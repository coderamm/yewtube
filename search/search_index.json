{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Overview","text":"<pre>\n                      _         _          \n                     | |       | |         \n  _   _  _____      _| |_ _   _| |__   ___ \n | | | |/ _ \\ \\ /\\ / / __| | | | '_ \\ / _ \\\n | |_| |  __/\\ V  V /| |_| |_| | |_) |  __/\n  \\__, |\\___| \\_/\\_/  \\__|\\__,_|_.__/ \\___|\n   __/ |                                   \n  |___/\n\n\n</pre> <p>yewtube, forked from mps-youtube , is a Terminal based YouTube player and downloader. No Youtube API key required.  Visit this page if you want to support maintainers of this project.</p>"},{"location":"#installation","title":"Installation","text":""},{"location":"#stable-version","title":"Stable Version","text":""},{"location":"#using-pip","title":"Using pip","text":"<ol> <li>Install using <code>pip install yewtube</code></li> <li>Run using, <code>yt</code>. Enjoy! </li> </ol>"},{"location":"#using-pipx-recommended","title":"Using pipx (Recommended)","text":"<ol> <li>Install pipx using <code>pip install pipx</code></li> <li>Install <code>yewtube</code> using <code>pipx install yewtube</code></li> <li>Now, type <code>yt</code> That's it.</li> </ol>"},{"location":"#latest-version","title":"Latest Version","text":""},{"location":"#using-pip_1","title":"Using pip","text":"<ol> <li>Install using <code>pip install git+https://github.com/mps-youtube/yewtube.git</code></li> <li>Run using, <code>yt</code>. Enjoy! </li> </ol>"},{"location":"#using-pipx","title":"Using pipx","text":"<ol> <li>Install pipx using <code>pip install pipx</code></li> <li>Install <code>yewtube</code> using <code>pipx install git+https://github.com/mps-youtube/yewtube.git</code></li> <li>Now, type <code>yt</code> That's it.</li> </ol>"},{"location":"#whats-new-in-yewtube","title":"What's new in yewtube?","text":"<ul> <li>No Youtube API Key required</li> <li>Run audio in VLC with no GUI</li> </ul> <p>See complete and up-to-date changelog here.</p> <p>These features are still inherited from mps-youtube. -   Search and play audio/video from YouTube -   Search tracks of albums by album title -   Search and import YouTube playlists -   Create and save local playlists -   Download audio/video -   Convert to mp3 &amp; other formats (requires ffmpeg or avconv) -   View video comments -   Works with Python 3.x -   Works with Windows, Linux and Mac OS X -   Requires mplayer, mpv or VLC</p> <p>This project is based on mps-youtube and mps-youtube is based on mps, a terminal based program to search, stream and download music. This implementation uses YouTube as a source of content and can play and download video as well as audio. The pafy  library handles interfacing with YouTube.</p> <p>mps-youtube wiki yewtube wiki</p>"},{"location":"#screenshots","title":"Screenshots","text":"<p>Search: </p> <p>A standard search is performed by entering <code>/</code> followed by search terms.</p> <p>You can play all of the search results by giving <code>1-</code> as input</p> <p>Repeating song/songs can be done with <code>song_number[loop]</code>, for example: <code>1[3]</code> or <code>4-6[2]</code></p> <p>Local Playlists: </p> <p>Search result items can easily be stored in local playlists.</p> <p>YouTube Playlists: </p> <p>YouTube playlists can be searched and played or saved as local playlists.</p> <p>A playlist search is performed by <code>//</code> followed by search term.</p> <p>Download: </p> <p>Content can be downloaded in various formats and resolutions.</p> <p>Comments: </p> <p>A basic comments browser is available to view YouTube user comments.</p> <p>Music Album Matching:</p> <p></p> <p></p> <p>An album title can be specified and yewtube will attempt to find matches for each track of the album, based on title and duration. Type <code>help search</code> for more info.</p> <p>Customisation:</p> <p></p> <p>Search results can be customised to display additional fields and ordered by various criteria.</p> <p>This configuration was set up using the following commands <pre><code>set order views\nset columns user:14 date comments rating likes dislikes category:9 views\n</code></pre></p> <p>Type <code>help config</code> for help on configuration options</p>"},{"location":"#upgrading","title":"Upgrading","text":""},{"location":"#if-installed-using-pipx","title":"If installed using pipx","text":"<p><code>pipx upgrade yewtube</code></p> <p>Optionally with upgrading all dependencies:</p> <p><code>pipx runpip yewtube install --upgrade-strategy eager --upgrade yewtube</code></p>"},{"location":"#if-installed-using-pip","title":"If installed using pip","text":"<p><code>pip install --upgrade yewtube</code></p> <p>Optionally with upgrading all dependencies:</p> <p><code>pip install --upgrade-strategy eager --upgrade yewtube</code></p>"},{"location":"#usage","title":"Usage","text":"<p>yewtube is run on the command line using the command:</p> <p><code>yt</code></p> <p>Enter <code>h</code> from within the program for help.</p>"},{"location":"#using-yewtube-with-mpv","title":"Using yewtube with mpv","text":"<p>If you have <code>mpv</code> player installed and you set it to be used as the player you can have yewtube to use its input bindings (with only a few usability changes done automatically by yewtube) by soft-linking to it from <code>~/.config/mps-youtube/mpv-input.conf</code> like so:</p> <pre><code>&gt; ln -sr ~/.config/mpv/input.conf ~/.config/mps-youtube/mpv-input.conf\n</code></pre>"},{"location":"#using-yewtube-with-mpris","title":"Using yewtube with mpris","text":"<ol> <li>Install PyGObject, GTK and their dependencies based on this guide https://pygobject.readthedocs.io/en/latest/getting_started.html</li> <li>Install yewtube with mpris extra</li> </ol> <pre><code>&gt; # recommended\n&gt; pipx install 'yewtube[mpris]'\n&gt; # or\n&gt; pip install 'yewtube[mpris]'\n</code></pre> <ol> <li>check yewtube version</li> </ol> <pre><code>&gt; yt --version\nyewtube version    : 2.8.2\nyt_dlp version     : 2022.02.04\nPython version     : 3.9.7 (default, Nov  7 2021, 15:17:57)\n[GCC 11.2.0]\nProcessor          : x86_64\nMachine type       : x86_64\nArchitecture       : 64bit, ELF\nPlatform           : Linux-5.13.0-35-generic-x86_64-with-glibc2.34\nsys.stdout.enc     : utf-8\ndefault enc        : utf-8\nConfig dir         : /home/user/.config/mps-youtube\ndbus               : 1.2.18\nglib               : True\nenv:TERM           : tmux-256color\nenv:SHELL          : /usr/bin/zsh\nenv:LANG           : en_US.UTF-8\n</code></pre> <p>If everything working correctly, dbug and glib would have similar result as above text</p> <ol> <li>run <code>set mpris true</code> on yewtube</li> <li>check with <code>playerctl</code></li> </ol> <pre><code>&gt; playerctl -l\nmps-youtube.instance567867\n</code></pre> <p>Check also the common-issue if you are having problem with yewtube.</p>"},{"location":"#how-to-contribute","title":"How to Contribute","text":"<p>Contributions are warmly welcomed! However, please check out the contribution page before making a contribution.</p>"},{"location":"changelog/","title":"CHANGELOG","text":""},{"location":"changelog/#v2121-2025-01-05","title":"v2.12.1 (2025-01-05)","text":""},{"location":"changelog/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Bump yt-dlp version to next stable release   (<code>1c79f11</code>)</li> </ul>"},{"location":"changelog/#chores","title":"Chores","text":"<ul> <li>Fixes #1303 1300 https &gt; 0.28 throws proxy can not be passed as argument error   (<code>7ab2fe2</code>)</li> </ul>"},{"location":"changelog/#documentation","title":"Documentation","text":"<ul> <li>Demonstrate how to use existing mpv input bindings   (#1289,   <code>2d89c3f</code>)</li> </ul> <p>demonstrate how to use existing mpv input bindings</p>"},{"location":"changelog/#v2120-2024-09-11","title":"v2.12.0 (2024-09-11)","text":""},{"location":"changelog/#chores_1","title":"Chores","text":"<ul> <li>Clean up setup.cfg   (<code>dfa42a2</code>)</li> </ul>"},{"location":"changelog/#v2117-2024-09-11","title":"v2.11.7 (2024-09-11)","text":""},{"location":"changelog/#bug-fixes_1","title":"Bug Fixes","text":"<ul> <li>Semantic_release version for pypi setup.py was stuck   (<code>f29e0b3</code>)</li> </ul>"},{"location":"changelog/#v2116-2024-09-11","title":"v2.11.6 (2024-09-11)","text":""},{"location":"changelog/#bug-fixes_2","title":"Bug Fixes","text":"<ul> <li>Wheel_recipe.sh   (<code>5005c1a</code>)</li> </ul>"},{"location":"changelog/#chores_2","title":"Chores","text":"<ul> <li>Update author email   (<code>6a5641c</code>)</li> </ul>"},{"location":"changelog/#v2115-2024-09-11","title":"v2.11.5 (2024-09-11)","text":""},{"location":"changelog/#v2114-2024-09-11","title":"v2.11.4 (2024-09-11)","text":""},{"location":"changelog/#v2113-2024-09-11","title":"v2.11.3 (2024-09-11)","text":""},{"location":"changelog/#documentation_1","title":"Documentation","text":"<ul> <li>Extend upgrade instructions (#1249,   <code>f62a5fd</code>)</li> </ul> <p>This adds the pip / pipx commands to upgrade all the dependencies. This makes directed actions like   https://github.com/mps-youtube/yewtube/issues/1225#issuecomment-1493400886 unnecessary.</p>"},{"location":"changelog/#v2105-2023-08-29","title":"v2.10.5 (2023-08-29)","text":""},{"location":"changelog/#bug-fixes_3","title":"Bug Fixes","text":"<p>Thanks to @galgot</p>"},{"location":"changelog/#1243-bumped-yt-dlp-version","title":"1243 bumped yt-dlp version","text":"<p>(<code>9ed4921</code>)</p>"},{"location":"changelog/#1243-bumped-yt-dlp-version_1","title":"1243 bumped yt-dlp version","text":"<p>(<code>4461d0c</code>)</p>"},{"location":"changelog/#v2104-2023-06-14","title":"v2.10.4 (2023-06-14)","text":""},{"location":"changelog/#bug-fixes_4","title":"Bug Fixes","text":""},{"location":"changelog/#806-pressing-q-doesnt-stops-playback-when-in-repeat-mode","title":"806 - pressing q doesn't stops playback when in repeat mode","text":"(<code>645617a</code>)"},{"location":"changelog/#chores_3","title":"Chores","text":"<ul> <li>Use pipenv   (<code>2edd0dd</code>)</li> </ul>"},{"location":"changelog/#v2103-2023-06-14","title":"v2.10.3 (2023-06-14)","text":""},{"location":"changelog/#v2102-2023-03-22","title":"v2.10.2 (2023-03-22)","text":""},{"location":"changelog/#bug-fixes_5","title":"Bug Fixes","text":"<ul> <li> <p>Shuffle all throwing error \"object does not support item assignment\"   (<code>13fb47b</code>)</p> </li> </ul>"},{"location":"changelog/#837-crashes-if-the-video-is-blocked-by-the-copyright-holder","title":"837 crashes if the video is blocked by the copyright holder","text":"<p>(<code>c472c7a</code>)</p>"},{"location":"changelog/#v2101-2023-03-21","title":"v2.10.1 (2023-03-21)","text":""},{"location":"changelog/#bug-fixes_6","title":"Bug Fixes","text":""},{"location":"changelog/#980-added-pylast-as-dependency-in-reqtxt","title":"980 added pylast as dependency in req.txt","text":"(<code>48cc757</code>)"},{"location":"changelog/#v2100-2023-03-21","title":"v2.10.0 (2023-03-21)","text":""},{"location":"changelog/#v294-2023-01-28","title":"v2.9.4 (2023-01-28)","text":""},{"location":"changelog/#bug-fixes_7","title":"Bug Fixes","text":"<ul> <li> <p>Semantic release python pypi receipe   (<code>495629a</code>)</p> </li> <li> <p>Updated readme metioned yewtube as fork of mpsyt   (<code>385d6a7</code>)</p> </li> </ul>"},{"location":"changelog/#documentation_2","title":"Documentation","text":"<ul> <li> <p>Added collaborators and contributors page   (<code>f258403</code>)</p> </li> <li> <p>Fix broken readme links   (<code>6d2d723</code>)</p> </li> </ul>"},{"location":"changelog/#features","title":"Features","text":"<ul> <li>Added subtitle suppport for vlc related to #331   (<code>96f2efd</code>)</li> </ul>"},{"location":"changelog/#v292-2023-01-26","title":"v2.9.2 (2023-01-26)","text":""},{"location":"changelog/#bug-fixes_8","title":"Bug Fixes","text":"<ul> <li>Remove pyreadline dependency (#105) (#107,   <code>19e4148</code>)</li> </ul> <p>It's unmaintained and yewtube works fine without it</p> <p>Co-authored-by: Francesco Gazzetta fgaz@fgaz.me</p>"},{"location":"changelog/#v291-2023-01-26","title":"v2.9.1 (2023-01-26)","text":""},{"location":"changelog/#bug-fixes_9","title":"Bug Fixes","text":""},{"location":"changelog/#50-brought-back-download-audio-file","title":"50 - brought back download audio file","text":"(<code>b46dab4</code>)"},{"location":"changelog/#v290-2022-10-20","title":"v2.9.0 (2022-10-20)","text":""},{"location":"changelog/#bug-fixes_10","title":"Bug Fixes","text":""},{"location":"changelog/#76-video-pops-up","title":"76 video pops up","text":"(<code>eaeff58</code>)"},{"location":"changelog/#features_1","title":"Features","text":"<ul> <li>mplayer: Set cache (#93,   <code>16d3a18</code>)</li> </ul>"},{"location":"changelog/#v285-2022-09-08","title":"v2.8.5 (2022-09-08)","text":""},{"location":"changelog/#bug-fixes_11","title":"Bug Fixes","text":"<ul> <li> <p>Enable quit-watch-later in mpv #77   (<code>079e440</code>)</p> </li> </ul> <p>Allows pressing shift-q to quit so mpv saves the video position and allows resuming on next play</p> <ul> <li>main: Handle error when setting locale (#86,   <code>ecd117c</code>)</li> </ul> <p>fix #85(main): handle error when setting locale</p>"},{"location":"changelog/#75-program-crashes-while-creating-custom-playlist-and-saving-it-without-playing","title":"75 program crashes while creating custom playlist and saving it without playing","text":"<p>(<code>2552eff</code>)</p>"},{"location":"changelog/#documentation_3","title":"Documentation","text":"<ul> <li> <p>Added common issues file. (#91,   <code>4b69e5e</code>)</p> </li> <li> <p>Added common issues file with some instructions for MacOS</p> </li> <li> <p>Modified readme with extra information about the common issue file</p> </li> </ul> <p>Co-authored-by: fazli.zekiqi fazli.zekiqi@cepheid.com</p>"},{"location":"changelog/#refactoring","title":"Refactoring","text":"<ul> <li>main: Use logging instead of warning (#88,   <code>32e7935</code>)</li> </ul>"},{"location":"changelog/#v284-2022-05-05","title":"v2.8.4 (2022-05-05)","text":""},{"location":"changelog/#bug-fixes_12","title":"Bug Fixes","text":""},{"location":"changelog/#53-viewing-playlists-uploaded-by-a-user-is-back","title":"53 viewing playlists uploaded by a user is back","text":"(<code>f201cb5</code>)"},{"location":"changelog/#v283-2022-04-25","title":"v2.8.3 (2022-04-25)","text":""},{"location":"changelog/#bug-fixes_13","title":"Bug Fixes","text":"<ul> <li> <p>Save full playlists by name and all its videos   (<code>d69a959</code>)</p> </li> </ul>"},{"location":"changelog/#45-fetch-all-videos-of-a-playlist","title":"45 fetch all videos of a playlist","text":"<p>(<code>261f468</code>)</p>"},{"location":"changelog/#67-vlc-dummy-interface-does-not-work-with-live-channels","title":"67 vlc dummy Interface does not work with live channels","text":"<p>(<code>2d4637b</code>)</p>"},{"location":"changelog/#v282-2022-03-17","title":"v2.8.2 (2022-03-17)","text":""},{"location":"changelog/#bug-fixes_14","title":"Bug Fixes","text":""},{"location":"changelog/#63-module-album-search-crash","title":"63 module album search crash","text":"(<code>3f2fcfb</code>)"},{"location":"changelog/#v281-2022-03-08","title":"v2.8.1 (2022-03-08)","text":""},{"location":"changelog/#bug-fixes_15","title":"Bug Fixes","text":"<ul> <li> <p>26 album search working now without youtube api   (<code>9c3ae03</code>)</p> </li> <li> <p>Bring back requirements.txt to life   (<code>ff6e59d</code>)</p> </li> <li> <p>Buffersize warning   (<code>d185c3f</code>)</p> </li> <li> <p>Check for app updates   (<code>eabfb52</code>)</p> </li> <li> <p>Default player priority is vlc &gt; mpv &gt; mplayer on first install fixed #16   (<code>35409eb</code>)</p> </li> <li> <p>Don't crash if playlists / history file has invalid youtube id fixed #24   (<code>323d5d8</code>)</p> </li> <li> <p>Playlists are working again fixed #18   (<code>bfceee4</code>)</p> </li> <li> <p>Use mkdocs instead of sphinx docs   (<code>32a2e9c</code>)</p> </li> <li> <p>build(setup): extras_require mkdocs</p> </li> <li> <p>package mkdocstrings-python-legacy</p> </li> <li> <p>refactor: check sys.stdout.encoding once</p> </li> </ul> <p>also isort module</p> <ul> <li> <p>docs: mkdocs</p> </li> <li> <p>skip_files for test files</p> </li> <li> <p>docs(CONTRIBUTING): mkdocs</p> </li> <li> <p>g: Mpv msglevel   (<code>062b125</code>)</p> </li> <li> <p>mplayer: _get_mplayer_version   (<code>ab21c5d</code>)</p> </li> <li> <p>isort module - type hint - function doc - return value type hint for func</p> </li> <li> <p>mpris: Handle no data on time-pos   (<code>8bb29d3</code>)</p> </li> <li> <p>util.uea_pad: Handle AttributeError on t.split   (<code>1643266</code>)</p> </li> </ul> <p>also isort import</p>"},{"location":"changelog/#24-colorama-support-for-windows","title":"24 colorama support for windows","text":"<p>(<code>9cf2616</code>)</p>"},{"location":"changelog/#28-show-changelog-with-help-new-command","title":"28 show changelog with <code>help new</code> command","text":"<p>(<code>d52b65d</code>)</p>"},{"location":"changelog/#35-remove-api-key-instructions","title":"35 remove api key instructions","text":"<p>(<code>4f1fee3</code>)</p>"},{"location":"changelog/#37-use-set-pages-command-to-config-how-many-search-result-pages-to-show","title":"37 use <code>set pages</code> command to config how many search result pages to show","text":"<p>(<code>2baec5f</code>)</p>"},{"location":"changelog/#38-improved-help-menu-responsiveness","title":"38 improved help menu responsiveness","text":"<p>(<code>972b4ef</code>)</p>"},{"location":"changelog/#39-key-error-data","title":"39 key error 'data'","text":"<p>(<code>834ed5b</code>)</p>"},{"location":"changelog/#44-dont-run-init-when-importing-mps_youtube","title":"44 dont run init when importing mps_youtube","text":"<p>(<code>a072c22</code>)</p>"},{"location":"changelog/#54-play-video-using-youtube-short-link","title":"54 play video using youtube short link","text":"<p>(<code>92d1c77</code>)</p>"},{"location":"changelog/#build-system","title":"Build System","text":"<ul> <li> <p>Include changelog   (<code>18390f5</code>)</p> </li> <li> <p>setup: Add requests   (<code>397eddd</code>)</p> </li> </ul>"},{"location":"changelog/#continuous-integration","title":"Continuous Integration","text":"<ul> <li> <p>Python-app   (<code>f40ca1a</code>)</p> </li> <li> <p>python-app: Workflows based on origin/develop   (<code>3d117ad</code>)</p> </li> <li> <p>only run pytest - use matrix for python version and os</p> </li> </ul>"},{"location":"changelog/#features_2","title":"Features","text":"<ul> <li> <p>Use yewtube over tor using torsocks \ud83d\udd25   (<code>1e9c4ce</code>)</p> </li> <li> <p>helptext: Help changelog   (<code>0643941</code>)</p> </li> <li> <p>setup: Extras dependencies for mpris   (<code>936e890</code>)</p> </li> </ul>"},{"location":"changelog/#refactoring_1","title":"Refactoring","text":"<ul> <li>Reset to upstream   (<code>dc4af72</code>)</li> </ul>"},{"location":"changelog/#testing","title":"Testing","text":"<ul> <li> <p>Uea_pad   (<code>22b4564</code>)</p> </li> <li> <p>mplayer: _get_mplayer_version   (<code>9c2350c</code>)</p> </li> </ul> <p>use default func behavior when no mplayer found</p> <ul> <li> <p>mpris: Test_mpris.setproperty   (<code>10ec94a</code>)</p> </li> <li> <p>Mpris2Controller: Init   (<code>cb977ec</code>)</p> </li> <li> <p>test_main: Skip test without attribute after fork   (<code>35ded20</code>)</p> </li> </ul>"},{"location":"changelog/#v264-2022-02-16","title":"v2.6.4 (2022-02-16)","text":""},{"location":"changelog/#bug-fixes_16","title":"Bug Fixes","text":"<ul> <li>Duplicate changelog and readme files   (<code>0265ef7</code>)</li> </ul>"},{"location":"changelog/#v263-2022-02-16","title":"v2.6.3 (2022-02-16)","text":""},{"location":"changelog/#bug-fixes_17","title":"Bug Fixes","text":"<ul> <li> <p>Welcome from semantic release python   (<code>c237a68</code>)</p> </li> <li> <p>setup: Use semantic versioning   (<code>2e100e7</code>)</p> </li> </ul>"},{"location":"changelog/#build-system_1","title":"Build System","text":"<ul> <li>setup: Fix long_description_content_type   (<code>db30143</code>)</li> </ul>"},{"location":"changelog/#features_3","title":"Features","text":"<ul> <li> <p>setup: Restrict pyreadline3 to windows only   (<code>7ebbf20</code>)</p> </li> <li> <p>setup: Restrict python version   (<code>b9bc61f</code>)</p> </li> </ul>"},{"location":"changelog/#refactoring_2","title":"Refactoring","text":"<ul> <li>setup: Check for minimum python 3.6   (<code>f5b5d73</code>)</li> </ul>"},{"location":"changelog/#v028-2018-02-17","title":"v0.2.8 (2018-02-17)","text":""},{"location":"changelog/#v027-2016-06-27","title":"v0.2.7 (2016-06-27)","text":""},{"location":"changelog/#v026-2016-01-01","title":"v0.2.6 (2016-01-01)","text":""},{"location":"changelog/#v025-2015-06-01","title":"v0.2.5 (2015-06-01)","text":""},{"location":"changelog/#v024-2015-05-13","title":"v0.2.4 (2015-05-13)","text":""},{"location":"changelog/#v023-2015-02-17","title":"v0.2.3 (2015-02-17)","text":""},{"location":"changelog/#v022-2015-02-14","title":"v0.2.2 (2015-02-14)","text":""},{"location":"changelog/#v021-2014-11-27","title":"v0.2.1 (2014-11-27)","text":""},{"location":"changelog/#v020-2014-11-25","title":"v0.2.0 (2014-11-25)","text":""},{"location":"contributing/","title":"Contributing for yewtube","text":"<p>Contributions are very much appreciated!</p> <ul> <li> <p>Pull requests should be based on and submitted to the \"develop\" branch.</p> </li> <li> <p>Please raise an issue to discuss what you plan to implement or change before  you start if it is going to involve a lot of work on your part.</p> </li> <li> <p>Please keep pull requests specific, do not make many disparate changes or new features in one request.  A separate pull request for each feature change is preferred.</p> </li> <li> <p>Please ensure your changes work in Python 3.3+ and Windows.</p> </li> </ul>"},{"location":"contributing/#code-conventions","title":"Code conventions","text":"<ul> <li> <p>Maximum line length is 80 characters</p> </li> <li> <p>Follow the line-spacing style that is already in place.</p> </li> <li> <p>Ensure all functions and classes have a PEP257 compliant docstring and the code is PEP8 compliant.</p> </li> </ul>"},{"location":"contributing/#documentation","title":"Documentation","text":"<p>Install required extra docs package to setup mkdocs: <code>pip install -e \".[docs]\"</code></p> <p>To run built-in dev server: <code>mkdocs serve</code></p> <p>To deploy documentation to github page: <code>mkdocs gh-deploy</code></p>"},{"location":"license/","title":"License","text":"<pre><code>GNU GENERAL PUBLIC LICENSE\n                       Version 3, 29 June 2007\n\n Copyright (C) 2007 Free Software Foundation, Inc. {http://fsf.org/}\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The GNU General Public License is a free, copyleft license for\nsoftware and other kinds of works.\n\n  The licenses for most software and other practical works are designed\nto take away your freedom to share and change the works.  By contrast,\nthe GNU General Public License is intended to guarantee your freedom to\nshare and change all versions of a program--to make sure it remains free\nsoftware for all its users.  We, the Free Software Foundation, use the\nGNU General Public License for most of our software; it applies also to\nany other work released this way by its authors.  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthem if you wish), that you receive source code or can get it if you\nwant it, that you can change the software or use pieces of it in new\nfree programs, and that you know you can do these things.\n\n  To protect your rights, we need to prevent others from denying you\nthese rights or asking you to surrender the rights.  Therefore, you have\ncertain responsibilities if you distribute copies of the software, or if\nyou modify it: responsibilities to respect the freedom of others.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must pass on to the recipients the same\nfreedoms that you received.  You must make sure that they, too, receive\nor can get the source code.  And you must show them these terms so they\nknow their rights.\n\n  Developers that use the GNU GPL protect your rights with two steps:\n(1) assert copyright on the software, and (2) offer you this License\ngiving you legal permission to copy, distribute and/or modify it.\n\n  For the developers' and authors' protection, the GPL clearly explains\nthat there is no warranty for this free software.  For both users' and\nauthors' sake, the GPL requires that modified versions be marked as\nchanged, so that their problems will not be attributed erroneously to\nauthors of previous versions.\n\n  Some devices are designed to deny users access to install or run\nmodified versions of the software inside them, although the manufacturer\ncan do so.  This is fundamentally incompatible with the aim of\nprotecting users' freedom to change the software.  The systematic\npattern of such abuse occurs in the area of products for individuals to\nuse, which is precisely where it is most unacceptable.  Therefore, we\nhave designed this version of the GPL to prohibit the practice for those\nproducts.  If such problems arise substantially in other domains, we\nstand ready to extend this provision to those domains in future versions\nof the GPL, as needed to protect the freedom of users.\n\n  Finally, every program is threatened constantly by software patents.\nStates should not allow patents to restrict development and use of\nsoftware on general-purpose computers, but in those that do, we wish to\navoid the special danger that patents applied to a free program could\nmake it effectively proprietary.  To prevent this, the GPL assures that\npatents cannot be used to render the program non-free.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                       TERMS AND CONDITIONS\n\n  0. Definitions.\n\n  \"This License\" refers to version 3 of the GNU General Public License.\n\n  \"Copyright\" also means copyright-like laws that apply to other kinds of\nworks, such as semiconductor masks.\n\n  \"The Program\" refers to any copyrightable work licensed under this\nLicense.  Each licensee is addressed as \"you\".  \"Licensees\" and\n\"recipients\" may be individuals or organizations.\n\n  To \"modify\" a work means to copy from or adapt all or part of the work\nin a fashion requiring copyright permission, other than the making of an\nexact copy.  The resulting work is called a \"modified version\" of the\nearlier work or a work \"based on\" the earlier work.\n\n  A \"covered work\" means either the unmodified Program or a work based\non the Program.\n\n  To \"propagate\" a work means to do anything with it that, without\npermission, would make you directly or secondarily liable for\ninfringement under applicable copyright law, except executing it on a\ncomputer or modifying a private copy.  Propagation includes copying,\ndistribution (with or without modification), making available to the\npublic, and in some countries other activities as well.\n\n  To \"convey\" a work means any kind of propagation that enables other\nparties to make or receive copies.  Mere interaction with a user through\na computer network, with no transfer of a copy, is not conveying.\n\n  An interactive user interface displays \"Appropriate Legal Notices\"\nto the extent that it includes a convenient and prominently visible\nfeature that (1) displays an appropriate copyright notice, and (2)\ntells the user that there is no warranty for the work (except to the\nextent that warranties are provided), that licensees may convey the\nwork under this License, and how to view a copy of this License.  If\nthe interface presents a list of user commands or options, such as a\nmenu, a prominent item in the list meets this criterion.\n\n  1. Source Code.\n\n  The \"source code\" for a work means the preferred form of the work\nfor making modifications to it.  \"Object code\" means any non-source\nform of a work.\n\n  A \"Standard Interface\" means an interface that either is an official\nstandard defined by a recognized standards body, or, in the case of\ninterfaces specified for a particular programming language, one that\nis widely used among developers working in that language.\n\n  The \"System Libraries\" of an executable work include anything, other\nthan the work as a whole, that (a) is included in the normal form of\npackaging a Major Component, but which is not part of that Major\nComponent, and (b) serves only to enable use of the work with that\nMajor Component, or to implement a Standard Interface for which an\nimplementation is available to the public in source code form.  A\n\"Major Component\", in this context, means a major essential component\n(kernel, window system, and so on) of the specific operating system\n(if any) on which the executable work runs, or a compiler used to\nproduce the work, or an object code interpreter used to run it.\n\n  The \"Corresponding Source\" for a work in object code form means all\nthe source code needed to generate, install, and (for an executable\nwork) run the object code and to modify the work, including scripts to\ncontrol those activities.  However, it does not include the work's\nSystem Libraries, or general-purpose tools or generally available free\nprograms which are used unmodified in performing those activities but\nwhich are not part of the work.  For example, Corresponding Source\nincludes interface definition files associated with source files for\nthe work, and the source code for shared libraries and dynamically\nlinked subprograms that the work is specifically designed to require,\nsuch as by intimate data communication or control flow between those\nsubprograms and other parts of the work.\n\n  The Corresponding Source need not include anything that users\ncan regenerate automatically from other parts of the Corresponding\nSource.\n\n  The Corresponding Source for a work in source code form is that\nsame work.\n\n  2. Basic Permissions.\n\n  All rights granted under this License are granted for the term of\ncopyright on the Program, and are irrevocable provided the stated\nconditions are met.  This License explicitly affirms your unlimited\npermission to run the unmodified Program.  The output from running a\ncovered work is covered by this License only if the output, given its\ncontent, constitutes a covered work.  This License acknowledges your\nrights of fair use or other equivalent, as provided by copyright law.\n\n  You may make, run and propagate covered works that you do not\nconvey, without conditions so long as your license otherwise remains\nin force.  You may convey covered works to others for the sole purpose\nof having them make modifications exclusively for you, or provide you\nwith facilities for running those works, provided that you comply with\nthe terms of this License in conveying all material for which you do\nnot control copyright.  Those thus making or running the covered works\nfor you must do so exclusively on your behalf, under your direction\nand control, on terms that prohibit them from making any copies of\nyour copyrighted material outside their relationship with you.\n\n  Conveying under any other circumstances is permitted solely under\nthe conditions stated below.  Sublicensing is not allowed; section 10\nmakes it unnecessary.\n\n  3. Protecting Users' Legal Rights From Anti-Circumvention Law.\n\n  No covered work shall be deemed part of an effective technological\nmeasure under any applicable law fulfilling obligations under article\n11 of the WIPO copyright treaty adopted on 20 December 1996, or\nsimilar laws prohibiting or restricting circumvention of such\nmeasures.\n\n  When you convey a covered work, you waive any legal power to forbid\ncircumvention of technological measures to the extent such circumvention\nis effected by exercising rights under this License with respect to\nthe covered work, and you disclaim any intention to limit operation or\nmodification of the work as a means of enforcing, against the work's\nusers, your or third parties' legal rights to forbid circumvention of\ntechnological measures.\n\n  4. Conveying Verbatim Copies.\n\n  You may convey verbatim copies of the Program's source code as you\nreceive it, in any medium, provided that you conspicuously and\nappropriately publish on each copy an appropriate copyright notice;\nkeep intact all notices stating that this License and any\nnon-permissive terms added in accord with section 7 apply to the code;\nkeep intact all notices of the absence of any warranty; and give all\nrecipients a copy of this License along with the Program.\n\n  You may charge any price or no price for each copy that you convey,\nand you may offer support or warranty protection for a fee.\n\n  5. Conveying Modified Source Versions.\n\n  You may convey a work based on the Program, or the modifications to\nproduce it from the Program, in the form of source code under the\nterms of section 4, provided that you also meet all of these conditions:\n\n    a) The work must carry prominent notices stating that you modified\n    it, and giving a relevant date.\n\n    b) The work must carry prominent notices stating that it is\n    released under this License and any conditions added under section\n    7.  This requirement modifies the requirement in section 4 to\n    \"keep intact all notices\".\n\n    c) You must license the entire work, as a whole, under this\n    License to anyone who comes into possession of a copy.  This\n    License will therefore apply, along with any applicable section 7\n    additional terms, to the whole of the work, and all its parts,\n    regardless of how they are packaged.  This License gives no\n    permission to license the work in any other way, but it does not\n    invalidate such permission if you have separately received it.\n\n    d) If the work has interactive user interfaces, each must display\n    Appropriate Legal Notices; however, if the Program has interactive\n    interfaces that do not display Appropriate Legal Notices, your\n    work need not make them do so.\n\n  A compilation of a covered work with other separate and independent\nworks, which are not by their nature extensions of the covered work,\nand which are not combined with it such as to form a larger program,\nin or on a volume of a storage or distribution medium, is called an\n\"aggregate\" if the compilation and its resulting copyright are not\nused to limit the access or legal rights of the compilation's users\nbeyond what the individual works permit.  Inclusion of a covered work\nin an aggregate does not cause this License to apply to the other\nparts of the aggregate.\n\n  6. Conveying Non-Source Forms.\n\n  You may convey a covered work in object code form under the terms\nof sections 4 and 5, provided that you also convey the\nmachine-readable Corresponding Source under the terms of this License,\nin one of these ways:\n\n    a) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by the\n    Corresponding Source fixed on a durable physical medium\n    customarily used for software interchange.\n\n    b) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by a\n    written offer, valid for at least three years and valid for as\n    long as you offer spare parts or customer support for that product\n    model, to give anyone who possesses the object code either (1) a\n    copy of the Corresponding Source for all the software in the\n    product that is covered by this License, on a durable physical\n    medium customarily used for software interchange, for a price no\n    more than your reasonable cost of physically performing this\n    conveying of source, or (2) access to copy the\n    Corresponding Source from a network server at no charge.\n\n    c) Convey individual copies of the object code with a copy of the\n    written offer to provide the Corresponding Source.  This\n    alternative is allowed only occasionally and noncommercially, and\n    only if you received the object code with such an offer, in accord\n    with subsection 6b.\n\n    d) Convey the object code by offering access from a designated\n    place (gratis or for a charge), and offer equivalent access to the\n    Corresponding Source in the same way through the same place at no\n    further charge.  You need not require recipients to copy the\n    Corresponding Source along with the object code.  If the place to\n    copy the object code is a network server, the Corresponding Source\n    may be on a different server (operated by you or a third party)\n    that supports equivalent copying facilities, provided you maintain\n    clear directions next to the object code saying where to find the\n    Corresponding Source.  Regardless of what server hosts the\n    Corresponding Source, you remain obligated to ensure that it is\n    available for as long as needed to satisfy these requirements.\n\n    e) Convey the object code using peer-to-peer transmission, provided\n    you inform other peers where the object code and Corresponding\n    Source of the work are being offered to the general public at no\n    charge under subsection 6d.\n\n  A separable portion of the object code, whose source code is excluded\nfrom the Corresponding Source as a System Library, need not be\nincluded in conveying the object code work.\n\n  A \"User Product\" is either (1) a \"consumer product\", which means any\ntangible personal property which is normally used for personal, family,\nor household purposes, or (2) anything designed or sold for incorporation\ninto a dwelling.  In determining whether a product is a consumer product,\ndoubtful cases shall be resolved in favor of coverage.  For a particular\nproduct received by a particular user, \"normally used\" refers to a\ntypical or common use of that class of product, regardless of the status\nof the particular user or of the way in which the particular user\nactually uses, or expects or is expected to use, the product.  A product\nis a consumer product regardless of whether the product has substantial\ncommercial, industrial or non-consumer uses, unless such uses represent\nthe only significant mode of use of the product.\n\n  \"Installation Information\" for a User Product means any methods,\nprocedures, authorization keys, or other information required to install\nand execute modified versions of a covered work in that User Product from\na modified version of its Corresponding Source.  The information must\nsuffice to ensure that the continued functioning of the modified object\ncode is in no case prevented or interfered with solely because\nmodification has been made.\n\n  If you convey an object code work under this section in, or with, or\nspecifically for use in, a User Product, and the conveying occurs as\npart of a transaction in which the right of possession and use of the\nUser Product is transferred to the recipient in perpetuity or for a\nfixed term (regardless of how the transaction is characterized), the\nCorresponding Source conveyed under this section must be accompanied\nby the Installation Information.  But this requirement does not apply\nif neither you nor any third party retains the ability to install\nmodified object code on the User Product (for example, the work has\nbeen installed in ROM).\n\n  The requirement to provide Installation Information does not include a\nrequirement to continue to provide support service, warranty, or updates\nfor a work that has been modified or installed by the recipient, or for\nthe User Product in which it has been modified or installed.  Access to a\nnetwork may be denied when the modification itself materially and\nadversely affects the operation of the network or violates the rules and\nprotocols for communication across the network.\n\n  Corresponding Source conveyed, and Installation Information provided,\nin accord with this section must be in a format that is publicly\ndocumented (and with an implementation available to the public in\nsource code form), and must require no special password or key for\nunpacking, reading or copying.\n\n  7. Additional Terms.\n\n  \"Additional permissions\" are terms that supplement the terms of this\nLicense by making exceptions from one or more of its conditions.\nAdditional permissions that are applicable to the entire Program shall\nbe treated as though they were included in this License, to the extent\nthat they are valid under applicable law.  If additional permissions\napply only to part of the Program, that part may be used separately\nunder those permissions, but the entire Program remains governed by\nthis License without regard to the additional permissions.\n\n  When you convey a copy of a covered work, you may at your option\nremove any additional permissions from that copy, or from any part of\nit.  (Additional permissions may be written to require their own\nremoval in certain cases when you modify the work.)  You may place\nadditional permissions on material, added by you to a covered work,\nfor which you have or can give appropriate copyright permission.\n\n  Notwithstanding any other provision of this License, for material you\nadd to a covered work, you may (if authorized by the copyright holders of\nthat material) supplement the terms of this License with terms:\n\n    a) Disclaiming warranty or limiting liability differently from the\n    terms of sections 15 and 16 of this License; or\n\n    b) Requiring preservation of specified reasonable legal notices or\n    author attributions in that material or in the Appropriate Legal\n    Notices displayed by works containing it; or\n\n    c) Prohibiting misrepresentation of the origin of that material, or\n    requiring that modified versions of such material be marked in\n    reasonable ways as different from the original version; or\n\n    d) Limiting the use for publicity purposes of names of licensors or\n    authors of the material; or\n\n    e) Declining to grant rights under trademark law for use of some\n    trade names, trademarks, or service marks; or\n\n    f) Requiring indemnification of licensors and authors of that\n    material by anyone who conveys the material (or modified versions of\n    it) with contractual assumptions of liability to the recipient, for\n    any liability that these contractual assumptions directly impose on\n    those licensors and authors.\n\n  All other non-permissive additional terms are considered \"further\nrestrictions\" within the meaning of section 10.  If the Program as you\nreceived it, or any part of it, contains a notice stating that it is\ngoverned by this License along with a term that is a further\nrestriction, you may remove that term.  If a license document contains\na further restriction but permits relicensing or conveying under this\nLicense, you may add to a covered work material governed by the terms\nof that license document, provided that the further restriction does\nnot survive such relicensing or conveying.\n\n  If you add terms to a covered work in accord with this section, you\nmust place, in the relevant source files, a statement of the\nadditional terms that apply to those files, or a notice indicating\nwhere to find the applicable terms.\n\n  Additional terms, permissive or non-permissive, may be stated in the\nform of a separately written license, or stated as exceptions;\nthe above requirements apply either way.\n\n  8. Termination.\n\n  You may not propagate or modify a covered work except as expressly\nprovided under this License.  Any attempt otherwise to propagate or\nmodify it is void, and will automatically terminate your rights under\nthis License (including any patent licenses granted under the third\nparagraph of section 11).\n\n  However, if you cease all violation of this License, then your\nlicense from a particular copyright holder is reinstated (a)\nprovisionally, unless and until the copyright holder explicitly and\nfinally terminates your license, and (b) permanently, if the copyright\nholder fails to notify you of the violation by some reasonable means\nprior to 60 days after the cessation.\n\n  Moreover, your license from a particular copyright holder is\nreinstated permanently if the copyright holder notifies you of the\nviolation by some reasonable means, this is the first time you have\nreceived notice of violation of this License (for any work) from that\ncopyright holder, and you cure the violation prior to 30 days after\nyour receipt of the notice.\n\n  Termination of your rights under this section does not terminate the\nlicenses of parties who have received copies or rights from you under\nthis License.  If your rights have been terminated and not permanently\nreinstated, you do not qualify to receive new licenses for the same\nmaterial under section 10.\n\n  9. Acceptance Not Required for Having Copies.\n\n  You are not required to accept this License in order to receive or\nrun a copy of the Program.  Ancillary propagation of a covered work\noccurring solely as a consequence of using peer-to-peer transmission\nto receive a copy likewise does not require acceptance.  However,\nnothing other than this License grants you permission to propagate or\nmodify any covered work.  These actions infringe copyright if you do\nnot accept this License.  Therefore, by modifying or propagating a\ncovered work, you indicate your acceptance of this License to do so.\n\n  10. Automatic Licensing of Downstream Recipients.\n\n  Each time you convey a covered work, the recipient automatically\nreceives a license from the original licensors, to run, modify and\npropagate that work, subject to this License.  You are not responsible\nfor enforcing compliance by third parties with this License.\n\n  An \"entity transaction\" is a transaction transferring control of an\norganization, or substantially all assets of one, or subdividing an\norganization, or merging organizations.  If propagation of a covered\nwork results from an entity transaction, each party to that\ntransaction who receives a copy of the work also receives whatever\nlicenses to the work the party's predecessor in interest had or could\ngive under the previous paragraph, plus a right to possession of the\nCorresponding Source of the work from the predecessor in interest, if\nthe predecessor has it or can get it with reasonable efforts.\n\n  You may not impose any further restrictions on the exercise of the\nrights granted or affirmed under this License.  For example, you may\nnot impose a license fee, royalty, or other charge for exercise of\nrights granted under this License, and you may not initiate litigation\n(including a cross-claim or counterclaim in a lawsuit) alleging that\nany patent claim is infringed by making, using, selling, offering for\nsale, or importing the Program or any portion of it.\n\n  11. Patents.\n\n  A \"contributor\" is a copyright holder who authorizes use under this\nLicense of the Program or a work on which the Program is based.  The\nwork thus licensed is called the contributor's \"contributor version\".\n\n  A contributor's \"essential patent claims\" are all patent claims\nowned or controlled by the contributor, whether already acquired or\nhereafter acquired, that would be infringed by some manner, permitted\nby this License, of making, using, or selling its contributor version,\nbut do not include claims that would be infringed only as a\nconsequence of further modification of the contributor version.  For\npurposes of this definition, \"control\" includes the right to grant\npatent sublicenses in a manner consistent with the requirements of\nthis License.\n\n  Each contributor grants you a non-exclusive, worldwide, royalty-free\npatent license under the contributor's essential patent claims, to\nmake, use, sell, offer for sale, import and otherwise run, modify and\npropagate the contents of its contributor version.\n\n  In the following three paragraphs, a \"patent license\" is any express\nagreement or commitment, however denominated, not to enforce a patent\n(such as an express permission to practice a patent or covenant not to\nsue for patent infringement).  To \"grant\" such a patent license to a\nparty means to make such an agreement or commitment not to enforce a\npatent against the party.\n\n  If you convey a covered work, knowingly relying on a patent license,\nand the Corresponding Source of the work is not available for anyone\nto copy, free of charge and under the terms of this License, through a\npublicly available network server or other readily accessible means,\nthen you must either (1) cause the Corresponding Source to be so\navailable, or (2) arrange to deprive yourself of the benefit of the\npatent license for this particular work, or (3) arrange, in a manner\nconsistent with the requirements of this License, to extend the patent\nlicense to downstream recipients.  \"Knowingly relying\" means you have\nactual knowledge that, but for the patent license, your conveying the\ncovered work in a country, or your recipient's use of the covered work\nin a country, would infringe one or more identifiable patents in that\ncountry that you have reason to believe are valid.\n\n  If, pursuant to or in connection with a single transaction or\narrangement, you convey, or propagate by procuring conveyance of, a\ncovered work, and grant a patent license to some of the parties\nreceiving the covered work authorizing them to use, propagate, modify\nor convey a specific copy of the covered work, then the patent license\nyou grant is automatically extended to all recipients of the covered\nwork and works based on it.\n\n  A patent license is \"discriminatory\" if it does not include within\nthe scope of its coverage, prohibits the exercise of, or is\nconditioned on the non-exercise of one or more of the rights that are\nspecifically granted under this License.  You may not convey a covered\nwork if you are a party to an arrangement with a third party that is\nin the business of distributing software, under which you make payment\nto the third party based on the extent of your activity of conveying\nthe work, and under which the third party grants, to any of the\nparties who would receive the covered work from you, a discriminatory\npatent license (a) in connection with copies of the covered work\nconveyed by you (or copies made from those copies), or (b) primarily\nfor and in connection with specific products or compilations that\ncontain the covered work, unless you entered into that arrangement,\nor that patent license was granted, prior to 28 March 2007.\n\n  Nothing in this License shall be construed as excluding or limiting\nany implied license or other defenses to infringement that may\notherwise be available to you under applicable patent law.\n\n  12. No Surrender of Others' Freedom.\n\n  If conditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot convey a\ncovered work so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you may\nnot convey it at all.  For example, if you agree to terms that obligate you\nto collect a royalty for further conveying from those to whom you convey\nthe Program, the only way you could satisfy both those terms and this\nLicense would be to refrain entirely from conveying the Program.\n\n  13. Use with the GNU Affero General Public License.\n\n  Notwithstanding any other provision of this License, you have\npermission to link or combine any covered work with a work licensed\nunder version 3 of the GNU Affero General Public License into a single\ncombined work, and to convey the resulting work.  The terms of this\nLicense will continue to apply to the part which is the covered work,\nbut the special requirements of the GNU Affero General Public License,\nsection 13, concerning interaction through a network will apply to the\ncombination as such.\n\n  14. Revised Versions of this License.\n\n  The Free Software Foundation may publish revised and/or new versions of\nthe GNU General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\n  Each version is given a distinguishing version number.  If the\nProgram specifies that a certain numbered version of the GNU General\nPublic License \"or any later version\" applies to it, you have the\noption of following the terms and conditions either of that numbered\nversion or of any later version published by the Free Software\nFoundation.  If the Program does not specify a version number of the\nGNU General Public License, you may choose any version ever published\nby the Free Software Foundation.\n\n  If the Program specifies that a proxy can decide which future\nversions of the GNU General Public License can be used, that proxy's\npublic statement of acceptance of a version permanently authorizes you\nto choose that version for the Program.\n\n  Later license versions may give you additional or different\npermissions.  However, no additional obligations are imposed on any\nauthor or copyright holder as a result of your choosing to follow a\nlater version.\n\n  15. Disclaimer of Warranty.\n\n  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY\nAPPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT\nHOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY\nOF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\nPURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM\nIS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF\nALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\n  16. Limitation of Liability.\n\n  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS\nTHE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY\nGENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE\nUSE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF\nDATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD\nPARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),\nEVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF\nSUCH DAMAGES.\n\n  17. Interpretation of Sections 15 and 16.\n\n  If the disclaimer of warranty and limitation of liability provided\nabove cannot be given local legal effect according to their terms,\nreviewing courts shall apply local law that most closely approximates\nan absolute waiver of all civil liability in connection with the\nProgram, unless a warranty or assumption of liability accompanies a\ncopy of the Program in return for a fee.\n\n                     END OF TERMS AND CONDITIONS\n\n            How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nstate the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    {one line to give the program's name and a brief idea of what it does.}\n    Copyright (C) {year}  {name of author}\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see {http://www.gnu.org/licenses/}.\n\nAlso add information on how to contact you by electronic and paper mail.\n\n  If the program does terminal interaction, make it output a short\nnotice like this when it starts in an interactive mode:\n\n    &lt;program&gt;  Copyright (C) &lt;year&gt;  &lt;name of author&gt;\n    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, your program's commands\nmight be different; for a GUI interface, you would use an \"about box\".\n\n  You should also get your employer (if you work as a programmer) or school,\nif any, to sign a \"copyright disclaimer\" for the program, if necessary.\nFor more information on this, and how to apply and follow the GNU GPL, see\n{http://www.gnu.org/licenses/}.\n\n  The GNU General Public License does not permit incorporating your program\ninto proprietary programs.  If your program is a subroutine library, you\nmay consider it more useful to permit linking proprietary applications with\nthe library.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.  But first, please read\n{http://www.gnu.org/philosophy/why-not-lgpl.html}.\n</code></pre>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>mps_youtube<ul> <li>__init__.py</li> <li>c.py</li> <li>cache.py</li> <li>commands<ul> <li>__init__.py</li> <li>album_search.py</li> <li>config.py</li> <li>download.py</li> <li>generate_playlist.py</li> <li>lastfm.py</li> <li>local_playlist.py</li> <li>misc.py</li> <li>play.py</li> <li>search.py</li> <li>songlist.py</li> <li>spotify_playlist.py</li> </ul> </li> <li>content.py</li> <li>contentquery.py</li> <li>description_parser.py</li> <li>g.py</li> <li>helptext.py</li> <li>history.py</li> <li>init.py</li> <li>listview<ul> <li>__init__.py</li> <li>base.py</li> <li>livestream.py</li> <li>songtitle.py</li> <li>user.py</li> </ul> </li> <li>main.py</li> <li>pafy.py</li> <li>paths.py</li> <li>player.py</li> <li>players<ul> <li>__init__.py</li> <li>GenericPlayer.py</li> <li>mplayer.py</li> <li>mpv.py</li> <li>vlc.py</li> </ul> </li> <li>playlist.py</li> <li>playlists.py</li> <li>screen.py</li> <li>streams.py</li> <li>terminalsize.py</li> <li>util.py</li> </ul> </li> </ul>"},{"location":"reference/__init__/","title":"__init__.py","text":""},{"location":"reference/c/","title":"c.py","text":"<p>Module for holding colour code values. </p>"},{"location":"reference/c/#mps_youtube.c.c","title":"<code>c(colour, text)</code>","text":"<p>Return coloured text. </p> Source code in <code>mps_youtube\\c.py</code> <pre><code>def c(colour, text):\n    \"\"\" Return coloured text. \"\"\"\n    colours = {'r': r, 'g': g, 'y': y, 'b':b, 'p':p}\n    return colours[colour] + text + w\n</code></pre>"},{"location":"reference/c/#mps_youtube.c.charcount","title":"<code>charcount(s)</code>","text":"<p>Return number of characters in string, with ANSI color codes excluded. </p> Source code in <code>mps_youtube\\c.py</code> <pre><code>def charcount(s):\n    \"\"\" Return number of characters in string, with ANSI color codes excluded. \"\"\"\n    return len(ansirx.sub('', s))\n</code></pre>"},{"location":"reference/cache/","title":"cache.py","text":""},{"location":"reference/cache/#mps_youtube.cache.load","title":"<code>load()</code>","text":"<p>Import cache file. </p> Source code in <code>mps_youtube\\cache.py</code> <pre><code>def load():\n    \"\"\" Import cache file. \"\"\"\n    if os.path.isfile(g.CACHEFILE):\n\n        try:\n\n            with open(g.CACHEFILE, \"rb\") as cf:\n                cached = pickle.load(cf)\n\n            # Note: will be none for yewtube 0.2.5 or earlier\n            version = cached.get('version')\n\n            if 'streams' in cached:\n                if version and version &gt;= 1:\n                    g.streams = cached['streams']\n                    g.username_query_cache = cached['userdata']\n            else:\n                g.streams = cached\n\n            if 'pafy' in cached:\n                pass\n                #pafy.load_cache(cached['pafy'])\n\n            dbg(c.g + \"%s cached streams imported%s\", str(len(g.streams)), c.w)\n\n        except (EOFError, IOError):\n            dbg(c.r + \"Cache file failed to open\" + c.w)\n\n        streams.prune()\n</code></pre>"},{"location":"reference/cache/#mps_youtube.cache.save","title":"<code>save()</code>","text":"<p>Save stream cache. </p> Source code in <code>mps_youtube\\cache.py</code> <pre><code>def save():\n    \"\"\" Save stream cache. \"\"\"\n    caches = dict(\n        version=CACHE_VERSION,\n        streams=g.streams,\n        userdata=g.username_query_cache\n        #,pafy=pafy.dump_cache()\n    )\n\n    with open(g.CACHEFILE, \"wb\") as cf:\n        pickle.dump(caches, cf, protocol=2)\n\n    dbg(c.p + \"saved cache file: \" + g.CACHEFILE + c.w)\n</code></pre>"},{"location":"reference/content/","title":"content.py","text":""},{"location":"reference/content/#mps_youtube.content.generate_playlist_display","title":"<code>generate_playlist_display()</code>","text":"<p>Generate list of playlists. </p> Source code in <code>mps_youtube\\content.py</code> <pre><code>def generate_playlist_display():\n    \"\"\" Generate list of playlists. \"\"\"\n\n    if not g.ytpls:\n        g.message = c.r + \"No playlists found!\"\n        return logo(c.g) + \"\\n\\n\"\n    g.rprompt = page_msg(g.current_page)\n\n    cw = getxy().width\n    fmtrow = \"%s%-5s %s %-12s %-8s  %-2s%s\\n\"\n    fmthd = \"%s%-5s %-{}s %-12s %-9s %-5s%s\\n\".format(cw - 36)\n    head = (c.ul, \"Item\", \"Playlist\", \"Author\", \"Updated\", \"Count\", c.w)\n    out = \"\\n\" + fmthd % head\n\n    for n, x in enumerate(g.ytpls):\n        col = (c.g if n % 2 == 0 else c.w)\n        length = x.get('size') or \"?\"\n        length = \"%4s\" % length\n        title = x.get('title') or \"unknown\"\n        author = x.get('author') or \"unknown\"\n        updated = yt_datetime(x.get('updated'))[1]\n        title = uea_pad(cw - 36, title)\n        out += (fmtrow % (col, str(n + 1), title, author[:12], updated, str(length), c.w))\n\n    return out + \"\\n\" * (5 - len(g.ytpls))\n</code></pre>"},{"location":"reference/content/#mps_youtube.content.generate_songlist_display","title":"<code>generate_songlist_display(song=False, zeromsg=None)</code>","text":"<p>Generate list of choices from a song list.</p> Source code in <code>mps_youtube\\content.py</code> <pre><code>def generate_songlist_display(song=False, zeromsg=None):\n    \"\"\" Generate list of choices from a song list.\"\"\"\n    # pylint: disable=R0914\n    if g.browse_mode == \"ytpl\":\n        return generate_playlist_display()\n\n    max_results = getxy().max_results\n\n    if not g.model:\n        g.message = zeromsg or \"Enter /search-term to search or [h]elp\"\n        return logo(c.g) + \"\\n\\n\"\n    g.rprompt = page_msg(g.current_page)\n\n    have_meta = all(x.ytid in g.meta for x in g.model)\n\n    user_columns = _get_user_columns() if have_meta else []\n    maxlength = max(x.length for x in g.model)\n    lengthsize = 8 if maxlength &gt; 35999 else 7\n    lengthsize = 6 if maxlength &lt; 6000 else lengthsize\n    reserved = 9 + lengthsize + len(user_columns)\n    cw = getxy().width\n    cw -= 1\n    title_size = cw - sum(1 + x['size'] for x in user_columns) - reserved\n    before = [{\"name\": \"idx\", \"size\": 3, \"heading\": \"Num\"},\n              {\"name\": \"title\", \"size\": title_size, \"heading\": \"Title\"}]\n    after = [{\"name\": \"length\", \"size\": lengthsize, \"heading\": \"Length\"}]\n    columns = before + user_columns + after\n\n    for n, column in enumerate(columns):\n        column['idx'] = n\n        column['sign'] = \"-\" if not column['name'] == \"length\" else \"\"\n\n    fmt = [\"%{}{}s  \".format(x['sign'], x['size']) for x in columns]\n    fmtrow = fmt[0:1] + [\"%s  \"] + fmt[2:]\n    fmt, fmtrow = \"\".join(fmt).strip(), \"\".join(fmtrow).strip()\n    titles = tuple([x['heading'][:x['size']] for x in columns])\n    hrow = c.ul + fmt % titles + c.w\n    out = \"\\n\" + hrow + \"\\n\"\n\n    for n, x in enumerate(g.model[:max_results]):\n        col = (c.r if n % 2 == 0 else c.p) if not song else c.b\n        details = {'title': x.title, \"length\": fmt_time(x.length)}\n        details = copy.copy(g.meta[x.ytid]) if have_meta else details\n        otitle = details['title']\n        details['idx'] = \"%2d\" % (n + 1)\n        details['title'] = uea_pad(columns[1]['size'], otitle)\n        #cat = details.get('category') or '-'\n        #details['category'] = 'pafy.get_categoryname(cat)'\n        details['ytid'] = x.ytid\n        line = ''\n\n        for z in columns:\n            fieldsize, field, direction = z['size'], z['name'], \"&lt;\" if z['sign'] == \"-\" else \"&gt;\"\n            line += uea_pad(fieldsize, details[field], direction)\n            if not columns[-1] == z:\n                line += \"  \"\n\n        col = col if not song or song != g.model[n] else c.p\n        line = col + line + c.w\n        out += line + \"\\n\"\n\n    return out + \"\\n\" * (5 - len(g.model)) if not song else out\n</code></pre>"},{"location":"reference/content/#mps_youtube.content.logo","title":"<code>logo(col=None, version='')</code>","text":"<p>Return text logo. </p> Source code in <code>mps_youtube\\content.py</code> <pre><code>def logo(col=None, version=\"\"):\n    \"\"\" Return text logo. \"\"\"\n    col = col if col else random.choice((c.g, c.r, c.y, c.b, c.p, c.w))\n    logo_txt = r\"\"\"                      _         _          \n                     | |       | |         \n  _   _  _____      _| |_ _   _| |__   ___ \n | | | |/ _ \\ \\ /\\ / / __| | | | '_ \\ / _ \\\n | |_| |  __/\\ V  V /| |_| |_| | |_) |  __/\n  \\__, |\\___| \\_/\\_/  \\__|\\__,_|_.__/ \\___|\n   __/ |                                   \n  |___/                                    \n    \"\"\"\n\n    version = \" v\" + version if version else \"\"\n    logo_txt = col + logo_txt + c.w + version\n    lines = logo_txt.split(\"\\n\")\n    length = max(len(x) for x in lines)\n    x, y, _ = getxy()\n    indent = (x - length - 1) // 2\n    newlines = (y - 12) // 2\n    indent, newlines = (0 if x &lt; 0 else x for x in (indent, newlines))\n    lines = [\" \" * indent + l for l in lines]\n    logo_txt = \"\\n\".join(lines) + \"\\n\" * newlines\n    return \"\" if g.debug_mode or g.no_textart else logo_txt\n</code></pre>"},{"location":"reference/content/#mps_youtube.content.page_msg","title":"<code>page_msg(page=0)</code>","text":"<p>Format information about currently displayed page to a string. </p> Source code in <code>mps_youtube\\content.py</code> <pre><code>def page_msg(page=0):\n    \"\"\" Format information about currently displayed page to a string. \"\"\"\n    if isinstance(g.content, PaginatedContent):\n        page_count = g.content.numPages()\n    else:\n        page_count = math.ceil(g.result_count/getxy().max_results)\n\n    if page_count &gt; 1:\n        pagemsg = \"{}{}/{}{}\"\n        #start_index = max_results * g.current_page\n        return pagemsg.format('&lt;' if page &gt; 0 else '[',\n                              \"%s%s%s\" % (c.y, page+1, c.w),\n                              page_count,\n                              '&gt;' if page + 1 &lt; page_count else ']')\n    return None\n</code></pre>"},{"location":"reference/content/#mps_youtube.content.playlists_display","title":"<code>playlists_display()</code>","text":"<p>Produce a list of all playlists. </p> Source code in <code>mps_youtube\\content.py</code> <pre><code>def playlists_display():\n    \"\"\" Produce a list of all playlists. \"\"\"\n    if not g.userpl:\n        g.message = F(\"no playlists\")\n        return generate_songlist_display() if g.model else (logo(c.y) + \"\\n\\n\")\n\n    maxname = max(len(a) for a in g.userpl)\n    out = \"      {0}Local Playlists{1}\\n\".format(c.ul, c.w)\n    start = \"      \"\n    fmt = \"%s%s%-3s %-\" + str(maxname + 3) + \"s%s %s%-7s%s %-5s%s\"\n    head = (start, c.b, \"ID\", \"Name\", c.b, c.b, \"Count\", c.b, \"Duration\", c.w)\n    out += \"\\n\" + fmt % head + \"\\n\\n\"\n\n    for v, z in enumerate(sorted(g.userpl)):\n        n, p = z, g.userpl[z]\n        l = fmt % (start, c.g, v + 1, n, c.w, c.y, str(len(p)), c.y,\n                   p.duration, c.w) + \"\\n\"\n        out += l\n\n    return out\n</code></pre>"},{"location":"reference/contentquery/","title":"contentquery.py","text":"<p>ContentQuery is an abstraction layer between the the pafy.call_gdata and the listViews.</p> <p>It lets you treat A query as a list of all the results, even though data is only queried when requested.</p>"},{"location":"reference/contentquery/#mps_youtube.contentquery.ContentQuery","title":"<code> ContentQuery        </code>","text":"<p>A wrapper for pafy.call_gdata. I lets you treat a search as a list, but the results will only be fetched when needed.</p> Source code in <code>mps_youtube\\contentquery.py</code> <pre><code>class ContentQuery:\n    \"\"\" A wrapper for pafy.call_gdata. I lets you treat a search as a list,\n        but the results will only be fetched when needed.\n    \"\"\"\n    maxresults = 0\n    pdata = []\n    nextpagetoken = None\n\n    datatype = None\n    query = None\n    api = None\n\n    def __init__(self, datatype, api, query):\n        # Perform initial API call, setBoundaries\n        # call parseData\n\n        self.datatype = datatype\n        self.query = query\n        self.api = api\n\n        self.pdata = []\n\n        self._perform_api_call()\n\n    def __getitem__(self, iid):\n        # Check if we already got the item or slice needed\n        # Call and parse nextPage as long as you dont have the data\n        # needed.\n        last_id = iid.stop if iid.__class__ == slice else iid\n        last_datapoint = min(last_id, self.maxresults)\n        while len(self.pdata) &lt; last_datapoint:\n            self._perform_api_call()\n        return self.pdata[iid]\n\n    def count(self):\n        \"\"\" Returns how many items are in the list \"\"\"\n        return self.maxresults\n\n    def __len__(self):\n        return abs(self.count())\n\n    def _perform_api_call(self):\n        # Include nextPageToken if it is set\n        # qry = dict(\n        #     pageToken=self.nextpagetoken,\n        #     **(self.query)\n        #     ) if self.nextpagetoken else self.query\n\n        # Run query\n        util.dbg(\"CQ.query\", self.query)\n        data = pafy.channel_search(self.query)#pafy.call_gdata(self.api, qry)\n\n        self.maxresults = len(data)#int(data.get(\"pageInfo\").get(\"totalResults\"))\n        self.nextpagetoken = None#data.get(\"nextPageToken\")\n\n        for obj in data:\n            self.pdata.append(self.datatype(obj))\n</code></pre>"},{"location":"reference/contentquery/#mps_youtube.contentquery.ContentQuery.count","title":"<code>count(self)</code>","text":"<p>Returns how many items are in the list </p> Source code in <code>mps_youtube\\contentquery.py</code> <pre><code>def count(self):\n    \"\"\" Returns how many items are in the list \"\"\"\n    return self.maxresults\n</code></pre>"},{"location":"reference/description_parser/","title":"description_parser.py","text":"<p>Module for trying to parse and retrieve song data from descriptions</p>"},{"location":"reference/description_parser/#mps_youtube.description_parser.artist_from_title","title":"<code>artist_from_title(title)</code>","text":"<p>Try to determine an artist by doing a search on the video and try to find the most common element by n number of times looking for the most common substring in a subset of the results from youtube</p> Source code in <code>mps_youtube\\description_parser.py</code> <pre><code>def artist_from_title(title):\n    \"\"\" Try to determine an artist by doing a search on the video\n        and try to find the most common element by n number of times looking\n        for the most common substring in a subset of the results from youtube\n    \"\"\"\n    query = {}\n    query['q'] = title\n    query['type'] = 'video'\n    query['fields'] = \"items(snippet(title))\"\n    query['maxResults'] = 50\n    query['part'] = \"snippet\"\n\n    results = None#pafy.call_gdata('search', query)['items']\n    titles = [x['snippet']['title'].upper() for x in results]\n\n    alts = {}\n    for _ in range(100):\n        random.shuffle(titles)\n        subset = titles[:10]\n        string = long_substr(subset).strip()\n        if len(string) &gt; 3:\n            alts[string] = alts.get(string, 0) + 1\n\n    best_string = None\n    if len(alts) == 1:\n        best_string = list(alts.keys())[0].capitalize()\n    else:\n        best_guess = 99999\n        best_string = None\n\n        for key in list(alts.keys()):\n            current_guess = title.upper().find(key)\n            if current_guess &lt; best_guess:\n                best_guess = current_guess\n                best_string = key.capitalize()\n\n    best_string = re.sub(r\"([^\\w]+)$\", \"\", best_string)\n    best_string = re.sub(r\"^([^\\w]+)\", \"\", best_string)\n    return best_string\n</code></pre>"},{"location":"reference/description_parser/#mps_youtube.description_parser.calculate_certainty","title":"<code>calculate_certainty(line)</code>","text":"<p>Determine if a line contains a  </p> Source code in <code>mps_youtube\\description_parser.py</code> <pre><code>def calculate_certainty(line):\n    \"\"\" Determine if a line contains a  \"\"\"\n    certainty_indexes = [\n        {'regex': r\"(?:\\(?(?:\\d{0,4}:)?\\d{0,2}:\\d{0,2}\\)?(?: - )?){1,2}\",\n         'weight': 1},\n        {'regex': r\"(([\\w&amp;()\\[\\]'\\.\\/ ]+)([ ]?[-]+[ ]?)([\\w&amp;()\\[\\]'\\.\\/ ]+))+\",\n         'weight': 0.75},\n        {'regex': r\"^([\\d]+[. ]+)\",\n         'weight': 1}\n    ]\n\n    certainty = 0.0\n    for method in certainty_indexes:\n        if re.match(method['regex'], line):\n            certainty += method['weight']\n\n    return certainty / len(certainty_indexes)\n</code></pre>"},{"location":"reference/description_parser/#mps_youtube.description_parser.has_artist","title":"<code>has_artist(text)</code>","text":"<p>Determine if the str\u00ecng has artist or not </p> Source code in <code>mps_youtube\\description_parser.py</code> <pre><code>def has_artist(text):\n    \"\"\" Determine if the str\u00ecng has artist or not \"\"\"\n    regex = r\"(?:([\\w&amp;()\\[\\]'\\.\\/ ]+)(?:[ ]?[-]+[ ]?)([\\w&amp;()\\[\\]'\\.\\/ ]+))+\"\n    return not re.match(regex, text)\n</code></pre>"},{"location":"reference/description_parser/#mps_youtube.description_parser.is_substr","title":"<code>is_substr(find, data)</code>","text":"<p>Check if is substring </p> Source code in <code>mps_youtube\\description_parser.py</code> <pre><code>def is_substr(find, data):\n    \"\"\" Check if is substring \"\"\"\n    if len(data) &lt; 1 and len(find) &lt; 1:\n        return False\n    for i, _ in enumerate(data):\n        if find not in data[i]:\n            return False\n    return True\n</code></pre>"},{"location":"reference/description_parser/#mps_youtube.description_parser.long_substr","title":"<code>long_substr(data)</code>","text":"<p>https://stackoverflow.com/a/2894073 </p> Source code in <code>mps_youtube\\description_parser.py</code> <pre><code>def long_substr(data):\n    \"\"\" https://stackoverflow.com/a/2894073 \"\"\"\n    substr = ''\n    if len(data) &gt; 1 and len(data[0]) &gt; 0:\n        for i in range(len(data[0])):\n            for j in range(len(data[0])-i+1):\n                if j &gt; len(substr) and is_substr(data[0][i:i+j], data):\n                    substr = data[0][i:i+j]\n    return substr\n</code></pre>"},{"location":"reference/description_parser/#mps_youtube.description_parser.parse","title":"<code>parse(text, title='Unknown')</code>","text":"<p>Main function</p> Source code in <code>mps_youtube\\description_parser.py</code> <pre><code>def parse(text, title=\"Unknown\"):\n    \"\"\" Main function\"\"\"\n\n    # Determine a certainty index for each line\n    lines = []\n    for line in text.split('\\n'):\n        lines.append((calculate_certainty(line), line))\n\n    # Get average from all strings\n    certainty_average = sum([x[0] for x in lines]) / len(lines)\n\n    # Single out lines with above average certainty index\n    lines = filter(lambda a: a is not None,\n                   [x if x[0] &gt; certainty_average else None for x in lines])\n\n    # Determine if they are artist combo strings or only title\n    cmbs = []\n    for line in lines:\n        is_ac = has_artist(line[1])\n        cmbs.append(strip_string(line[1], is_ac))\n\n    # No or very few tracklists will ommit aritsts or add artist information\n    # on only a few select number of tracks, therefore we count entries with\n    # and without artist, and remove the anomalities IF the number of\n    # anomalities are small enough\n\n    counters = {'has': 0, 'not': 0}\n    for combo in cmbs:\n        counters['has' if combo[0] else 'not'] += 1\n\n    dominant = 'has' if counters['has'] &gt; counters['not'] else 'not'\n\n    diff = abs(counters['has'] - counters['not'])\n    if diff &gt; sum([counters['has'], counters['not']]):\n        print(\"Too many anomalities detected\")\n        return []\n\n    if dominant == 'has':\n        cmbs = filter(lambda a: a is not None,\n                      [x if x[0] is not None else None for x in cmbs])\n    else:\n        arti = artist_from_title(title)\n        cmbs = filter(lambda a: a is not None,\n                      [(arti, x[1]) if x[0] is None else None for x in cmbs])\n    return list(cmbs)\n</code></pre>"},{"location":"reference/description_parser/#mps_youtube.description_parser.strip_string","title":"<code>strip_string(text, single=False)</code>","text":"<p>Strip an artist-combo string </p> Source code in <code>mps_youtube\\description_parser.py</code> <pre><code>def strip_string(text, single=False):\n    \"\"\" Strip an artist-combo string \"\"\"\n    # Removes timestamps\n    ts_reg = r\"(?:\\(?(?:\\d{0,4}:)?\\d{1,2}:\\d{1,2}\\)?(?: - )?){1,2}\"\n    text = re.sub(ts_reg, \"\", text)\n\n    # Removes Tracknumbers.\n    text = re.sub(r\"^([\\d]+[. ]+)\", \"\", text)\n\n    # Removes starting with non words\n    text = re.sub(r\"^[^\\w&amp;()\\[\\]'\\.\\/]\", \"\", text, flags=re.MULTILINE)\n\n    artist, track = None, None\n    if not single:\n        rgex = r\"(?:([\\w&amp;()\\[\\]'\\.\\/ ]+)(?:[ ]?[-]+[ ]?)([\\w&amp;()\\[\\]'\\.\\/ ]+))+\"\n        artist, track = (re.findall(rgex, text)[0])\n    else:\n        track = text\n\n    return artist, track\n</code></pre>"},{"location":"reference/g/","title":"g.py","text":"<p>Module for holding globals that are needed throught mps-youtube. </p>"},{"location":"reference/helptext/","title":"helptext.py","text":"<p>Holds all help text</p>"},{"location":"reference/helptext/#mps_youtube.helptext.get_help","title":"<code>get_help(choice)</code>","text":"<p>Return help message. </p> Source code in <code>mps_youtube\\helptext.py</code> <pre><code>def get_help(choice):\n    \"\"\" Return help message. \"\"\"\n    helps = {\"download\": (\"playback dl listen watch show repeat playing\"\n                          \"show_video playurl browserplay dlurl d da dv all *\"\n                          \" play browsersearch\".split()),\n\n             \"dl-command\": (\"dlcmd dl-cmd download-cmd dl_cmd download_cmd \"\n                            \"download-command download_command\".split()),\n\n             \"encode\": (\"encoding transcoding transcode wma mp3 format \"\n                        \"encode encoder\".split()),\n\n             \"invoke\": \"command commands yt invocation\".split(),\n\n             \"search\": (\"user userpl pl pls r n p url album \"\n                        \"editing result results related remove swop mkp --description\".split()),\n\n             \"edit\": (\"editing manupulate manipulating rm mv sw edit move \"\n                      \"swap shuffle\".split()),\n\n             \"tips\": (\"undump dump -f -w -a adv advanced\".split(\" \")),\n\n             \"basic\": (\"basic comment basics c copy clipboard comments u \"\n                       \"i\".split()),\n\n             \"config\": (\"set checkupdate colours colors ddir directory player \"\n                        \"arguments args playerargs music search_music keys \"\n                        \"status show_status show_video video configuration \"\n                        \"fullscreen full screen folder player mpv mplayer\"\n                        \" settings default reset configure audio results \"\n                        \"max_results size lines rows height window \"\n                        \"position window_pos quality resolution max_res \"\n                        \"columns width console overwrite\".split()),\n\n             \"playlists\": (\"save rename delete move rm ls mv sw add vp open\"\n                           \" view\".split())}\n\n    for topic, aliases in helps.items():\n\n        if choice in aliases:\n            choice = topic\n            break\n\n    choice = \"menu\" if not choice else choice\n    out, all_help = \"\", helptext()\n    help_names = [x[0] for x in all_help]\n    choice = get_near_name(choice, help_names)\n\n    def indent(x):\n        \"\"\" Indent. \"\"\"\n        return \"\\n  \".join(x.split(\"\\n\"))\n\n    if choice == \"menu\" or choice not in help_names:\n        out += \"  %sHelp Topics%s\" % (c.ul, c.w)\n        out += F('help topic', 2, 1)\n\n        for x in all_help:\n            out += (\"\\n%s     %-10s%s : %s\" % (c.y, x[0], c.w, x[1]))\n\n        out += \"\\n\"\n        return out\n\n    else:\n        if choice == 'tor':\n            output_text = check_tor()\n        elif choice == 'new':\n            output_text = get_changelog()\n        elif choice == \"changelog\":\n            output_text = get_changelog_local()\n        else:\n            choice = help_names.index(choice)\n            output_text = all_help[choice][2]\n\n        return indent(output_text)\n</code></pre>"},{"location":"reference/helptext/#mps_youtube.helptext.helptext","title":"<code>helptext()</code>","text":"<p>Return a list of help categories, with their contents. </p> Source code in <code>mps_youtube\\helptext.py</code> <pre><code>def helptext():\n    \"\"\" Return a list of help categories, with their contents. \"\"\"\n\n    return [\n        (\"basic\", \"Basics\", \"\"\"\n\n    {0}Basic Usage{1}\n\n    Use {2}/{1} or {2}.{1} to prefix your search query.  e.g., {2}/pink floyd{1}\n\n    Then, when results are shown:\n\n        {2}&lt;number(s)&gt;{1} - play specified items, separated by commas.\n                      e.g., {2}1-3,5{1} plays items 1, 2, 3 and 5.\n\n        {2}i &lt;number&gt;{1} - view information on video &lt;number&gt;\n        {2}c &lt;number&gt;{1} - view comments for video &lt;number&gt;\n        {2}d &lt;number&gt;{1} - download video &lt;number&gt;\n        {2}r &lt;number&gt;{1} - show videos related to video &lt;number&gt;\n        {2}u &lt;number&gt;{1} - show videos uploaded by uploader of video &lt;number&gt;\n        {2}x &lt;number&gt;{1} - copy item &lt;number&gt; url to clipboard. (See the note below)\n        Note: This feature requires `pyperclip` which is installed automatically when you install yewtube but\n        Linux users further need to install `xsel` or `xclip` manually using apt, dnf, pacman, zypper or whatever package manager you use.\n        Visit https://pyperclip.readthedocs.io/en/latest/index.html#not-implemented-error for more info.\n\n        {2}q{1}, {2}quit{1} - exit yewtube\n    \"\"\".format(c.ul, c.w, c.y)),\n        (\"search\", \"Searching and Retrieving\", \"\"\"\n    {0}Searching and Retrieving{1}\n\n    {2}set search_music false{1} - search all YouTube categories.\n    {2}set search_music true{1}  - search only YouTube music category.\n\n    {2}/&lt;query&gt;{1} or {2}.&lt;query&gt;{1} to search for videos. e.g., {2}/daft punk{1}\n    Search Arguments:\n    {2}-d, --duration{1}    Can be any/short/medium/long\n    {2}-a, --after{1}       Date in {2}YYYY-MM-DD{1} or {2}YYYY-MM-DD{1}T{2}HH:MM{1} format\n    {2}-l, --live{1}        Limit search to livestreams\n    {2}-c, --category{1}    Search within a category, (number or string)\n                      Available categories:\n                      {2}{3}{1}\n\n    {2}//&lt;query&gt;{1} or {2}..&lt;query&gt;{1} - search for YouTube playlists. e.g., \\\n    {2}//80's music{1}\n    {2}n{1} and {2}p{1} - continue search to next/previous pages.\n    {2}p &lt;number&gt;{1} - switch to page &lt;number&gt;.\n\n    {2}album &lt;album title&gt;{1} - Search for matching tracks using album title\n    {2}channels &lt;Channel name&gt;{1} - Search for channels by channelname\n    {2}live &lt;category&gt;{1} - Search for livestreams from a range of categories.\n    Categories: {2}{3}{1}\n\n    {2}mkp &lt;fullfilepath&gt;{1} - Creates a playlist automatically with video titles from fullfilepath\n    &lt;fullfilepath&gt;: Full path of text file with one title per line\n\n    {2}mkp -d &lt;search result number&gt;{1} - Create a playlist based on tracks\n    listed in that videos description. (Alternatively one can use {2}--description{1})\n\n    {2}user &lt;username&gt;{1} - list YouTube uploads by &lt;username&gt;.\n    {2}user &lt;username&gt;/&lt;query&gt;{1} - as above, but matches &lt;query&gt;.\n    {2}userpl &lt;username&gt;{1} - list YouTube playlists created by &lt;username&gt;.\n    {2}pl &lt;url or id&gt;{1} - Open YouTube playlist by url or id.\n    {2}url &lt;url or id&gt;{1} - Retrieve specific YouTube video by url or id.\n    {2}url &lt;url&gt; &lt;url&gt; ... &lt;url&gt;{1} - Retrieve specific YouTube videos by url or id.\n    {2}url_file &lt;file_absolute_path&gt;{1} - Retrieve YouTube videos by url or id from a .txt file.\n    File format : .txt, with one url or id by line.\n\n    {2}r &lt;number&gt;{1} - show videos related to video &lt;number&gt;.\n    {2}u &lt;number&gt;{1} - show videos uploaded by uploader of video &lt;number&gt;.\n    {2}c &lt;number&gt;{1} - view comments for video &lt;number&gt;\n    \"\"\".format(c.ul, c.w, c.y, \", \".join(g.categories.keys()))),\n\n        (\"edit\", \"Editing / Manipulating Results\", \"\"\"\n    {0}Editing and Manipulating Results{1}\n\n    {2}rm &lt;number(s)&gt;{1} - remove items from displayed results.\n    {2}sw &lt;number&gt;,&lt;number&gt;{1} - swap two items.\n    {2}mv &lt;number&gt;,&lt;number&gt;{1} - move item &lt;number&gt; to position &lt;number&gt;.\n    {2}save &lt;name&gt;{1} - save displayed items as a local playlist.\n    {2}mix &lt;number&gt;{1} - show YouTube mix playlist from item in results.\n\n    {2}shuffle{1} - Shuffle the displayed results.\n    {2}shuffle all{1} - Shuffle entire loaded playlist.\n    {2}reverse{1} or {2}reverse &lt;number&gt;-&lt;number&gt;{1} - Reverse the displayed items or item range.\n    {2}reverse all{1} - Reverse order of entire loaded playlist.\n    \"\"\".format(c.ul, c.w, c.y)),\n\n        (\"download\", \"Downloading and Playback\", \"\"\"\n    {0}Downloading and Playback{1}\n\n    {2}set show_video true{1} - play video instead of audio.\n\n    {2}&lt;number(s)&gt;{1} - play specified items, separated by commas.\n                  e.g., {2}1-3,5{1} plays items 1, 2, 3 and 5\n\n    {2}d &lt;number&gt;{1} - view downloads available for an item.\n    {2}da &lt;number(s)&gt;{1} - download best available audio file(s).\n    {2}dv &lt;number(s)&gt;{1} - download best available video file(s).\n    {2}dapl &lt;url or id&gt;{1} - download YouTube playlist (audio) by url or id.\n    {2}dvpl &lt;url or id&gt;{1} - download YouTube playlist (video) by url or id.\n    {2}daupl &lt;username&gt;{1} - download user's YouTube playlists (audio).\n    {2}dvupl &lt;username&gt;{1} - download user's YouTube playlists (video).\n    {2}dlurl &lt;url or id&gt;{1} - download a YouTube video by url or video id.\n    {2}daurl &lt;url or id&gt;{1} - download best available audio of YouTube video by url or video id.\n    {2}playurl &lt;url or id&gt;{1} - play a YouTube video by url or id.\n    {2}browserplay &lt;number&gt;{1} - open a specified previous search in browser.\n\n    {2}all{1} or {2}*{1} - play all displayed items.\n    {2}repeat &lt;number(s)&gt;{1} - play and repeat the specified items.\n    {2}shuffle &lt;number(s)&gt;{1} - play specified items in random order.\n    \"\"\".format(c.ul, c.w, c.y)),\n\n        (\"dl-command\", \"Downloading Using External Application\", \"\"\"\n    {0}Download Using A Custom Application{1}\n\n    Use {2}set download_command &lt;command&gt;{1} to specify a custom command to use for\n    downloading.\n\n    mps-youtube will make the following substitutions:\n\n    %u - url of the remote file to download\n    %d - download directory as set in DDIR in mps-youtube config\n    %f - filename (determined by title and filetype)\n    %F - full file path (%d/%f)\n    %i - youtube video id\n\n    for example, to download using aria2c (http://aria2.sourceforge.net), enter:\n\n        {2}set download_command aria2c --dir=%d --out=%f %u{1}\n\n    Note that using a custom download command does not support transcoding the\n    downloaded file to another format using mps-youtube.\n    \"\"\".format(c.ul, c.w, c.y)),\n\n\n        (\"encode\", \"Encoding to MP3 and other formats\", \"\"\"\n    {0}Encoding to MP3 and other formats{1}\n\n    Enter {2}encoders{1} to view available encoding presets\n    Enter {2}set encoder &lt;number&gt;{1} to apply an encoding preset for downloads\n\n    This feature requires that ffmpeg or avconv is installed on your system and is\n    available in the system path.\n\n    The encoding presets can be modified by editing the text config file which\n    resides at:\n       {3}\n    \"\"\".format(c.ul, c.w, c.y, g.TCFILE)),\n\n        (\"playlists\", \"Using Local Playlists\", \"\"\"\n    {0}Using Local Playlists{1}\n\n    {2}add &lt;number(s)&gt;{1} - add items to the current playlist.\n    {2}add &lt;number(s)&gt; &lt;playlist&gt;{1} - add items to the specified playlist.\n         (&lt;playlist&gt; will be created if it doesn't already exist)\n\n    {2}vp{1} - view current playlist.\n    {2}ls{1} - list saved playlists.\n    {2}mv &lt;old name or ID&gt; &lt;new name&gt;{1} - rename a playlist.\n    {2}rmp &lt;playlist_name or ID&gt;{1} - delete a playlist from disk.\n\n    {2}open &lt;name or ID&gt;{1} - open a saved playlist as the current playlist.\n    {2}play &lt;name or ID&gt;{1} - play a saved playlist directly.\n    {2}view &lt;name or ID&gt;{1} - view a playlist (current playlist left intact).\n    {2}save{1} or {2}save &lt;name&gt;{1} - save the displayed items as a playlist.\n\n    {2}rm &lt;number(s)&gt;{1} - remove items from displayed results.\n    {2}sw &lt;number&gt;,&lt;number&gt;{1} - swap two items.\n    {2}mv &lt;number&gt;,&lt;number&gt;{1} - move item &lt;number&gt; to position &lt;number&gt;.\n    \"\"\".format(c.ul, c.w, c.y)),\n\n        (\"history\", \"Accessing Local History\", \"\"\"\n    {0}Accessing Local History{1}\n\n    Access songs that have been played within yewtube\n\n        {2}history{1} - displays a list of songs contained in history\n        {2}history clear{1} - clears the song history\n        {2}history recent{1} - displays a list of recent played songs\n        {2}set history on|off{1} - toggles history recording\n    \"\"\".format(c.ul, c.w, c.y)),\n\n        (\"invoke\", \"Invocation Parameters\", \"\"\"\n    {0}Invocation{1}\n\n    All yewtube commands can be entered from the command line.  For example;\n\n      {2}yt dlurl &lt;url or id&gt;{1} to download a YouTube video by url or id\n      {2}yt playurl &lt;url or id&gt;{1} to play a YouTube video by url or id\n      {2}yt /mozart{1} to search\n      {2}yt //best songs of 2010{1} for a playlist search\n      {2}yt play &lt;playlist name or ID&gt;{1} to play a saved playlist\n      {2}yt ls{1} to list saved playlists\n\n    For further automation, a series of commands can be entered separated by\n    commas (,).  E.g.,\n\n      {2}yt open 1, 2-4{1} - play items 2-4 of first saved playlist\n      {2}yt //the doors, 1, all -a{1} - open YouTube playlist and play audio\n\n    If you need to enter an actual comma on the command line, use {2},,{1} instead.\n    \"\"\".format(c.ul, c.w, c.y)),\n\n        (\"config\", \"Configuration Options\", \"\"\"\n    {0}Configuration{1}\n\n    {2}set{1} - view current configuration\n    {2}set &lt;item&gt; default{1} - set an item to its default value\n    {2}set all default{1} - restore default settings\n    {2}set checkupdate true|false{1} - check for updates on exit\n    {2}set columns &lt;columns&gt;{1} - select extra displayed fields in search results:\n         (valid: views comments rating date time user likes dislikes category ytid)\n    {2}set ddir &lt;download direcory&gt;{1} - set where downloads are saved\n    {2}set download_command &lt;command&gt;{1} - type {2}help dl-command{1} for info\n    {2}set encoder &lt;number&gt;{1} - set encoding preset for downloaded files\n    {2}set fullscreen true|false{1} - output video content in full-screen mode\n    {2}set always_repeat true|false{1} - always in repeat mode without repeat &lt;number&gt;\n    {2}set max_res &lt;number&gt;{1} - play / download maximum video resolution height{3}\n    {2}set notifier &lt;notifier app&gt;{1} - call &lt;notifier app&gt; with each new song title\n    {2}set order &lt;relevance|date|views|rating&gt;{1} search result ordering\n    {2}set user_order &lt;&lt;nothing&gt;|relevance|date|views|rating&gt;{1} user upload list\n        result ordering, leave blank for the same as order setting\n    {2}set overwrite true|false{1} - overwrite existing files (skip if false)\n    {2}set player &lt;player app&gt;{1} - use &lt;player app&gt; for playback\n    {2}set playerargs &lt;args&gt;{1} - use specified arguments with player\n    {2}set lookup_metadata true|false{1} - lookup metadata using Last.fm\n    {2}set lastfm_username &lt;username&gt;{1} - scrobble to this Last.fm userprofile\n    {2}set lastfm_password &lt;password&gt;{1} - Last.fm password (saved in hash form)\n    {2}set lastfm_api &lt;key&gt;{1} - API key needed for Last.fm mps-yt authorization\n    {2}set lastfm_secret &lt;key&gt;{1} - secret for the Last.fm API key\n    {2}set search_music true|false{1} - search only music (all categories if false)\n    {2}set show_mplayer_keys true|false{1} - show keyboard help for mplayer and mpv\n    {2}set show_status true|false{1} - show status messages and progress\n    {2}set show_video true|false{1} - show video output (audio only if false)\n    {2}set window_pos &lt;top|bottom&gt;-&lt;left|right&gt;{1} - set player window position\n    {2}set window_size &lt;number&gt;x&lt;number&gt;{1} - set player window width &amp; height\n    {2}set audio_format &lt;auto|m4a|webm&gt;{1} - set default music audio format\n    {2}set video_format &lt;auto|mp4|webm|3gp&gt;{1} - set default music video format\n    {2}set set_title true|false{1} - change window title\n    {2}set show_qrcode true|false{1} - show qrcode of the URL in the video information panel\n    {2}set history true|false{1} - record play history\n    {2}set input_history true|false{1} - record command input history\n    {2}set vlc_dummy_interface true|false{1} - whether to hide VLC GUI or not (hides when true)\n\n    Additionally, {2}set -t{1} may be used to temporarily change a setting without\n    saving it to disk\n    \"\"\".format(c.ul, c.w, c.y, '\\n{0}set max_results &lt;number&gt;{1} - show &lt;number&gt; re'\n               'sults when searching (max 50)'.format(c.y, c.w) if not\n               g.detectable_size else '')),\n\n        (\"lastfm\", \"Last.fm configuration\", \"\"\"\n    {0}Configure Last.fm{1}\n\n    pylast needs to be installed for Last.fm support. See https://github.com/pylast/pylast.\n\n    Use {2}set{1} to set your Last.fm login credenditals, e.g. {2}set lastfm_username jane_doe{1}.\n    Similarly, you also have to provide an API key and it's corresponding secret.\n    An API key can be retrieved from https://www.last.fm/api/account/create.\n\n    Your Last.fm configuration is saved and automatically reloaded when mps-youtube starts.\n\n    After having set the required information, a connection can also be established\n    with {2}lastfm_connect{1}. Additionally, {2}lastfm_connect{1} provides verbose error messages.\n\n    For now, Last.fm support only works with the {2}album{1} command.\n    \"\"\".format(c.ul, c.w, c.y)),\n\n        (\"tips\", \"Advanced Tips\", \"\"\"\n    {0}Advanced Tips{1}\n\n    Use {2}-w{1}, {2}-f{1} or {2}-a{1} with your choice to override the configured\\\n     setting and\n    play items in windowed, fullscreen or audio modes.  E.g., 1-4 -a\n\n    When specifying columns with {2}set columns{1} command, append :N to set\\\n     width.\n        E.g.: {2}set columns date views user:17 likes{1}\n\n    When using {2}open{1}, {2}view{1} or {2}play{1} to access a local playlist, \\\n    you can enter\n    the first few characters instead of the whole name.\n\n    Use {2}5-{1} to select items 5 upward and {2}-5{1} to select up to item 5. \\\n    This can be\n    included with other choices. e.g., 5,3,7-,-2\n    You can use spaces instead of commas: 5 3 7- -2\n    Reversed ranges also work. eg., 5-2\n\n    {2}dump{1} - to show entire contents of an opened YouTube playlist.\n           (useful for playing or saving entire playlists, use {2}undump{1} to \\\n    undo)\n\n    {2}set player mpv{1} or {2}set player mplayer{1} - change player application\n\n    Use {2}1{1} and {2}0{1} in place of true and false when using the {2}set{1} \\\n    command\n\n    Use {2}clearcache{1} command to clear the cache.\n    \"\"\".format(\n                c.ul, c.w, c.y\n            ),\n        ),\n        (\n            \"new\",\n            \"Show online changelog for the latest version\",\n            \"\"\"{0}What's New{1}\\n{3}\"\"\".format(c.ul, c.w, c.y, \"get_changelog()\"),\n        ),\n        (\n            \"changelog\",\n            \"Check program changelog\",\n            \"\"\"{0}Changelog{1}\\n{3}\"\"\".format(c.ul, c.w, c.y, \"get_changelog_local()\"),\n        ),\n        (\n            \"tor\",\n            \"Check Tor Status. NOTE: Use this feature at your own risk. In case of any kind of damage we will not be responsible.\",\n            \"\"\"{0}Tor Status{1}\\n{3}\"\"\".format(c.ul, c.w, c.y, \"check_tor()\"),\n        ),\n    ]\n</code></pre>"},{"location":"reference/history/","title":"history.py","text":""},{"location":"reference/history/#mps_youtube.history.add","title":"<code>add(song)</code>","text":"<p>Add song to history. </p> Source code in <code>mps_youtube\\history.py</code> <pre><code>def add(song):\n    \"\"\" Add song to history. \"\"\"\n    if not g.userhist.get('history'):\n        g.userhist['history'] = Playlist('history')\n\n    g.userhist['history'].songs.append(song)\n\n    save()\n</code></pre>"},{"location":"reference/history/#mps_youtube.history.load","title":"<code>load()</code>","text":"<p>Open history. Called once on script invocation. </p> Source code in <code>mps_youtube\\history.py</code> <pre><code>def load():\n    \"\"\" Open history. Called once on script invocation. \"\"\"\n    _convert_to_m3u()\n    try:\n        g.userhist['history'] = read_m3u(g.HISTFILE)\n\n    except FileNotFoundError:\n        # no playlist found, create a blank one\n        if not os.path.isfile(g.HISTFILE):\n            g.userhist = {}\n            save()\n</code></pre>"},{"location":"reference/history/#mps_youtube.history.save","title":"<code>save()</code>","text":"<p>Save history.  Called each time history is updated. </p> Source code in <code>mps_youtube\\history.py</code> <pre><code>def save():\n    \"\"\" Save history.  Called each time history is updated. \"\"\"\n    with open(g.HISTFILE, 'w') as hf:\n        hf.write('#EXTM3U\\n\\n')\n        if 'history' in g.userhist:\n            for song in g.userhist['history'].songs:\n                hf.write('#EXTINF:%d,%s\\n' % (song.length, song.title))\n                hf.write('https://www.youtube.com/watch?v=%s\\n' % song.ytid)\n\n    dbg(c.r + \"History saved\\n---\" + c.w)\n</code></pre>"},{"location":"reference/init/","title":"init.py","text":""},{"location":"reference/init/#mps_youtube.init.init","title":"<code>init()</code>","text":"<p>Initial setup. </p> Source code in <code>mps_youtube\\init.py</code> <pre><code>def init():\n    \"\"\" Initial setup. \"\"\"\n\n    _process_cl_args()\n\n    # set player to mpv or mplayer if found, otherwise unset\n    suffix = \".exe\" if mswin else \"\"\n    vlc, mplayer, mpv = \"vlc\" + suffix, \"mplayer\" + suffix, \"mpv\" + suffix\n\n    # check for old pickled binary config and convert to json if so\n    config.convert_old_cf_to_json()\n\n    if not os.path.exists(g.CFFILE):\n\n        if has_exefile(vlc):\n            config.PLAYER.set(vlc)\n\n        elif has_exefile(mpv):\n            config.PLAYER.set(mpv)\n\n        elif has_exefile(mplayer):\n            config.PLAYER.set(mplayer)\n\n        config.save()\n\n    else:\n        config.load()\n        try:\n            assign_player(config.PLAYER.get)  # Player is not assigned when config is loaded\n        except Exception as ex:\n            g.message = \"%sFailed to get %s`s version. Probabily it is not installed. Try installing it again or change player using `set player &lt;player_name&gt;` %s\" %(c.y, config.PLAYER.get , c.w)\n            screen.update()\n            input(\"Press Enter to go back to main menu.\")\n\n    # Make pafy use the same api key\n    # pafy.set_api_key(config.API_KEY.get)\n\n    _init_readline()\n    cache.load()\n    _init_transcode()\n\n    # ensure encoder is not set beyond range of available presets\n    if config.ENCODER.get &gt;= len(g.encoders):\n        config.ENCODER.set(\"0\")\n\n    # check mpv/mplayer version\n    if has_exefile(config.PLAYER.get):\n        load_player_info(config.PLAYER.get)\n\n    # setup colorama\n    if has_colorama and mswin:\n        # Colorama converts ansi escape codes to Windows system calls\n        colorama.init()\n\n    # find muxer app\n    if mswin:\n        g.muxapp = has_exefile(\"ffmpeg.exe\") or has_exefile(\"avconv.exe\")\n\n    else:\n        g.muxapp = has_exefile(\"ffmpeg\") or has_exefile(\"avconv\")\n\n    # initialize MPRIS2 interface\n    if config.MPRIS.get:\n        try:\n            from . import mpris\n            conn1, conn2 = multiprocessing.Pipe()\n            g.mprisctl = mpris.MprisConnection(conn1)\n            t = multiprocessing.Process(target=mpris.main, args=(conn2,))\n            t.daemon = True\n            t.start()\n        except ImportError:\n            print(\"could not load MPRIS interface. missing libraries.\")\n</code></pre>"},{"location":"reference/main/","title":"main.py","text":"<p>mps-youtube.</p> <p>https://github.com/np1/mps-youtube</p> <p>Copyright (C) 2014, 2015 np1 and contributors</p> <p>This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</p> <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.</p> <p>You should have received a copy of the GNU General Public License along with this program.  If not, see http://www.gnu.org/licenses/.</p>"},{"location":"reference/main/#mps_youtube.main.matchfunction","title":"<code>matchfunction(func, regex, userinput)</code>","text":"<p>Match userinput against regex.</p> <p>Call func, return True if matches.</p> Source code in <code>mps_youtube\\main.py</code> <pre><code>def matchfunction(func, regex, userinput):\n    \"\"\" Match userinput against regex.\n\n    Call func, return True if matches.\n\n    \"\"\"\n    # Not supported in python 3.3 or lower\n    # match = regex.fullmatch(userinput)\n    # if match:\n    match = regex.match(userinput)\n    if match and match.group(0) == userinput:\n        matches = match.groups()\n        util.dbg(\"input: %s\", userinput)\n        util.dbg(\"function call: %s\", func.__name__)\n        util.dbg(\"regx matches: %s\", matches)\n\n        try:\n            func(*matches)\n\n        except IndexError:\n            if g.debug_mode:\n                g.content = ''.join(traceback_py.format_exception(\n                    *sys.exc_info()))\n            g.message = util.F('invalid range')\n            g.content = g.content or content.generate_songlist_display()\n\n        except (ValueError, IOError) as e:\n            if g.debug_mode:\n                g.content = ''.join(traceback_py.format_exception(\n                    *sys.exc_info()))\n            g.message = util.F('cant get track') % str(e)\n            g.content = g.content or\\\n                content.generate_songlist_display(zeromsg=g.message)\n\n        except Exception as e:#pafy.GdataError as e:\n            import traceback\n            traceback.print_exception(type(e), e, e.__traceback__)\n            if g.debug_mode:\n                g.content = ''.join(traceback.format_exception(\n                    *sys.exc_info()))\n            g.message = util.F('no data') % e\n            g.content = g.content\n\n        return True\n</code></pre>"},{"location":"reference/main/#mps_youtube.main.prompt_for_exit","title":"<code>prompt_for_exit()</code>","text":"<p>Ask for exit confirmation. </p> Source code in <code>mps_youtube\\main.py</code> <pre><code>def prompt_for_exit():\n    \"\"\" Ask for exit confirmation. \"\"\"\n    g.message = c.r + \"Press ctrl-c again to exit\" + c.w\n    g.content = content.generate_songlist_display()\n    screen.update()\n\n    try:\n        userinput = input(c.r + \" &gt; \" + c.w)\n\n    except (KeyboardInterrupt, EOFError):\n        commands.misc.quits(showlogo=False)\n\n    return userinput\n</code></pre>"},{"location":"reference/pafy/","title":"pafy.py","text":""},{"location":"reference/pafy/#mps_youtube.pafy.all_playlists_from_channel","title":"<code>all_playlists_from_channel(channel_id)</code>","text":"<p>Get all playlists from a channel</p> Source code in <code>mps_youtube\\pafy.py</code> <pre><code>def all_playlists_from_channel(channel_id):\n    '''\n    Get all playlists from a channel\n    '''\n    async def _async_get():\n        channel = Channel(channel_id)\n        await channel.init()\n        playlists = channel.result.get('playlists', [])\n        while channel.has_more_playlists():\n            await channel.next()\n            playlists.extend(channel.result.get('playlists', []))\n        return playlists\n\n    return asyncio.run(_async_get())\n</code></pre>"},{"location":"reference/pafy/#mps_youtube.pafy.all_videos_from_channel","title":"<code>all_videos_from_channel(channel_id)</code>","text":"<p>Get all videos from a channel identified by channel_id</p> Source code in <code>mps_youtube\\pafy.py</code> <pre><code>def all_videos_from_channel(channel_id):\n    '''\n    Get all videos from a channel identified by channel_id\n    '''\n    async def _async_get():\n        channel = Channel(channel_id)\n        await channel.init()\n        videos = channel.result.get('videos', [])\n        while channel.has_more_videos():\n            await channel.next()\n            videos.extend(channel.result.get('videos', []))\n        return videos\n\n    return asyncio.run(_async_get())\n</code></pre>"},{"location":"reference/pafy/#mps_youtube.pafy.channel_search","title":"<code>channel_search(query)</code>","text":"<p>Search channel based on keyword / query provided by user</p> Source code in <code>mps_youtube\\pafy.py</code> <pre><code>def channel_search(query):\n    '''\n    Search channel based on keyword / query provided by user\n    '''\n    async def _async_search():\n        channelsSearch = ChannelsSearch(query, limit=50, region='US')\n        result = await channelsSearch.next()\n        return result['result']\n\n    return asyncio.run(_async_search())\n</code></pre>"},{"location":"reference/pafy/#mps_youtube.pafy.download_video","title":"<code>download_video(ytid, folder, audio_only=False)</code>","text":"<p>Given a youtube video id and target folder, this function will download video to that folder</p> Source code in <code>mps_youtube\\pafy.py</code> <pre><code>def download_video(ytid, folder, audio_only=False):\n\n    '''\n    Given a youtube video id and target folder, this function will download video to that folder\n    '''\n\n    ytdl_format_options = {\n        'outtmpl': os.path.join(folder, '%(title)s-%(id)s.%(ext)s')\n    }\n    if audio_only:\n        ytdl_format_options['format'] = 'bestaudio/best'\n        ytdl_format_options['postprocessors'] =[{\n            'key': 'FFmpegExtractAudio',\n            'preferredcodec': 'mp3',\n            'preferredquality': '192',\n        }]\n\n    with yt_dlp.YoutubeDL(ytdl_format_options) as ydl:\n        ydl.download('https://www.youtube.com/watch?v=%s' % ytid)\n        return True\n</code></pre>"},{"location":"reference/pafy/#mps_youtube.pafy.extract_video_id","title":"<code>extract_video_id(url)</code>","text":"<p>Extract the video id from a url, return video id as str.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>url contain video id</p> required <p>Returns:</p> Type Description <code>str</code> <p>video id</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If no video id found</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; extract_video_id('http://example.com')\n&gt;&gt;&gt; extract_video_id('https://www.youtube.com/watch?v=LDU_Txk06tM')\nLDU_Txk06tM\n&gt;&gt;&gt; extract_video_id('https://youtu.be/LDU_Txk06tM')\nLDU_Txk06tM\n</code></pre> Source code in <code>mps_youtube\\pafy.py</code> <pre><code>def extract_video_id(url: str) -&gt; str:\n    \"\"\"Extract the video id from a url, return video id as str.\n\n    Args:\n        url: url contain video id\n\n    Returns:\n        video id\n\n    Raises:\n        ValueError: If no video id found\n\n    Examples:\n\n        &gt;&gt;&gt; extract_video_id('http://example.com')\n        &gt;&gt;&gt; extract_video_id('https://www.youtube.com/watch?v=LDU_Txk06tM')\n        LDU_Txk06tM\n        &gt;&gt;&gt; extract_video_id('https://youtu.be/LDU_Txk06tM')\n        LDU_Txk06tM\n    \"\"\"\n    idregx = re.compile(r'[\\w-]{11}$')\n    url = str(url).strip()\n\n    if idregx.match(url):\n        return url # ID of video\n\n    if '://' not in url:\n        url = '//' + url\n    parsedurl = urlparse(url)\n    if parsedurl.netloc in ('youtube.com', 'www.youtube.com', 'm.youtube.com', 'gaming.youtube.com'):\n        query = parse_qs(parsedurl.query)\n        if 'v' in query and idregx.match(query['v'][0]):\n            return query['v'][0]\n    elif parsedurl.netloc in ('youtu.be', 'www.youtu.be'):\n        vidid = parsedurl.path.split('/')[-1] if parsedurl.path else ''\n        if idregx.match(vidid):\n            return vidid\n\n    err = \"Need 11 character video id or the URL of the video. Got %s\"\n    raise ValueError(err % url)\n</code></pre>"},{"location":"reference/pafy/#mps_youtube.pafy.get_comments","title":"<code>get_comments(video_id)</code>","text":"<p>Get comments for a video using yt-dlp</p> Source code in <code>mps_youtube\\pafy.py</code> <pre><code>def get_comments(video_id):\n    '''\n    Get comments for a video using yt-dlp\n    '''\n    try:\n        with yt_dlp.YoutubeDL({'logger': MyLogger(), 'getcomments': True, 'skip_download': True}) as ydl:\n            info = ydl.extract_info(f'https://www.youtube.com/watch?v={video_id}', download=False)\n            comments = info.get('comments', [])\n            # Format to match expected structure\n            return [{'text': c.get('text', ''), 'author': c.get('author', ''), 'time': c.get('timestamp', 0)} for c in comments]\n    except Exception as e:\n        return []\n</code></pre>"},{"location":"reference/pafy/#mps_youtube.pafy.get_playlist","title":"<code>get_playlist(playlist_id)</code>","text":"<p>Get all videos of a playlist identified by playlist_id</p> Source code in <code>mps_youtube\\pafy.py</code> <pre><code>def get_playlist(playlist_id):\n    '''\n    Get all videos of a playlist identified by playlist_id\n    '''\n    async def _async_get():\n        playlist = await Playlist.get('https://www.youtube.com/playlist?list=%s' % playlist_id)\n        while playlist.hasMoreVideos:\n            await playlist.getNextVideos()\n        return playlist\n\n    return asyncio.run(_async_get())\n</code></pre>"},{"location":"reference/pafy/#mps_youtube.pafy.get_subtitles","title":"<code>get_subtitles(ytid, output_dir)</code>","text":"<p>Downloads and saves the .vtt subtitle of give youtube video id under path {output_dir}/subtitles Subtitles are selected as follows: 1. Select first user provided subtitle. If none then 2. Select auto generated 'en' subtitles</p> Source code in <code>mps_youtube\\pafy.py</code> <pre><code>def get_subtitles(ytid, output_dir):\n    '''\n    Downloads and saves the .vtt subtitle of give youtube video id under path {output_dir}/subtitles\n    Subtitles are selected as follows:\n    1. Select first user provided subtitle. If none then\n    2. Select auto generated 'en' subtitles\n    '''\n\n    if output_dir.endswith('/'):\n        output_dir = output_dir[:-1]\n    outtmpl = f'{output_dir}/subtitles/{ytid}'\n    # check if subtitles already exist\n    existing_subtitles = glob.glob(os.path.join(outtmpl+'*.vtt'))\n    if existing_subtitles:\n        return existing_subtitles[0]\n\n    url = f'https://www.youtube.com/watch?v={ytid}'\n    ydl_opts = {\n        'skip_download': True,\n        'writesubtitles': True,\n        'writeautomaticsub': True,\n        'subtitlesformat': 'vtt',\n        'outtmpl': outtmpl,\n        'logger': MyLogger(print_info=False),\n    }\n    # Create a YoutubeDL instance with the options\n    with yt_dlp.YoutubeDL(ydl_opts) as ydl:\n        info_dict = ydl.extract_info(url, download=False)\n        subtitles = info_dict.get('subtitles', {})\n        available_formats = list(subtitles.keys())\n        if available_formats:\n            lang = available_formats[0] # pick first subtitle from user-uploaded subtitles\n        else:\n            lang = 'en' # otherwise use english auto-generated subtitles\n        ydl.params['subtitleslangs'] = [lang]\n        # Add the new options to the existing ydl_opts dictionary\n        ydl.add_default_info_extractors()\n        # Create a new yt-dlp object with the updated ydl_opts dictionary\n        ydl = yt_dlp.YoutubeDL(ydl_opts)\n        # Download the subtitle\n        ydl.download([url])\n        path = f'{outtmpl}.{lang}.vtt'\n        return path if os.path.isfile(path) else None\n</code></pre>"},{"location":"reference/pafy/#mps_youtube.pafy.get_video_info","title":"<code>get_video_info(video_id)</code>","text":"<p>Get detailed information about a video</p> Source code in <code>mps_youtube\\pafy.py</code> <pre><code>def get_video_info(video_id):\n    '''\n    Get detailed information about a video\n    '''\n    async def _async_get():\n        try:\n            videoInfo = await Video.getInfo(video_id)\n            response = return_dislikes(video_id)\n            videoInfo['likes'] = response['likes']\n            videoInfo['dislikes'] = response['dislikes']\n            videoInfo['averageRating'] = response['rating']\n            return videoInfo\n        except:\n            raise Exception(\"Can't get video info. Video is either private or unavailable in your country.\")\n\n    return asyncio.run(_async_get())\n</code></pre>"},{"location":"reference/pafy/#mps_youtube.pafy.get_video_streams","title":"<code>get_video_streams(ytid)</code>","text":"<p>given a youtube video id returns different video / audio stream formats'     </p> Source code in <code>mps_youtube\\pafy.py</code> <pre><code>def get_video_streams(ytid):\n\n    '''\n    given a youtube video id returns different video / audio stream formats' \\\n    '''\n\n    with yt_dlp.YoutubeDL({'logger':MyLogger()}) as ydl:\n        info_dict = ydl.extract_info(ytid, download=False)\n        return [i for i in info_dict['formats'] if i.get('format_note') != 'storyboard']\n</code></pre>"},{"location":"reference/pafy/#mps_youtube.pafy.get_video_title_suggestions","title":"<code>get_video_title_suggestions(query)</code>","text":"<p>Get search suggestions for a query</p> Source code in <code>mps_youtube\\pafy.py</code> <pre><code>def get_video_title_suggestions(query):\n    '''\n    Get search suggestions for a query\n    '''\n    async def _async_get():\n        result = await Suggestions.get(query, language='en', region='US')\n        related_searches = result['result']\n        return related_searches[random.randint(0, len(related_searches) - 1)] if related_searches else query\n\n    return asyncio.run(_async_get())\n</code></pre>"},{"location":"reference/pafy/#mps_youtube.pafy.playlist_search","title":"<code>playlist_search(query)</code>","text":"<p>Returns all playlists having similar names as keyword / query provided</p> Source code in <code>mps_youtube\\pafy.py</code> <pre><code>def playlist_search(query):\n    '''\n    Returns all playlists having similar names as keyword / query provided\n    '''\n    async def _async_search():\n        playlistsSearch = PlaylistsSearch(query, limit=50)\n        result = await playlistsSearch.next()\n        return result['result']\n\n    return asyncio.run(_async_search())\n</code></pre>"},{"location":"reference/pafy/#mps_youtube.pafy.search_videos","title":"<code>search_videos(query, pages)</code>","text":"<p>Given a keyword / query this function will return youtube video results against those keywords / query</p> Source code in <code>mps_youtube\\pafy.py</code> <pre><code>def search_videos(query, pages):\n    '''\n    Given a keyword / query this function will return youtube video results against those keywords / query\n    '''\n    async def _async_search():\n        videosSearch = VideosSearch(query, limit=50)\n        result = await videosSearch.next()\n        wdata = result.get('result', []) if result else []\n        for i in range(pages-1):\n            try:\n                result = await videosSearch.next()\n                if result and 'result' in result:\n                    wdata.extend(result['result'])\n            except:\n                break\n        return wdata\n\n    return asyncio.run(_async_search())\n</code></pre>"},{"location":"reference/pafy/#mps_youtube.pafy.search_videos_from_channel","title":"<code>search_videos_from_channel(channel_id, query)</code>","text":"<p>Search for videos within a specific channel</p> Source code in <code>mps_youtube\\pafy.py</code> <pre><code>def search_videos_from_channel(channel_id, query):\n    '''\n    Search for videos within a specific channel\n    '''\n    async def _async_search():\n        search = ChannelSearch(query, channel_id)\n        result = await search.next()\n        return result\n\n    return asyncio.run(_async_search())\n</code></pre>"},{"location":"reference/paths/","title":"paths.py","text":""},{"location":"reference/paths/#mps_youtube.paths.get_config_dir","title":"<code>get_config_dir()</code>","text":"<p>Get user's configuration directory. Migrate to new mps name if old.</p> Source code in <code>mps_youtube\\paths.py</code> <pre><code>def get_config_dir():\n    \"\"\" Get user's configuration directory. Migrate to new mps name if old.\"\"\"\n    if mswin:\n        confdir = os.environ[\"APPDATA\"]\n\n    elif 'XDG_CONFIG_HOME' in os.environ:\n        confdir = os.environ['XDG_CONFIG_HOME']\n\n    else:\n        confdir = os.path.join(os.path.expanduser(\"~\"), '.config')\n\n    mps_confdir = os.path.join(confdir, \"mps-youtube\")\n\n    os.makedirs(mps_confdir, exist_ok=True)\n\n    return mps_confdir\n</code></pre>"},{"location":"reference/paths/#mps_youtube.paths.get_default_ddir","title":"<code>get_default_ddir()</code>","text":"<p>Get system default Download directory, append mps dir. </p> Source code in <code>mps_youtube\\paths.py</code> <pre><code>def get_default_ddir():\n    \"\"\" Get system default Download directory, append mps dir. \"\"\"\n    user_home = os.path.expanduser(\"~\")\n    join, exists = os.path.join, os.path.exists\n\n    if mswin:\n        return join(user_home, \"Downloads\", \"yewtube\")\n\n    USER_DIRS = join(user_home, \".config\", \"user-dirs.dirs\")\n    DOWNLOAD_HOME = join(user_home, \"Downloads\")\n\n    # define ddir by (1) env var, (2) user-dirs.dirs file,\n    #                (3) existing ~/Downloads dir (4) ~\n\n    if 'XDG_DOWNLOAD_DIR' in os.environ:\n        ddir = os.environ['XDG_DOWNLOAD_DIR']\n\n    elif exists(USER_DIRS):\n        lines = open(USER_DIRS).readlines()\n        defn = [x for x in lines if x.startswith(\"XDG_DOWNLOAD_DIR\")]\n\n        if len(defn) == 1:\n            ddir = defn[0].split(\"=\")[1].replace('\"', '')\n            ddir = ddir.replace(\"$HOME\", user_home).strip()\n\n        else:\n            ddir = DOWNLOAD_HOME if exists(DOWNLOAD_HOME) else user_home\n\n    else:\n        ddir = DOWNLOAD_HOME if exists(DOWNLOAD_HOME) else user_home\n\n    ddir = ddir\n    return os.path.join(ddir, \"mps\")\n</code></pre>"},{"location":"reference/player/","title":"player.py","text":""},{"location":"reference/player/#mps_youtube.player.BasePlayer","title":"<code> BasePlayer        </code>","text":"Source code in <code>mps_youtube\\player.py</code> <pre><code>class BasePlayer:\n    _playbackStatus = \"Paused\"\n    _last_displayed_line = None\n\n    @property\n    def PlaybackStatus(self):\n        return self._playbackStatus\n\n    @PlaybackStatus.setter\n    def PlaybackStatus(self, value):\n        self._playbackStatus = value\n        if value == 'Playing':\n            paused = False\n        else:\n            paused = True\n        g.mprisctl.send(('pause', paused))\n\n    def play(self, songlist, shuffle=False, repeat=False, override=False):\n        \"\"\" Play a range of songs, exit cleanly on keyboard interrupt. \"\"\"\n\n        if config.ALWAYS_REPEAT.get:\n            repeat = True\n\n        self.songlist = songlist\n        self.shuffle = shuffle\n        self.repeat = repeat\n        self.override = override\n        if shuffle:\n            random.shuffle(self.songlist)\n\n        self.song_no = 0\n        while 0 &lt;= self.song_no &lt;= len(self.songlist)-1:\n            self.song = self.songlist[self.song_no]\n            g.content = self._playback_progress(self.song_no, self.songlist,\n                                                repeat=repeat)\n\n            if not g.command_line:\n                screen.update(fill_blank=False)\n\n            hasnext = len(self.songlist) &gt; self.song_no + 1\n\n            if hasnext:\n                streams.preload(self.songlist[self.song_no + 1],\n                                override=self.override)\n\n            if config.SET_TITLE.get:\n                util.set_window_title(self.song.title + \" - yewtube\")\n\n            self.softrepeat = repeat and len(self.songlist) == 1\n\n            if g.scrobble:\n                lastfm.set_now_playing(g.artist, g.scrobble_queue[self.song_no])\n\n            try:\n                if config.SHOW_VIDEO and config.SHOW_SUBTITLES:\n                    self.subtitle_path = pafy.get_subtitles(self.song.ytid, config.DDIR.get)\n                self.video, self.stream, self.override = stream_details(\n                                                            self.song,\n                                                            override=self.override,\n                                                            softrepeat=self.softrepeat)\n                self._playsong()\n\n            except KeyboardInterrupt:\n                logging.info(\"Keyboard Interrupt\")\n                util.xprint(c.w + \"Stopping...                          \")\n                screen.reset_terminal()\n                g.message = c.y + \"Playback halted\" + c.w\n                raise KeyboardInterrupt\n                break\n\n            # skip forbidden, video removed/no longer available, etc. tracks\n            except (TypeError, Exception) as e:\n                import traceback\n                traceback.print_exception(type(e), e, e.__traceback__)\n                self.song_no += 1\n                pass\n\n            if config.SET_TITLE.get:\n                util.set_window_title(\"yewtube\")\n\n            if self.song_no == -1:\n                self.song_no = len(songlist) - 1 if repeat else 0\n            elif self.song_no == len(self.songlist) and repeat:\n                self.song_no = 0\n\n    # To be defined by subclass based on being cmd player or library\n    # When overriding next and previous don't forget to add the following\n    # if g.scrobble:\n    #   lastfm.scrobble_track(g.artist, g.album, g.scrobble_queue[self.song_no])\n    def next(self):\n        pass\n\n    def previous(self):\n        pass\n\n    def stop(self):\n        pass\n    ###############\n\n    def seek(self):\n        pass\n\n    def _playsong(self, failcount=0, softrepeat=False):\n        \"\"\" Play song using config.PLAYER called with args config.PLAYERARGS.\n\n        \"\"\"\n        # pylint: disable=R0911,R0912\n        if not config.PLAYER.get or not util.has_exefile(config.PLAYER.get):\n            g.message = \"Player not configured! Enter %sset player &lt;player_app&gt; \"\\\n                \"%s to set a player\" % (c.g, c.w)\n            return\n\n        if config.NOTIFIER.get:\n            subprocess.Popen(shlex.split(config.NOTIFIER.get) + [self.song.title])\n\n        size = streams.get_size(self.song.ytid, self.stream['url'])\n        songdata = (self.song.ytid, '' if self.stream.get('ext') is None else self.stream.get('ext') + \" \" + self.stream['quality'],\n                    int(size / (1024 ** 2)))\n        self.songdata = \"%s; %s; %s Mb\" % songdata\n        screen.writestatus(self.songdata)\n\n        self._launch_player()\n\n        if config.HISTORY.get:\n            history.add(self.song)\n\n    def _launch_player(self):\n        \"\"\" Launch player application. \"\"\"\n        pass\n\n    def send_metadata_mpris(self):\n        metadata = util._get_metadata(self.song.title) if config.LOOKUP_METADATA.get else None\n\n        if metadata is None:\n            arturl = \"https://i.ytimg.com/vi/%s/default.jpg\" % self.song.ytid\n            metadata = (self.song.ytid, self.song.title, self.song.length,\n                        arturl, [''], '')\n        else:\n            arturl = metadata['album_art_url']\n            metadata = (self.song.ytid, metadata['track_title'],\n                        self.song.length, arturl,\n                        [metadata['artist']], metadata['album'])\n\n        if g.mprisctl:\n            g.mprisctl.send(('metadata', metadata))\n\n    def _playback_progress(self, idx, allsongs, repeat=False):\n        \"\"\" Generate string to show selected tracks, indicate current track. \"\"\"\n        # pylint: disable=R0914\n        # too many local variables\n        cw = util.getxy().width\n        out = \"  %s%-XXs%s%s\\n\".replace(\"XX\", str(cw - 9))\n        out = out % (c.ul, \"Title\", \"Time\", c.w)\n        multi = len(allsongs) &gt; 1\n\n        for n, song in enumerate(allsongs):\n            length_orig = util.fmt_time(song.length)\n            length = \" \" * (8 - len(length_orig)) + length_orig\n            i = util.uea_pad(cw - 14, song.title), length, length_orig\n            fmt = (c.w, \"  \", c.b, i[0], c.w, c.y, i[1], c.w)\n\n            if n == idx:\n                fmt = (c.y, \"&gt; \", c.p, i[0], c.w, c.p, i[1], c.w)\n                cur = i\n\n            out += \"%s%s%s%s%s %s%s%s\\n\" % fmt\n\n        out += \"\\n\" * (3 - len(allsongs))\n        pos = 8 * \" \", c.y, idx + 1, c.w, c.y, len(allsongs), c.w\n        playing = \"{}{}{}{} of {}{}{}\\n\\n\".format(*pos) if multi else \"\\n\\n\"\n        keys = self._help(short=(not multi and not repeat))\n        out = out if multi else content.generate_songlist_display(song=allsongs[0])\n\n        if config.SHOW_PLAYER_KEYS.get and keys is not None:\n            out += \"\\n\" + keys\n\n        else:\n            playing = \"{}{}{}{} of {}{}{}\\n\".format(*pos) if multi else \"\\n\"\n            out += \"\\n\" + \" \" * (cw - 19) if multi else \"\"\n\n        fmt = playing, c.r, cur[0].strip()[:cw - 19], c.w, c.w, cur[2], c.w\n        out += \"%s    %s%s%s %s[%s]%s\" % fmt\n        out += \"    REPEAT MODE\" if repeat else \"\"\n        return out\n\n    def make_status_line(self, elapsed_s, prefix, songlength=0, volume=None):\n        self._line = self._make_status_line(elapsed_s, prefix, songlength,\n                                            volume=volume)\n\n        if self._line != self._last_displayed_line:\n            screen.writestatus(self._line)\n            self._last_displayed_line = self._line\n\n    def _make_status_line(self, elapsed_s, prefix, songlength=0, volume=None):\n        \"\"\" Format progress line output.  \"\"\"\n        # pylint: disable=R0914\n\n        display_s = elapsed_s\n        display_h = display_m = 0\n\n        if elapsed_s &gt;= 60:\n            display_m = display_s // 60\n            display_s %= 60\n\n            if display_m &gt;= 60:\n                display_h = display_m // 60\n                display_m %= 60\n\n        pct = (float(elapsed_s) / songlength * 100) if songlength else 0\n\n        status_line = \"%02i:%02i:%02i %s\" % (\n            display_h, display_m, display_s,\n            (\"[%.0f%%]\" % pct).ljust(6)\n        )\n\n        if volume:\n            vol_suffix = \" vol: %d%%\" % volume\n\n        else:\n            vol_suffix = \"\"\n\n        cw = util.getxy().width\n        prog_bar_size = cw - len(prefix) - len(status_line) - len(vol_suffix) - 7\n        progress = int(math.ceil(pct / 100 * prog_bar_size))\n        status_line += \" [%s]\" % (\"=\" * (progress - 1) +\n                                  \"&gt;\").ljust(prog_bar_size, ' ')\n        return prefix + status_line + vol_suffix\n</code></pre>"},{"location":"reference/player/#mps_youtube.player.BasePlayer.play","title":"<code>play(self, songlist, shuffle=False, repeat=False, override=False)</code>","text":"<p>Play a range of songs, exit cleanly on keyboard interrupt. </p> Source code in <code>mps_youtube\\player.py</code> <pre><code>def play(self, songlist, shuffle=False, repeat=False, override=False):\n    \"\"\" Play a range of songs, exit cleanly on keyboard interrupt. \"\"\"\n\n    if config.ALWAYS_REPEAT.get:\n        repeat = True\n\n    self.songlist = songlist\n    self.shuffle = shuffle\n    self.repeat = repeat\n    self.override = override\n    if shuffle:\n        random.shuffle(self.songlist)\n\n    self.song_no = 0\n    while 0 &lt;= self.song_no &lt;= len(self.songlist)-1:\n        self.song = self.songlist[self.song_no]\n        g.content = self._playback_progress(self.song_no, self.songlist,\n                                            repeat=repeat)\n\n        if not g.command_line:\n            screen.update(fill_blank=False)\n\n        hasnext = len(self.songlist) &gt; self.song_no + 1\n\n        if hasnext:\n            streams.preload(self.songlist[self.song_no + 1],\n                            override=self.override)\n\n        if config.SET_TITLE.get:\n            util.set_window_title(self.song.title + \" - yewtube\")\n\n        self.softrepeat = repeat and len(self.songlist) == 1\n\n        if g.scrobble:\n            lastfm.set_now_playing(g.artist, g.scrobble_queue[self.song_no])\n\n        try:\n            if config.SHOW_VIDEO and config.SHOW_SUBTITLES:\n                self.subtitle_path = pafy.get_subtitles(self.song.ytid, config.DDIR.get)\n            self.video, self.stream, self.override = stream_details(\n                                                        self.song,\n                                                        override=self.override,\n                                                        softrepeat=self.softrepeat)\n            self._playsong()\n\n        except KeyboardInterrupt:\n            logging.info(\"Keyboard Interrupt\")\n            util.xprint(c.w + \"Stopping...                          \")\n            screen.reset_terminal()\n            g.message = c.y + \"Playback halted\" + c.w\n            raise KeyboardInterrupt\n            break\n\n        # skip forbidden, video removed/no longer available, etc. tracks\n        except (TypeError, Exception) as e:\n            import traceback\n            traceback.print_exception(type(e), e, e.__traceback__)\n            self.song_no += 1\n            pass\n\n        if config.SET_TITLE.get:\n            util.set_window_title(\"yewtube\")\n\n        if self.song_no == -1:\n            self.song_no = len(songlist) - 1 if repeat else 0\n        elif self.song_no == len(self.songlist) and repeat:\n            self.song_no = 0\n</code></pre>"},{"location":"reference/player/#mps_youtube.player.stream_details","title":"<code>stream_details(song, failcount=0, override=False, softrepeat=False)</code>","text":"<p>Fetch stream details for a song.</p> Source code in <code>mps_youtube\\player.py</code> <pre><code>def stream_details(song, failcount=0, override=False, softrepeat=False):\n    \"\"\"Fetch stream details for a song.\"\"\"\n    # don't interrupt preloading:\n    while song.ytid in g.preloading:\n        screen.writestatus(\"fetching item..\")\n        time.sleep(0.1)\n\n    try:\n        streams.get(song, force=failcount, callback=screen.writestatus)\n\n    except (IOError, URLError, HTTPError, socket.timeout) as e:\n        util.dbg(\"--ioerror in stream_details call to streams.get %s\", str(e))\n\n        if \"Youtube says\" in str(e):\n            g.message = util.F('cant get track') % (song.title + \" \" + str(e))\n            return\n\n        elif failcount &lt; g.max_retries:\n            util.dbg(\"--ioerror - trying next stream\")\n            failcount += 1\n            return stream_details(song, failcount=failcount, override=override, softrepeat=softrepeat)\n\n        elif \"pafy\" in str(e):\n            g.message = str(e) + \" - \" + song.ytid\n            return\n\n    except ValueError:\n        g.message = util.F('track unresolved')\n        util.dbg(\"----valueerror in stream_details call to streams.get\")\n        return\n\n    if failcount == g.max_retries:\n        raise TypeError()\n\n    try:\n        video = ((config.SHOW_VIDEO.get and override != \"audio\") or\n                 (override in (\"fullscreen\", \"window\", \"forcevid\")))\n        m4a = \"mplayer\" not in config.PLAYER.get\n        cached = g.streams[song.ytid]\n        stream = streams.select(cached, q=failcount, audio=(not video), m4a_ok=m4a)\n\n        # handle no audio stream available, or m4a with mplayer\n        # by switching to video stream and suppressing video output.\n        if (not stream or failcount) and not video:\n            util.dbg(c.r + \"no audio or mplayer m4a, using video stream\" + c.w)\n            override = \"a-v\"\n            video = True\n            stream = streams.select(cached, q=failcount, audio=False, maxres=1600)\n\n        if not stream:\n            raise IOError(\"No streams available\")\n\n        return (video, stream, override)\n\n    except (HTTPError) as e:\n\n        # Fix for invalid streams (gh-65)\n        util.dbg(\"----htterror in stream_details call to gen_real_args %s\", str(e))\n        if failcount &lt; g.max_retries:\n            failcount += 1\n            return stream_details(song, failcount=failcount,\n                                  override=override, softrepeat=softrepeat)\n        else:\n            g.message = str(e)\n            return\n\n    except IOError as e:\n        # this may be cause by attempting to play a https stream with\n        # mplayer\n        # ====\n        errmsg = e.message if hasattr(e, \"message\") else str(e)\n        g.message = c.r + str(errmsg) + c.w\n        return\n</code></pre>"},{"location":"reference/playlist/","title":"playlist.py","text":""},{"location":"reference/playlist/#mps_youtube.playlist.Playlist","title":"<code> Playlist        </code>","text":"<p>Representation of a playist, has list of songs. </p> Source code in <code>mps_youtube\\playlist.py</code> <pre><code>class Playlist:\n\n    \"\"\" Representation of a playist, has list of songs. \"\"\"\n\n    def __init__(self, name=None, songs=None):\n        \"\"\" class members. \"\"\"\n        self.name = name\n        self.songs = songs or []\n\n    def __len__(self):\n        \"\"\" Return number of tracks. \"\"\"\n        return len(self.songs)\n\n    def __getitem__(self, sliced):\n        return self.songs[sliced]\n\n    def __setitem__(self, position, item):\n        self.songs[position] = item\n\n    def __iter__(self):\n        for i in self.songs:\n            yield i\n\n    @property\n    def duration(self):\n        \"\"\" Sum duration of the playlist. \"\"\"\n        duration = sum(s.length for s in self.songs)\n        mins, secs = divmod(duration, 60)\n        hours, mins = divmod(mins, 60)\n        duration = '{H:02}:{M:02}:{S:02}'.format(H=hours, M=mins, S=secs)\n        return duration\n</code></pre>"},{"location":"reference/playlist/#mps_youtube.playlist.Playlist.duration","title":"<code>duration</code>  <code>property</code> <code>readonly</code>","text":"<p>Sum duration of the playlist. </p>"},{"location":"reference/playlist/#mps_youtube.playlist.Playlist.__init__","title":"<code>__init__(self, name=None, songs=None)</code>  <code>special</code>","text":"<p>class members. </p> Source code in <code>mps_youtube\\playlist.py</code> <pre><code>def __init__(self, name=None, songs=None):\n    \"\"\" class members. \"\"\"\n    self.name = name\n    self.songs = songs or []\n</code></pre>"},{"location":"reference/playlist/#mps_youtube.playlist.Playlist.__len__","title":"<code>__len__(self)</code>  <code>special</code>","text":"<p>Return number of tracks. </p> Source code in <code>mps_youtube\\playlist.py</code> <pre><code>def __len__(self):\n    \"\"\" Return number of tracks. \"\"\"\n    return len(self.songs)\n</code></pre>"},{"location":"reference/playlist/#mps_youtube.playlist.Video","title":"<code> Video        </code>","text":"<p>Class to represent a YouTube video. </p> Source code in <code>mps_youtube\\playlist.py</code> <pre><code>class Video:\n\n    \"\"\" Class to represent a YouTube video. \"\"\"\n    description = \"\"\n    def __init__(self, ytid, title, length):\n        \"\"\" class members. \"\"\"\n        self.ytid = ytid\n        self.title = title\n        self.length = int(length)\n</code></pre>"},{"location":"reference/playlist/#mps_youtube.playlist.Video.__init__","title":"<code>__init__(self, ytid, title, length)</code>  <code>special</code>","text":"<p>class members. </p> Source code in <code>mps_youtube\\playlist.py</code> <pre><code>def __init__(self, ytid, title, length):\n    \"\"\" class members. \"\"\"\n    self.ytid = ytid\n    self.title = title\n    self.length = int(length)\n</code></pre>"},{"location":"reference/playlists/","title":"playlists.py","text":""},{"location":"reference/playlists/#mps_youtube.playlists.delete","title":"<code>delete(name)</code>","text":"<p>Delete playlist, including m3u file. </p> Source code in <code>mps_youtube\\playlists.py</code> <pre><code>def delete(name):\n    \"\"\" Delete playlist, including m3u file. \"\"\"\n    del g.userpl[name]\n    os.remove(os.path.join(g.PLFOLDER, name + '.m3u'))\n</code></pre>"},{"location":"reference/playlists/#mps_youtube.playlists.load","title":"<code>load()</code>","text":"<p>Open playlists. Called once on script invocation. </p> Source code in <code>mps_youtube\\playlists.py</code> <pre><code>def load():\n    \"\"\" Open playlists. Called once on script invocation. \"\"\"\n    _convert_playlist_to_v2()\n    _convert_playlist_to_m3u()\n    try:\n        # Loop through all files ending in '.m3u'\n        for m3u in [m3u for m3u in os.listdir(g.PLFOLDER) if m3u[-4:] == '.m3u']:\n            g.userpl[m3u[:-4]] = read_m3u(os.path.join(g.PLFOLDER, m3u))\n\n    except FileNotFoundError:\n        # No playlist folder, create an empty one\n        if not os.path.isdir(g.PLFOLDER):\n            g.userpl = {}\n            os.mkdir(g.PLFOLDER)\n            save()\n\n    # remove any cached urls from playlist file, these are now\n    # stored in a separate cache file\n\n    do_save = False\n\n    for k, v in g.userpl.items():\n        for song in v.songs:\n            if hasattr(song, \"urls\"):\n                util.dbg(\"remove %s: %s\", k, song.urls)\n                del song.urls\n                do_save = True\n\n    if do_save:\n        save()\n</code></pre>"},{"location":"reference/playlists/#mps_youtube.playlists.read_m3u","title":"<code>read_m3u(m3u)</code>","text":"<p>Processes an m3u file into a Playlist object. </p> Source code in <code>mps_youtube\\playlists.py</code> <pre><code>def read_m3u(m3u):\n    \"\"\" Processes an m3u file into a Playlist object. \"\"\"\n    name = os.path.basename(m3u)[:-4]\n    songs = []\n    expect_ytid = False\n\n    with open(m3u, 'r') as plf:\n        if plf.readline().startswith('#EXTM3U'):\n            for line in plf:\n                if line.startswith('#EXTINF:') and not expect_ytid:\n                    duration, title = line.replace('#EXTINF:', '').strip().split(',', 1)\n                    expect_ytid = True\n                elif not line.startswith('\\n') and not line.startswith('#') and expect_ytid:\n                    try:\n                        expect_ytid = False\n                        ytid = pafy.extract_video_id(line).strip()\n                        songs.append(Video(ytid, title, int(duration)))\n                    except ValueError as ex:\n                        util.dbg(c.r + str(ex) + c.w)\n        # Handles a simple m3u file which should just be a list of urls\n        else:\n            plf.seek(0)\n            for line in plf:\n                if not line.startswith('#'):\n                    try:\n                        p = util.get_pafy(line)\n                        songs.append(Video(p.videoid, p.title, p.length))\n                    except (IOError, ValueError) as e:\n                        util.dbg(c.r + \"Error loading video: \" + str(e) + c.w)\n\n    return Playlist(name, songs)\n</code></pre>"},{"location":"reference/playlists/#mps_youtube.playlists.save","title":"<code>save()</code>","text":"<p>Save playlists.  Called each time a playlist is saved or deleted. </p> Source code in <code>mps_youtube\\playlists.py</code> <pre><code>def save():\n    \"\"\" Save playlists.  Called each time a playlist is saved or deleted. \"\"\"\n    for pl in g.userpl:\n        with open(os.path.join(g.PLFOLDER, pl+'.m3u'), 'w') as plf:\n            plf.write('#EXTM3U\\n\\n')\n            for song in g.userpl[pl].songs:\n                plf.write('#EXTINF:%d,%s\\n' % (song.length, song.title))\n                plf.write('https://www.youtube.com/watch?v=%s\\n' % song.ytid)\n\n    util.dbg(c.r + \"Playlist saved\\n---\" + c.w)\n</code></pre>"},{"location":"reference/screen/","title":"screen.py","text":""},{"location":"reference/screen/#mps_youtube.screen.clear","title":"<code>clear()</code>","text":"<p>Clear all text from screen.</p> Source code in <code>mps_youtube\\screen.py</code> <pre><code>def clear():\n    \"\"\"Clear all text from screen.\"\"\"\n    if g.no_clear_screen:\n        util.xprint('--\\n')\n    else:\n        util.xprint('\\n' * 200)\n</code></pre>"},{"location":"reference/screen/#mps_youtube.screen.msgexit","title":"<code>msgexit(msg, code=0)</code>","text":"<p>Print a message and exit. </p> Source code in <code>mps_youtube\\screen.py</code> <pre><code>def msgexit(msg, code=0):\n    \"\"\" Print a message and exit. \"\"\"\n    util.xprint(msg)\n    sys.exit(code)\n</code></pre>"},{"location":"reference/screen/#mps_youtube.screen.reset_terminal","title":"<code>reset_terminal()</code>","text":"<p>Reset terminal control character and modes for non Win OS's. </p> Source code in <code>mps_youtube\\screen.py</code> <pre><code>def reset_terminal():\n    \"\"\" Reset terminal control character and modes for non Win OS's. \"\"\"\n    if not mswin:\n        subprocess.call([\"tset\", \"-c\"])\n</code></pre>"},{"location":"reference/screen/#mps_youtube.screen.update","title":"<code>update(fill_blank=True)</code>","text":"<p>Display content, show message, blank screen.</p> Source code in <code>mps_youtube\\screen.py</code> <pre><code>def update(fill_blank=True):\n    \"\"\" Display content, show message, blank screen.\"\"\"\n    clear()\n\n    if isinstance(g.content, content.PaginatedContent):\n        util.xprint(g.content.getPage(g.current_page))\n        g.rprompt = content.page_msg(g.current_page)\n    elif g.content:\n        util.xprint(g.content)\n        g.content = False\n\n    if g.message or g.rprompt:\n        out = g.message or ''\n        blanks = util.getxy().width - len(out) - len(g.rprompt or '')\n        out += ' ' * blanks + (g.rprompt or '')\n        util.xprint(out)\n\n    elif fill_blank:\n        util.xprint(\"\")\n\n    g.message = g.rprompt = False\n</code></pre>"},{"location":"reference/screen/#mps_youtube.screen.writestatus","title":"<code>writestatus(text, mute=False)</code>","text":"<p>Update status line. </p> Source code in <code>mps_youtube\\screen.py</code> <pre><code>def writestatus(text, mute=False):\n    \"\"\" Update status line. \"\"\"\n    if not mute and config.SHOW_STATUS.get:\n        _writeline(text)\n</code></pre>"},{"location":"reference/streams/","title":"streams.py","text":""},{"location":"reference/streams/#mps_youtube.streams.get","title":"<code>get(vid, force=False, callback=None, threeD=False)</code>","text":"<p>Get all streams as a dict.  callback function passed to get_pafy. </p> Source code in <code>mps_youtube\\streams.py</code> <pre><code>def get(vid, force=False, callback=None, threeD=False):\n    \"\"\" Get all streams as a dict.  callback function passed to get_pafy. \"\"\"\n    now = time.time()\n    ytid = vid.ytid\n    have_stream = g.streams.get(ytid) and (g.streams[ytid]['expiry'] &gt; now if g.streams[ytid]['expiry'] is not None else False)\n    prfx = \"preload: \" if not callback else \"\"\n\n    if not force and have_stream:\n        ss = str(int(g.streams[ytid]['expiry'] - now) // 60)\n        util.dbg(\"%s%sGot streams from cache (%s mins left)%s\",\n                c.g, prfx, ss, c.w)\n        return g.streams.get(ytid)['meta']\n\n\n    #p = None#util.get_pafy(vid, force=force, callback=callback)\n    #ps = p.allstreams if threeD else [x for x in p.allstreams if not x.threed]\n    ps = pafy.get_video_streams(ytid)\n\n    try:\n        # test urls are valid\n        [x['url'] for x in ps]\n\n    except TypeError:\n        # refetch if problem\n        util.dbg(\"%s****Type Error in get_streams. Retrying%s\", c.r, c.w)\n        p = util.get_pafy(vid, force=True, callback=callback)\n        ps = p.allstreams if threeD else [x for x in p.allstreams\n                                          if not x.threed]\n\n    streams = [{\"url\": s['url'],\n                \"ext\": s['ext'],\n                \"quality\": s['resolution'],\n                \"rawbitrate\": s.get('bitrate',-1),\n                \"mtype\": 'audio' if 'audio' in s['resolution'] else ('video' if s['acodec'] != 'none' else '?'),\n                \"size\": int(s.get('filesize') if s.get('filesize') is not None else s.get('filesize_approx', -1))} for s in ps]\n\n\n    if 'manifest' in streams[0]['url']:\n        expiry = float(streams[0]['url'].split('/expire/')[1].split('/')[0])\n    else:\n        temp = streams[0]['url'].split('expire=')[1]\n        expiry = float(temp[:temp.find('&amp;')])\n\n    g.streams[ytid] = dict(expiry=expiry, meta=streams)\n    prune()\n    return streams\n</code></pre>"},{"location":"reference/streams/#mps_youtube.streams.get_size","title":"<code>get_size(ytid, url, preloading=False)</code>","text":"<p>Get size of stream, try stream cache first. </p> Source code in <code>mps_youtube\\streams.py</code> <pre><code>def get_size(ytid, url, preloading=False):\n    \"\"\" Get size of stream, try stream cache first. \"\"\"\n    # try cached value\n    stream = [x for x in g.streams[ytid]['meta'] if x['url'] == url][0]\n    size = stream['size']\n    prefix = \"preload: \" if preloading else \"\"\n\n    if not size == -1:\n        util.dbg(\"%s%susing cached size: %s%s\", c.g, prefix, size, c.w)\n\n    else:\n        screen.writestatus(\"Getting content length\", mute=preloading)\n        stream['size'] = _get_content_length(url, preloading=preloading)\n        util.dbg(\"%s%s - content-length: %s%s\", c.y, prefix, stream['size'], c.w)\n\n    return stream['size']\n</code></pre>"},{"location":"reference/streams/#mps_youtube.streams.preload","title":"<code>preload(song, delay=2, override=False)</code>","text":"<p>Get streams. </p> Source code in <code>mps_youtube\\streams.py</code> <pre><code>def preload(song, delay=2, override=False):\n    \"\"\"  Get streams. \"\"\"\n    args = (song, delay, override)\n    t = threading.Thread(target=_preload, args=args)\n    t.daemon = True\n    t.start()\n</code></pre>"},{"location":"reference/streams/#mps_youtube.streams.prune","title":"<code>prune()</code>","text":"<p>Keep cache size in check. </p> Source code in <code>mps_youtube\\streams.py</code> <pre><code>def prune():\n    \"\"\" Keep cache size in check. \"\"\"\n    while len(g.pafs) &gt; g.max_cached_streams:\n        g.pafs.popitem(last=False)\n\n    while len(g.streams) &gt; g.max_cached_streams:\n        g.streams.popitem(last=False)\n\n    # prune time expired items\n\n    now = time.time()\n    oldpafs = [k for k in g.pafs if g.pafs[k] is not None and g.pafs[k].expiry &lt; now]\n\n    if len(oldpafs):\n        util.dbg(c.r + \"%s old pafy items pruned%s\", len(oldpafs), c.w)\n\n    for oldpaf in oldpafs:\n        g.pafs.pop(oldpaf, 0)\n\n    oldstreams = [k for k in g.streams if g.streams[k]['expiry'] is None or g.streams[k]['expiry'] &lt; now]\n\n    if len(oldstreams):\n        util.dbg(c.r + \"%s old stream items pruned%s\", len(oldstreams), c.w)\n\n    for oldstream in oldstreams:\n        g.streams.pop(oldstream, 0)\n\n    util.dbg(c.b + \"paf: %s, streams: %s%s\", len(g.pafs), len(g.streams), c.w)\n</code></pre>"},{"location":"reference/streams/#mps_youtube.streams.select","title":"<code>select(slist, q=0, audio=False, m4a_ok=True, maxres=None)</code>","text":"<p>Select a stream from stream list. </p> Source code in <code>mps_youtube\\streams.py</code> <pre><code>def select(slist, q=0, audio=False, m4a_ok=True, maxres=None):\n    \"\"\" Select a stream from stream list. \"\"\"\n    maxres = maxres or config.MAX_RES.get\n    slist = slist['meta'] if isinstance(slist, dict) else slist\n\n    def okres(x):\n        \"\"\" Return True if resolution is within user specified maxres. \"\"\"\n        return int(x['quality'].split(\"x\")[1]) &lt;= maxres\n\n    def getq(x):\n        \"\"\" Return height aspect of resolution, eg 640x480 =&gt; 480. \"\"\"\n        return int(x['quality'].split(\"x\")[1])\n\n    def getbitrate(x):\n        \"\"\"Return the bitrate of a stream.\"\"\"\n        return x['rawbitrate']\n\n    if audio:\n        streams = [x for x in slist if x['mtype'] == \"audio\"]\n        if not m4a_ok:\n            streams = [x for x in streams if not x['ext'] == \"m4a\"]\n        if not config.AUDIO_FORMAT.get == \"auto\":\n            if m4a_ok and config.AUDIO_FORMAT.get == \"m4a\":\n                streams = [x for x in streams if x['ext'] == \"m4a\"]\n            if config.AUDIO_FORMAT.get == \"webm\":\n                streams = [x for x in streams if x['ext'] == \"webm\"]\n            if not streams:\n                streams = [x for x in slist if x['mtype'] == \"audio\"]\n        streams = sorted(streams, key=getbitrate, reverse=True)\n    else:\n        streams = [x for x in slist if x['mtype'] == \"video\" and okres(x)]\n        if not config.VIDEO_FORMAT.get == \"auto\":\n            if config.VIDEO_FORMAT.get == \"mp4\":\n                streams = [x for x in streams if x['ext'] == \"mp4\"]\n            if config.VIDEO_FORMAT.get == \"webm\":\n                streams = [x for x in streams if x['ext'] == \"webm\"]\n            if config.VIDEO_FORMAT.get == \"3gp\":\n                streams = [x for x in streams if x['ext'] == \"3gp\"]\n            if not streams:\n                streams = [x for x in slist if x['mtype'] == \"video\" and okres(x)]\n        streams = sorted(streams, key=getq, reverse=True)\n\n    util.dbg(\"select stream, q: %s, audio: %s, len: %s\", q, audio, len(streams))\n\n    try:\n        ret = streams[q]\n\n    except IndexError:\n        ret = streams[0] if q and len(streams) else None\n\n    return ret\n</code></pre>"},{"location":"reference/terminalsize/","title":"terminalsize.py","text":"<p>Terminal Size. </p>"},{"location":"reference/terminalsize/#mps_youtube.terminalsize.get_terminal_size","title":"<code>get_terminal_size()</code>","text":"<p>getTerminalSize().</p> <ul> <li>get width and height of console</li> <li>works on linux,os x,windows,cygwin(windows) originally retrieved from: http://stackoverflow.com/questions/566746/how-to-get-console-window-width-in-python</li> </ul> Source code in <code>mps_youtube\\terminalsize.py</code> <pre><code>def get_terminal_size():\n    \"\"\" getTerminalSize().\n\n    - get width and height of console\n    - works on linux,os x,windows,cygwin(windows)\n    originally retrieved from:\n    http://stackoverflow.com/questions/566746/how-to-get-console-window-width-in-python\n    \"\"\"\n\n    if sys.version_info &gt;= (3,3):\n        return shutil.get_terminal_size()\n\n    current_os = platform.system()\n    tuple_xy = None\n\n    if current_os == 'Windows':\n        tuple_xy = _get_terminal_size_windows()\n\n        if tuple_xy is None:\n            tuple_xy = _get_terminal_size_tput()\n            # needed for window's python in cygwin's xterm!\n\n    else:\n        tuple_xy = _get_terminal_size_linux()\n\n    if tuple_xy is None:\n        tuple_xy = (80, 25)      # default value\n\n    return tuple_xy\n</code></pre>"},{"location":"reference/util/","title":"util.py","text":""},{"location":"reference/util/#mps_youtube.util.IterSlicer","title":"<code> IterSlicer        </code>","text":"<p>Class that takes an iterable and allows slicing, loading from the iterable as needed.</p> Source code in <code>mps_youtube\\util.py</code> <pre><code>class IterSlicer():\n    \"\"\" Class that takes an iterable and allows slicing,\n        loading from the iterable as needed.\"\"\"\n\n    def __init__(self, iterable, length=None):\n        self.ilist = []\n        self.iterable = iter(iterable)\n        self.length = length\n        if length is None:\n            try:\n                self.length = len(iterable)\n            except TypeError:\n                pass\n\n    def __getitem__(self, sliced):\n        if isinstance(sliced, slice):\n            stop = sliced.stop\n        else:\n            stop = sliced\n        # To get the last item in an iterable, must iterate over all items\n        if (stop is None) or (stop &lt; 0):\n            stop = None\n        while (stop is None) or (stop &gt; len(self.ilist) - 1):\n            try:\n                self.ilist.append(next(self.iterable))\n            except StopIteration:\n                break\n\n        return self.ilist[sliced]\n\n    def __len__(self):\n        if self.length is None:\n            self.length = len(self[:])\n        return self.length\n</code></pre>"},{"location":"reference/util/#mps_youtube.util.XYTuple","title":"<code> XYTuple            (tuple)         </code>","text":"<p>XYTuple(width, height, max_results)</p>"},{"location":"reference/util/#mps_youtube.util.XYTuple.__getnewargs__","title":"<code>__getnewargs__(self)</code>  <code>special</code>","text":"<p>Return self as a plain tuple.  Used by copy and pickle.</p> Source code in <code>mps_youtube\\util.py</code> <pre><code>def __getnewargs__(self):\n    'Return self as a plain tuple.  Used by copy and pickle.'\n    return _tuple(self)\n</code></pre>"},{"location":"reference/util/#mps_youtube.util.XYTuple.__new__","title":"<code>__new__(_cls, width, height, max_results)</code>  <code>special</code> <code>staticmethod</code>","text":"<p>Create new instance of XYTuple(width, height, max_results)</p>"},{"location":"reference/util/#mps_youtube.util.XYTuple.__replace__","title":"<code>__replace__(/, self, **kwds)</code>  <code>special</code>","text":"<p>Return a new XYTuple object replacing specified fields with new values</p> Source code in <code>mps_youtube\\util.py</code> <pre><code>def _replace(self, /, **kwds):\n    result = self._make(_map(kwds.pop, field_names, self))\n    if kwds:\n        raise TypeError(f'Got unexpected field names: {list(kwds)!r}')\n    return result\n</code></pre>"},{"location":"reference/util/#mps_youtube.util.XYTuple.__repr__","title":"<code>__repr__(self)</code>  <code>special</code>","text":"<p>Return a nicely formatted representation string</p> Source code in <code>mps_youtube\\util.py</code> <pre><code>def __repr__(self):\n    'Return a nicely formatted representation string'\n    return self.__class__.__name__ + repr_fmt % self\n</code></pre>"},{"location":"reference/util/#mps_youtube.util.F","title":"<code>F(key, nb=0, na=0, textlib=None)</code>","text":"<p>Format text.</p> <p>:param nb: newline before :type nb: int :param na: newline after :type na: int :param textlib: the dictionary to use (defaults to g.text if not given) :type textlib: dict :returns: A string, potentially containing one or more %s :rtype: str</p> Source code in <code>mps_youtube\\util.py</code> <pre><code>def F(key, nb=0, na=0, textlib=None):\n    \"\"\"Format text.\n\n    :param nb: newline before\n    :type nb: int\n    :param na: newline after\n    :type na: int\n    :param textlib: the dictionary to use (defaults to g.text if not given)\n    :type textlib: dict\n    :returns: A string, potentially containing one or more %s\n    :rtype: str\n    \"\"\"\n    textlib = textlib or g.text\n\n    assert key in textlib\n    text = textlib[key]\n    percent_fmt = textlib.get(key + \"_\")\n\n    if percent_fmt:\n        text = re.sub(r\"\\*\", r\"%s\", text) % percent_fmt\n\n    text = text.replace(\"&amp;&amp;\", \"%s\")\n\n    return \"\\n\" * nb + text + c.w + \"\\n\" * na\n</code></pre>"},{"location":"reference/util/#mps_youtube.util.correct_truncate","title":"<code>correct_truncate(text, max_len)</code>","text":"<p>Truncate a string taking into account East Asian width chars.</p> Source code in <code>mps_youtube\\util.py</code> <pre><code>def correct_truncate(text, max_len):\n    \"\"\" Truncate a string taking into account East Asian width chars.\"\"\"\n    str_len, out = 0, ''\n\n    for c in text:\n        str_len += real_len(c)\n\n        if str_len &lt;= max_len:\n            out += c\n\n        else:\n            break\n\n    return out\n</code></pre>"},{"location":"reference/util/#mps_youtube.util.dbg","title":"<code>dbg(*args)</code>","text":"<p>Emit a debug message.</p> Source code in <code>mps_youtube\\util.py</code> <pre><code>def dbg(*args):\n    \"\"\"Emit a debug message.\"\"\"\n    # Uses xenc to deal with UnicodeEncodeError when writing to terminal\n    logging.debug(*(xenc(i) for i in args))\n</code></pre>"},{"location":"reference/util/#mps_youtube.util.fmt_time","title":"<code>fmt_time(seconds)</code>","text":"<p>Format number of seconds to %H:%M:%S. </p> Source code in <code>mps_youtube\\util.py</code> <pre><code>def fmt_time(seconds):\n    \"\"\" Format number of seconds to %H:%M:%S. \"\"\"\n    hms = time.strftime('%H:%M:%S', time.gmtime(int(seconds)))\n    H, M, S = hms.split(\":\")\n\n    if H == \"00\":\n        hms = M + \":\" + S\n\n    elif H == \"01\" and int(M) &lt; 40:\n        hms = str(int(M) + 60) + \":\" + S\n\n    elif H.startswith(\"0\"):\n        hms = \":\".join([H[1], M, S])\n\n    return hms\n</code></pre>"},{"location":"reference/util/#mps_youtube.util.get_near_name","title":"<code>get_near_name(begin, items)</code>","text":"<p>Return the closest matching playlist name that starts with begin. </p> Source code in <code>mps_youtube\\util.py</code> <pre><code>def get_near_name(begin, items):\n    \"\"\" Return the closest matching playlist name that starts with begin. \"\"\"\n    for name in sorted(items):\n        if name.lower().startswith(begin.lower()):\n            return name\n    return begin\n</code></pre>"},{"location":"reference/util/#mps_youtube.util.get_pafy","title":"<code>get_pafy(item, force=False, callback=None)</code>","text":"<p>Get pafy object for an item.</p> <p>:param item: video to retrieve :type item: :class:<code>mps_youtube.playlist.Video</code> or str :param force: ignore cache and retrieve anyway :type force: bool :param callback: callpack to pass to pafy :type callback: func :rtype: Pafy</p> Source code in <code>mps_youtube\\util.py</code> <pre><code>def get_pafy(item, force=False, callback=None):\n    \"\"\"\n    Get pafy object for an item.\n\n    :param item: video to retrieve\n    :type item: :class:`mps_youtube.playlist.Video` or str\n    :param force: ignore cache and retrieve anyway\n    :type force: bool\n    :param callback: callpack to pass to pafy\n    :type callback: func\n    :rtype: Pafy\n    \"\"\"\n\n    if isinstance(item, Video):\n        ytid = item.ytid\n    else:\n        ytid = item\n    callback_fn = callback or (lambda x: None)\n    cached = g.pafs.get(ytid)\n\n    if not force and cached and cached.expiry &gt; time.time():\n        dbg(\"get pafy cache hit for %s\", cached.title)\n        cached.fresh = False\n        return cached\n\n    else:\n\n        try:\n            p = None#pafy.new(ytid, callback=callback_fn)\n\n        except IOError as e:\n\n            if \"pafy\" in str(e):\n                dbg(c.p + \"retrying failed pafy get: \" + ytid + c.w)\n                p = None#pafy.new(ytid, callback=callback)\n\n            else:\n                raise\n\n        g.pafs[ytid] = p\n        p.fresh = True\n        thread = \"preload: \" if not callback else \"\"\n        dbg(\"%s%sgot new pafy object: %s%s\" % (c.y, thread, p.title[:26], c.w))\n        dbg(\"%s%sgot new pafy object: %s%s\" % (c.y, thread, p.videoid, c.w))\n        return p\n</code></pre>"},{"location":"reference/util/#mps_youtube.util.getxy","title":"<code>getxy()</code>","text":"<p>Get terminal size, terminal width and max-results.</p> <p>:rtype: :class:<code>XYTuple</code></p> Source code in <code>mps_youtube\\util.py</code> <pre><code>def getxy():\n    \"\"\"\n    Get terminal size, terminal width and max-results.\n\n    :rtype: :class:`XYTuple`\n    \"\"\"\n    # Import here to avoid circular dependency\n    from . import config\n    if g.detectable_size:\n        x, y = terminalsize.get_terminal_size()\n        max_results = y - 4 if y &lt; 54 else 50\n        max_results = 1 if y &lt;= 5 else max_results\n\n    else:\n        x, max_results = config.CONSOLE_WIDTH.get, config.MAX_RESULTS.get\n        y = max_results + 4\n\n    return XYTuple(x, y, max_results)\n</code></pre>"},{"location":"reference/util/#mps_youtube.util.has_exefile","title":"<code>has_exefile(filename)</code>","text":"<p>Check whether file exists in path and is executable.</p> <p>:param filename: name of executable :type filename: str :returns: Path to file or False if not found :rtype: str or False</p> Source code in <code>mps_youtube\\util.py</code> <pre><code>def has_exefile(filename):\n    \"\"\" Check whether file exists in path and is executable.\n\n    :param filename: name of executable\n    :type filename: str\n    :returns: Path to file or False if not found\n    :rtype: str or False\n    \"\"\"\n    paths = [os.getcwd()] + os.environ.get(\"PATH\", '').split(os.pathsep)\n    paths = [i for i in paths if i]\n    dbg(\"searching path for %s\", filename)\n\n    for path in paths:\n        exepath = os.path.join(path, filename)\n\n        if os.path.isfile(exepath):\n            if os.access(exepath, os.X_OK):\n                dbg(\"found at %s\", exepath)\n                return exepath\n\n    return False\n</code></pre>"},{"location":"reference/util/#mps_youtube.util.is_known_player","title":"<code>is_known_player(player)</code>","text":"<p>Return true if the set player is known. </p> Source code in <code>mps_youtube\\util.py</code> <pre><code>def is_known_player(player):\n    \"\"\" Return true if the set player is known. \"\"\"\n    for allowed_player in g.playerargs_defaults:\n        regex = r'(?:\\b%s($|\\.[a-zA-Z0-9]+$))' % re.escape(allowed_player)\n        match = re.search(regex, player)\n\n        if mswin:\n            match = re.search(regex, player, re.IGNORECASE)\n\n        if match:\n            return allowed_player\n\n    return None\n</code></pre>"},{"location":"reference/util/#mps_youtube.util.list_update","title":"<code>list_update(item, lst, remove=False)</code>","text":"<p>Add or remove item from list, checking first to avoid exceptions. </p> Source code in <code>mps_youtube\\util.py</code> <pre><code>def list_update(item, lst, remove=False):\n    \"\"\" Add or remove item from list, checking first to avoid exceptions. \"\"\"\n    if not remove and item not in lst:\n        lst.append(item)\n\n    elif remove and item in lst:\n        lst.remove(item)\n</code></pre>"},{"location":"reference/util/#mps_youtube.util.mswinfn","title":"<code>mswinfn(filename)</code>","text":"<p>Fix filename for Windows. </p> Source code in <code>mps_youtube\\util.py</code> <pre><code>def mswinfn(filename):\n    \"\"\" Fix filename for Windows. \"\"\"\n    if mswin:\n        filename = utf8_replace(filename) if not_utf8_environment else filename\n        allowed = re.compile(r'[^\\\\/?*$\\'\"%&amp;:&lt;&gt;|]')\n        filename = \"\".join(x if allowed.match(x) else \"_\" for x in filename)\n\n    return filename\n</code></pre>"},{"location":"reference/util/#mps_youtube.util.number_string_to_list","title":"<code>number_string_to_list(text)</code>","text":"<p>Parses comma separated lists </p> Source code in <code>mps_youtube\\util.py</code> <pre><code>def number_string_to_list(text):\n    \"\"\" Parses comma separated lists \"\"\"\n    text = [x.strip() for x in text.split(\",\")]\n    vals = []\n    for line in text:\n        k = line\n        if \"-\" in line:\n            separated = [int(x.strip()) for x in k.split(\"-\")]\n            for number in list(range(separated[0]-1, separated[1])):\n                vals.append(number)\n        else:\n            vals.append(k)\n\n    return [int(x) - 1 for x in vals]\n</code></pre>"},{"location":"reference/util/#mps_youtube.util.parse_multi","title":"<code>parse_multi(choice, end=None)</code>","text":"<p>Handle ranges like 5-9, 9-5, 5- and -5 with optional repetitions number [n]</p> <p>eg. 2-4[2] is the same as 2 3 4 2 3 4 and 3[4] is 3 3 3 3</p> <p>Return list of ints.</p> Source code in <code>mps_youtube\\util.py</code> <pre><code>def parse_multi(choice, end=None):\n    \"\"\"\n    Handle ranges like 5-9, 9-5, 5- and -5 with optional repetitions number [n]\n\n    eg. 2-4[2] is the same as 2 3 4 2 3 4 and 3[4] is 3 3 3 3\n\n    Return list of ints.\n\n    \"\"\"\n    end = end or str(len(g.model))\n    pattern = r'(?&lt;![-\\d\\[\\]])(\\d+-\\d+|-\\d+|\\d+-|\\d+)(?:\\[(\\d+)\\])?(?![-\\d\\[\\]])'\n    items = re.findall(pattern, choice)\n    alltracks = []\n\n    for x, nreps in items:\n        # nreps is in the inclusive range [1,100]\n        nreps = min(int(nreps), 100) if nreps else 1\n        for _ in range(nreps):\n\n            if x.startswith(\"-\"):\n                x = \"1\" + x\n\n            elif x.endswith(\"-\"):\n                x = x + str(end)\n\n            if \"-\" in x:\n                nrange = x.split(\"-\")\n                startend = map(int, nrange)\n                alltracks += _bi_range(*startend)\n\n            else:\n                alltracks.append(int(x))\n\n    return alltracks\n</code></pre>"},{"location":"reference/util/#mps_youtube.util.parse_video_length","title":"<code>parse_video_length(duration)</code>","text":"<p>Converts HH:MM:SS to a single integer .i.e. total number of seconds</p> Source code in <code>mps_youtube\\util.py</code> <pre><code>def parse_video_length(duration):\n    '''\n    Converts HH:MM:SS to a single integer .i.e. total number of seconds\n    '''\n    if duration:\n        duration_tokens = duration.split(\":\")\n        if len(duration_tokens) == 2:\n            return int(duration_tokens[0]) * 60 + int(duration_tokens[1])\n        else:\n            return int(duration_tokens[0]) * 3600 + int(duration_tokens[1]) * 60 + int(duration_tokens[2])\n    else:\n        return 10\n</code></pre>"},{"location":"reference/util/#mps_youtube.util.real_len","title":"<code>real_len(u, alt=False)</code>","text":"<p>Try to determine width of strings displayed with monospace font. </p> Source code in <code>mps_youtube\\util.py</code> <pre><code>def real_len(u, alt=False):\n    \"\"\" Try to determine width of strings displayed with monospace font. \"\"\"\n    if not isinstance(u, str):\n        u = u.decode(\"utf8\")\n\n    u = xenc(u) # Handle replacements of unsuported characters\n\n    ueaw = unicodedata.east_asian_width\n\n    if alt:\n        # widths = dict(W=2, F=2, A=1, N=0.75, H=0.5)  # original\n        widths = dict(N=.75, Na=1, W=2, F=2, A=1)\n\n    else:\n        widths = dict(W=2, F=2, A=1, N=1, H=0.5)\n\n    return int(round(sum(widths.get(ueaw(char), 1) for char in u)))\n</code></pre>"},{"location":"reference/util/#mps_youtube.util.sanitize_filename","title":"<code>sanitize_filename(filename, ignore_slashes=False)</code>","text":"<p>Sanitize filename </p> Source code in <code>mps_youtube\\util.py</code> <pre><code>def sanitize_filename(filename, ignore_slashes=False):\n    \"\"\" Sanitize filename \"\"\"\n    if not ignore_slashes:\n        filename = filename.replace('/', '-')\n    if macos:\n        filename = filename.replace(':', '_')\n    if mswin:\n        filename = utf8_replace(filename) if not_utf8_environment else filename\n        allowed = re.compile(r'[^\\\\?*$\\'\"%&amp;:&lt;&gt;|]')\n        filename = \"\".join(x if allowed.match(x) else \"_\" for x in filename)\n\n    return filename\n</code></pre>"},{"location":"reference/util/#mps_youtube.util.set_window_title","title":"<code>set_window_title(title)</code>","text":"<p>Set terminal window title. </p> Source code in <code>mps_youtube\\util.py</code> <pre><code>def set_window_title(title):\n    \"\"\" Set terminal window title. \"\"\"\n    if mswin:\n        ctypes.windll.kernel32.SetConsoleTitleW(xenc(title))\n    else:\n        sys.stdout.write(xenc('\\x1b]2;' + title + '\\x07'))\n</code></pre>"},{"location":"reference/util/#mps_youtube.util.uea_pad","title":"<code>uea_pad(num, t, direction='&lt;', notrunc=False)</code>","text":"<p>Right pad with spaces taking into account East Asian width chars. </p> Source code in <code>mps_youtube\\util.py</code> <pre><code>def uea_pad(num, t, direction=\"&lt;\", notrunc=False):\n    \"\"\" Right pad with spaces taking into account East Asian width chars. \"\"\"\n    direction = direction.strip() or \"&lt;\"\n\n    t = ' '.join(str(t).split('\\n'))\n\n    # TODO: Find better way of dealing with this?\n    if num &lt;= 0:\n        return ''\n\n    if not notrunc:\n        # Truncate to max of num characters\n        t = correct_truncate(t, num)\n\n    if real_len(t) &lt; num:\n        spaces = num - real_len(t)\n\n        if direction == \"&lt;\":\n            t = t + (\" \" * spaces)\n\n        elif direction == \"&gt;\":\n            t = (\" \" * spaces) + t\n\n        elif direction == \"^\":\n            right = False\n\n            while real_len(t) &lt; num:\n                t = t + \" \" if right else \" \" + t\n                right = not right\n\n    return t\n</code></pre>"},{"location":"reference/util/#mps_youtube.util.utf8_replace","title":"<code>utf8_replace(txt)</code>","text":"<p>Replace unsupported characters in unicode string.</p> <p>:param txt: text to filter :type txt: str :returns: Unicode text without any characters unsupported by locale :rtype: str</p> Source code in <code>mps_youtube\\util.py</code> <pre><code>def utf8_replace(txt):\n    \"\"\"\n    Replace unsupported characters in unicode string.\n\n    :param txt: text to filter\n    :type txt: str\n    :returns: Unicode text without any characters unsupported by locale\n    :rtype: str\n    \"\"\"\n    sse = sys.stdout.encoding\n    txt = str(txt)\n    txt = txt.encode(sse, \"replace\").decode(sse)\n    return txt\n</code></pre>"},{"location":"reference/util/#mps_youtube.util.xenc","title":"<code>xenc(stuff)</code>","text":"<p>Replace unsupported characters. </p> Source code in <code>mps_youtube\\util.py</code> <pre><code>def xenc(stuff):\n    \"\"\" Replace unsupported characters. \"\"\"\n    return utf8_replace(stuff) if not_utf8_environment else stuff\n</code></pre>"},{"location":"reference/util/#mps_youtube.util.xprint","title":"<code>xprint(stuff, end=None)</code>","text":"<p>Compatible print. </p> Source code in <code>mps_youtube\\util.py</code> <pre><code>def xprint(stuff, end=None):\n    \"\"\" Compatible print. \"\"\"\n    print(xenc(stuff), end=end)\n</code></pre>"},{"location":"reference/util/#mps_youtube.util.yt_datetime","title":"<code>yt_datetime(yt_date_time)</code>","text":"<p>Return a time object, locale formated date string and locale formatted time string. </p> Source code in <code>mps_youtube\\util.py</code> <pre><code>def yt_datetime(yt_date_time):\n    \"\"\" Return a time object, locale formated date string and locale formatted time string. \"\"\"\n    if yt_date_time is None:\n        return ['Unknown', 'Unknown', 'Unknown']\n    time_obj = time.strptime(yt_date_time, \"%Y-%m-%dT%H:%M:%SZ\")\n    locale_date = time.strftime(\"%x\", time_obj)\n    locale_time = time.strftime(\"%X\", time_obj)\n    # strip first two digits of four digit year\n    short_date = re.sub(r\"(\\d\\d\\D\\d\\d\\D)20(\\d\\d)$\", r\"\\1\\2\", locale_date)\n    return time_obj, short_date, locale_time\n</code></pre>"},{"location":"reference/util/#mps_youtube.util.yt_datetime_local","title":"<code>yt_datetime_local(yt_date_time)</code>","text":"<p>Return a datetime object, locale converted and formated date string and locale converted and formatted time string. </p> Source code in <code>mps_youtube\\util.py</code> <pre><code>def yt_datetime_local(yt_date_time):\n    \"\"\" Return a datetime object, locale converted and formated date string and locale converted and formatted time string. \"\"\"\n    datetime_obj = datetime.strptime(yt_date_time, \"%Y-%m-%dT%H:%M:%SZ\")\n    datetime_obj = utc2local(datetime_obj)\n    locale_date = datetime_obj.strftime(\"%x\")\n    locale_time = datetime_obj.strftime(\"%X\")\n    # strip first two digits of four digit year\n    short_date = re.sub(r\"(\\d\\d\\D\\d\\d\\D)20(\\d\\d)$\", r\"\\1\\2\", locale_date)\n    return datetime_obj, short_date, locale_time\n</code></pre>"},{"location":"reference/commands/__init__/","title":"init","text":""},{"location":"reference/commands/__init__/#mps_youtube.commands.__init__.Command","title":"<code> Command            (tuple)         </code>","text":"<p>Command(regex, category, usage, function)</p>"},{"location":"reference/commands/__init__/#mps_youtube.commands.__init__.Command.__getnewargs__","title":"<code>__getnewargs__(self)</code>  <code>special</code>","text":"<p>Return self as a plain tuple.  Used by copy and pickle.</p> Source code in <code>mps_youtube\\commands\\__init__.py</code> <pre><code>def __getnewargs__(self):\n    'Return self as a plain tuple.  Used by copy and pickle.'\n    return _tuple(self)\n</code></pre>"},{"location":"reference/commands/__init__/#mps_youtube.commands.__init__.Command.__new__","title":"<code>__new__(_cls, regex, category, usage, function)</code>  <code>special</code> <code>staticmethod</code>","text":"<p>Create new instance of Command(regex, category, usage, function)</p>"},{"location":"reference/commands/__init__/#mps_youtube.commands.__init__.Command.__replace__","title":"<code>__replace__(/, self, **kwds)</code>  <code>special</code>","text":"<p>Return a new Command object replacing specified fields with new values</p> Source code in <code>mps_youtube\\commands\\__init__.py</code> <pre><code>def _replace(self, /, **kwds):\n    result = self._make(_map(kwds.pop, field_names, self))\n    if kwds:\n        raise TypeError(f'Got unexpected field names: {list(kwds)!r}')\n    return result\n</code></pre>"},{"location":"reference/commands/__init__/#mps_youtube.commands.__init__.Command.__repr__","title":"<code>__repr__(self)</code>  <code>special</code>","text":"<p>Return a nicely formatted representation string</p> Source code in <code>mps_youtube\\commands\\__init__.py</code> <pre><code>def __repr__(self):\n    'Return a nicely formatted representation string'\n    return self.__class__.__name__ + repr_fmt % self\n</code></pre>"},{"location":"reference/commands/__init__/#mps_youtube.commands.__init__.command","title":"<code>command(regex, *commands)</code>","text":"<p>Decorator to register an mps-youtube command. </p> Source code in <code>mps_youtube\\commands\\__init__.py</code> <pre><code>def command(regex, *commands):\n    \"\"\" Decorator to register an mps-youtube command. \"\"\"\n    for command in commands:\n        completer.add_cmd(command)\n    def decorator(function):\n        cmd = Command(re.compile(regex), None, None, function)\n        g.commands.append(cmd)\n        return function\n    return decorator\n</code></pre>"},{"location":"reference/commands/album_search/","title":"album_search.py","text":""},{"location":"reference/commands/album_search/#mps_youtube.commands.album_search.search_album","title":"<code>search_album(term)</code>","text":"<p>Search for albums. </p> Source code in <code>mps_youtube\\commands\\album_search.py</code> <pre><code>@command(r'album\\s*(.{0,500})', 'album')\ndef search_album(term):\n    \"\"\"Search for albums. \"\"\"\n    # pylint: disable=R0914,R0912\n    if not term:\n        show_message(\"Enter album name:\", c.g, update=True)\n        term = input(\"&gt; \")\n\n        if not term or len(term) &lt; 2:\n            g.message = c.r + \"Not enough input!\" + c.w\n            g.content = content_py.generate_songlist_display()\n            return\n\n    album = _get_mb_album(term)\n\n    if not album:\n        show_message(\"Album '%s' not found!\" % term)\n        return\n\n    prompt = \"Artist? [%s] &gt; \" % album['artist']\n    util.xprint(prompt, end=\"\")\n    artistentry = input().strip()\n\n    if artistentry:\n\n        if artistentry == \"q\":\n            show_message(\"Album search abandoned!\")\n            return\n\n        album = _get_mb_album(term, artist=artistentry)\n\n        if not album:\n            show_message(\"Album '%s' by '%s' not found!\" % (term, artistentry))\n            return\n\n    title, artist = album['title'], album['artist']\n    mb_tracks = _get_mb_tracks(album['aid'])\n\n    if not mb_tracks:\n        show_message(\"Album '%s' by '%s' has 0 tracks!\" % (title, artist))\n        return\n\n    msg = \"%s%s%s by %s%s%s\\n\\n\" % (c.g, title, c.w, c.g, artist, c.w)\n    msg += \"Enter to begin matching or [q] to abort\"\n    g.message = msg\n    g.content = \"Tracks:\\n\"\n    for n, track in enumerate(mb_tracks, 1):\n        g.content += \"%02s  %s\" % (n, track['title'])\n        g.content += \"\\n\"\n\n    screen.update()\n    entry = input(\"Continue? [Enter] &gt; \")\n\n    if entry == \"\":\n        pass\n\n    else:\n        show_message(\"Album search abandoned!\")\n        return\n\n    songs = []\n    screen.clear()\n    itt = _match_tracks(artist, title, mb_tracks)\n\n    stash = config.SEARCH_MUSIC.get, config.ORDER.get\n    config.SEARCH_MUSIC.value = True\n    config.ORDER.value = \"relevance\"\n\n    try:\n        songs.extend(itt)\n\n    except KeyboardInterrupt:\n        util.xprint(\"%sHalted!%s\" % (c.r, c.w))\n\n    finally:\n        config.SEARCH_MUSIC.value, config.ORDER.value = stash\n\n    if songs:\n        util.xprint(\"\\n%s / %s songs matched\" % (len(songs), len(mb_tracks)))\n        input(\"Press Enter to continue\")\n        if g.lastfm_network:\n            g.artist = artist\n            g.album = title\n            g.scrobble = True\n            # Fill up queue with all the track names\n            g.scrobble_queue = [t['title'] for t in mb_tracks]\n\n    msg = \"Contents of album %s%s - %s%s %s(%d/%d)%s:\" % (\n        c.y, artist, title, c.w, c.b, len(songs), len(mb_tracks), c.w)\n    failmsg = \"Found no album tracks for %s%s%s\" % (c.y, title, c.w)\n\n    paginatesongs(songs, msg=msg, failmsg=failmsg)\n</code></pre>"},{"location":"reference/commands/album_search/#mps_youtube.commands.album_search.show_message","title":"<code>show_message(message, col='', update=False)</code>","text":"<p>Show message using col, update screen if required. </p> Source code in <code>mps_youtube\\commands\\album_search.py</code> <pre><code>def show_message(message, col=c.r, update=False):\n    \"\"\" Show message using col, update screen if required. \"\"\"\n    g.content = content_py.generate_songlist_display()\n    g.message = col + message + c.w\n\n    if update:\n        screen.update()\n</code></pre>"},{"location":"reference/commands/config/","title":"config.py","text":""},{"location":"reference/commands/config/#mps_youtube.commands.config.setconfig","title":"<code>setconfig(key, val, is_temp=False)</code>","text":"<p>Set configuration variable. </p> Source code in <code>mps_youtube\\commands\\config.py</code> <pre><code>@command(r'set\\s+([-\\w]+)\\s*(.*)')\ndef setconfig(key, val, is_temp=False):\n    \"\"\" Set configuration variable. \"\"\"\n    key = key.replace(\"-\", \"_\")\n    if key.upper() == \"ALL\" and val.upper() == \"DEFAULT\":\n\n        for ci in config:\n            config[ci].value = config[ci].default\n\n        config.save()\n        message = \"Default configuration reinstated\"\n\n    elif not key.upper() in config:\n        message = \"Unknown config item: %s%s%s\" % (c.r, key, c.w)\n\n    elif val.upper() == \"DEFAULT\":\n        att = config[key.upper()]\n        att.value = att.default\n        att.temp_value = None\n        message = \"%s%s%s set to %s%s%s (default)\"\n        dispval = att.display or \"None\"\n        message = message % (c.y, key, c.w, c.y, dispval, c.w)\n        config.save()\n\n    else:\n        # config.save() will be called by config.set() method\n        message = config[key.upper()].set(val, is_temp=is_temp)\n\n    showconfig()\n    g.message = message\n</code></pre>"},{"location":"reference/commands/config/#mps_youtube.commands.config.show_encs","title":"<code>show_encs()</code>","text":"<p>Display available encoding presets. </p> Source code in <code>mps_youtube\\commands\\config.py</code> <pre><code>@command(r'encoders?', 'encoder')\ndef show_encs():\n    \"\"\" Display available encoding presets. \"\"\"\n    out = \"%sEncoding profiles:%s\\n\\n\" % (c.ul, c.w)\n\n    for x, e in enumerate(g.encoders):\n        sel = \" (%sselected%s)\" % (c.y, c.w) if config.ENCODER.get == x else \"\"\n        out += \"%2d. %s%s\\n\" % (x, e['name'], sel)\n\n    g.content = out\n    message = \"Enter %sset encoder &lt;num&gt;%s to select an encoder\"\n    g.message = message % (c.g, c.w)\n</code></pre>"},{"location":"reference/commands/config/#mps_youtube.commands.config.showconfig","title":"<code>showconfig()</code>","text":"<p>Dump config data. </p> Source code in <code>mps_youtube\\commands\\config.py</code> <pre><code>@command(r'set|showconfig', 'set', 'showconfig')\ndef showconfig():\n    \"\"\" Dump config data. \"\"\"\n    width = util.getxy().width\n    longest_key = 17\n    longest_val = 0\n    has_temps = False\n\n    for setting in config:\n        val = config[setting]\n        longest_val = max(longest_val, len(str(val.display)))\n        has_temps = has_temps or val.temp_value is not None\n\n    width -= 27\n    s = \"  %s%-{0}s%s : %-{1}s\".format(longest_key, longest_val+1)\n\n    if has_temps:\n        width -= longest_val + 5\n        out = \"  %s%-{}s   %-{}s %s%s%s\\n\".format(longest_key, longest_val) % (\n            c.ul, \"Key\", \"Value\", \"Temporary\", \" \" * width, c.w)\n    else:\n        out = \"  %s%-{}s   %s%s%s\\n\".format(longest_key) % (c.ul, \"Key\", \"Value\", \" \" * width, c.w)\n\n    for setting in config:\n        val = config[setting]\n\n        # don't show player specific settings if unknown player\n        if not util.is_known_player(config.PLAYER.get) and \\\n                val.require_known_player:\n            continue\n\n        # don't show max_results if auto determined\n        if g.detectable_size and setting == \"MAX_RESULTS\":\n            continue\n\n        if g.detectable_size and setting == \"CONSOLE_WIDTH\":\n            continue\n\n        out += s % (c.g, setting.lower(), c.w, val.display)\n\n        if has_temps:\n            out += \"%s%s\" % (c.w, val.display_temp)\n\n        out += \"\\n\"\n\n    g.content = out\n    g.message = \"Enter %sset &lt;key&gt; &lt;value&gt;%s to change\\n\" % (c.g, c.w)\n    g.message += \"Enter %sset all default%s to reset all\" % (c.g, c.w)\n</code></pre>"},{"location":"reference/commands/download/","title":"download.py","text":""},{"location":"reference/commands/download/#mps_youtube.commands.download.da_url","title":"<code>da_url(url)</code>","text":"<p>Open and prompt for download of youtube best audio from url. </p> Source code in <code>mps_youtube\\commands\\download.py</code> <pre><code>@command(r'daurl\\s(.*[-_a-zA-Z0-9]{11}.*)', 'daurl')\ndef da_url(url):\n    \"\"\" Open and prompt for download of youtube best audio from url. \"\"\"\n    g.browse_mode = \"normal\"\n    yt_url(url)\n\n    if len(g.model) == 1:\n        download(\"da\", \"1\")\n\n    if g.command_line:\n        sys.exit()\n</code></pre>"},{"location":"reference/commands/download/#mps_youtube.commands.download.dl_url","title":"<code>dl_url(url)</code>","text":"<p>Open and prompt for download of youtube video url. </p> Source code in <code>mps_youtube\\commands\\download.py</code> <pre><code>@command(r'dlurl\\s(.*[-_a-zA-Z0-9]{11}.*)', 'dlurl')\ndef dl_url(url):\n    \"\"\" Open and prompt for download of youtube video url. \"\"\"\n    g.browse_mode = \"normal\"\n    yt_url(url)\n\n    if len(g.model) == 1:\n        download(\"download\", \"1\")\n\n    if g.command_line:\n        sys.exit()\n</code></pre>"},{"location":"reference/commands/download/#mps_youtube.commands.download.down_many","title":"<code>down_many(dltype, choice, subdir=None)</code>","text":"<p>Download multiple items. </p> Source code in <code>mps_youtube\\commands\\download.py</code> <pre><code>@command(r'(da|dv)\\s+((?:\\d+\\s\\d+|-\\d+|\\d+-|\\d+,)(?:[\\d\\s,-]*))', 'da', 'dv')\ndef down_many(dltype, choice, subdir=None):\n    \"\"\" Download multiple items. \"\"\"\n    choice = util.parse_multi(choice)\n    choice = list(set(choice))\n    downsongs = [g.model[int(x) - 1] for x in choice]\n    temp = g.model[::]\n    g.model.songs = downsongs[::]\n    count = len(downsongs)\n    av = \"audio\" if dltype.startswith(\"da\") else \"video\"\n    msg = \"\"\n\n    def handle_error(message):\n        \"\"\" Handle error in download. \"\"\"\n        g.message = message\n        g.content = disp\n        screen.update()\n        time.sleep(2)\n        g.model.songs.pop(0)\n\n    try:\n        for song in downsongs:\n            g.result_count = len(g.model)\n            disp = content.generate_songlist_display()\n            title = \"Download Queue (%s):%s\\n\\n\" % (av, c.w)\n            disp = re.sub(r\"(Num\\s*?Title.*?\\n)\", title, disp)\n            g.content = disp\n            screen.update()\n\n            try:\n                filename = _make_fname(song, None, av=av, subdir=subdir)\n\n            except IOError as e:\n                handle_error(\"Error for %s: %s\" % (song.title, str(e)))\n                count -= 1\n                continue\n\n            except KeyError:\n                handle_error(\"No audio track for %s\" % song.title)\n                count -= 1\n                continue\n\n            try:\n                _download(song, filename, url=None, audio=av == \"audio\")\n\n            except HTTPError:\n                handle_error(\"HTTP Error for %s\" % song.title)\n                count -= 1\n                continue\n\n            g.model.songs.pop(0)\n            msg = \"Downloaded %s items\" % count\n            g.message = \"Saved to \" + c.g + song.title + c.w\n\n    except KeyboardInterrupt:\n        msg = \"Downloads interrupted!\"\n\n    finally:\n        g.model.songs = temp[::]\n        g.message = msg\n        g.result_count = len(g.model)\n        g.content = content.generate_songlist_display()\n</code></pre>"},{"location":"reference/commands/download/#mps_youtube.commands.download.down_plist","title":"<code>down_plist(dltype, parturl)</code>","text":"<p>Download YouTube playlist. </p> Source code in <code>mps_youtube\\commands\\download.py</code> <pre><code>@command(r'(da|dv)pl\\s+%s' % PL, 'dapl', 'dvpl')\ndef down_plist(dltype, parturl):\n    \"\"\" Download YouTube playlist. \"\"\"\n\n    plist(parturl)\n    dump(False)\n    title = g.pafy_pls[parturl][0].title\n    # Remove double quotes for convenience\n    subdir = util.sanitize_filename(title.replace('\"', ''))\n    down_many(dltype, \"1-\", subdir=subdir)\n    msg = g.message\n    plist(parturl)\n    g.message = msg\n</code></pre>"},{"location":"reference/commands/download/#mps_youtube.commands.download.down_user_pls","title":"<code>down_user_pls(dltype, user)</code>","text":"<p>Download all user playlists. </p> Source code in <code>mps_youtube\\commands\\download.py</code> <pre><code>@command(r'(da|dv)upl\\s+(.*)', 'daupl', 'dvupl')\ndef down_user_pls(dltype, user):\n    \"\"\" Download all user playlists. \"\"\"\n    user_pls(user)\n    for i in g.ytpls:\n        down_plist(dltype, i.get('link'))\n\n    return\n</code></pre>"},{"location":"reference/commands/download/#mps_youtube.commands.download.download","title":"<code>download(dltype, num)</code>","text":"<p>Download a track or playlist by menu item number. </p> Source code in <code>mps_youtube\\commands\\download.py</code> <pre><code>@command(r'(dv|da|d|dl|download)\\s*(\\d{1,4})', 'da', 'dv', 'd', 'dl', 'download')\ndef download(dltype, num):\n    \"\"\" Download a track or playlist by menu item number. \"\"\"\n    # This function needs refactoring!\n    # pylint: disable=R0912\n    # pylint: disable=R0914\n    if g.browse_mode == \"ytpl\" and dltype in (\"da\", \"dv\"):\n        plid = g.ytpls[int(num) - 1][\"link\"]\n        down_plist(dltype, plid)\n        return\n\n    elif g.browse_mode == \"ytpl\":\n        g.message = \"Use da or dv to specify audio / video playlist download\"\n        g.message = c.y + g.message + c.w\n        g.content = content.generate_songlist_display()\n        return\n\n    elif g.browse_mode != \"normal\":\n        g.message = \"Download must refer to a specific video item\"\n        g.message = c.y + g.message + c.w\n        g.content = content.generate_songlist_display()\n        return\n\n    screen.writestatus(\"Fetching video info...\")\n    song = (g.model[int(num) - 1])\n\n    # best = dltype.startswith(\"dv\") or dltype.startswith(\"da\")\n    #\n    # if not best:\n    #\n    #     try:\n    #         # user prompt for download stream\n    #         url, ext, url_au, ext_au = prompt_dl(song)\n    #\n    #     except KeyboardInterrupt:\n    #         g.message = c.r + \"Download aborted!\" + c.w\n    #         g.content = content.generate_songlist_display()\n    #         return\n    #\n    #     if not url or ext_au == \"abort\":\n    #         # abort on invalid stream selection\n    #         g.content = content.generate_songlist_display()\n    #         g.message = \"%sNo download selected / invalid input%s\" % (c.y, c.w)\n    #         return\n    #\n    #     else:\n    #         # download user selected stream(s)\n    #         filename = _make_fname(song, ext)\n    #         args = (song, filename, url)\n    #\n    #         if url_au and ext_au:\n    #             # downloading video and audio stream for muxing\n    #             audio = False\n    #             filename_au = _make_fname(song, ext_au)\n    #             args_au = (song, filename_au, url_au)\n    #\n    #         else:\n    #             audio = ext in (\"m4a\", \"ogg\")\n    #\n    #         kwargs = dict(audio=audio)\n    #\n    # elif best:\n    #     # set updownload without prompt\n    #     url_au = None\n    #     av = \"audio\" if dltype.startswith(\"da\") else \"video\"\n    #     audio = av == \"audio\"\n    #     filename = _make_fname(song, None, av=av)\n    #     args = (song, filename)\n    #     kwargs = dict(url=None, audio=audio)\n\n    try:\n        # perform download(s)\n        # dl_filenames = [args[1]]\n        # f = _download(*args, **kwargs)\n        success = pafy.download_video(song.ytid, config.DDIR.get, True if dltype.startswith(\"da\") else False)\n        if success:\n            g.message = \"Saved \\'\" + song.title + \"\\' to \" + c.g + config.DDIR.get + c.w\n\n        # if url_au:\n        #     dl_filenames += [args_au[1]]\n        #     _download(*args_au, allow_transcode=False, **kwargs)\n\n    except KeyboardInterrupt:\n        g.message = c.r + \"Download halted!\" + c.w\n\n        # try:\n        #     for downloaded in dl_filenames:\n        #         os.remove(downloaded)\n        #\n        # except IOError:\n        #     pass\n\n    # if url_au:\n    #     # multiplex\n    #     name, ext = os.path.splitext(args[1])\n    #     tmpvideoname = name + '.' +str(random.randint(10000, 99999)) + ext\n    #     os.rename(args[1], tmpvideoname)\n    #     mux_cmd = [g.muxapp, \"-i\", tmpvideoname, \"-i\", args_au[1], \"-c\",\n    #                \"copy\", name + \".mp4\"]\n    #\n    #     try:\n    #         subprocess.call(mux_cmd)\n    #         g.message = \"Saved to :\" + c.g + mux_cmd[7] + c.w\n    #         os.remove(tmpvideoname)\n    #         os.remove(args_au[1])\n    #\n    #     except KeyboardInterrupt:\n    #         g.message = \"Audio/Video multiplex aborted!\"\n\n    g.content = content.generate_songlist_display()\n</code></pre>"},{"location":"reference/commands/download/#mps_youtube.commands.download.external_download","title":"<code>external_download(song, filename, url)</code>","text":"<p>Perform download using external application. </p> Source code in <code>mps_youtube\\commands\\download.py</code> <pre><code>def external_download(song, filename, url):\n    \"\"\" Perform download using external application. \"\"\"\n    cmd = config.DOWNLOAD_COMMAND.get\n    ddir, basename = config.DDIR.get, os.path.basename(filename)\n    cmd_list = shlex.split(cmd)\n\n    def list_string_sub(orig, repl, lst):\n        \"\"\" Replace substrings for items in a list. \"\"\"\n        return [x if orig not in x else x.replace(orig, repl) for x in lst]\n\n    cmd_list = list_string_sub(\"%F\", filename, cmd_list)\n    cmd_list = list_string_sub(\"%d\", ddir, cmd_list)\n    cmd_list = list_string_sub(\"%f\", basename, cmd_list)\n    cmd_list = list_string_sub(\"%u\", url, cmd_list)\n    cmd_list = list_string_sub(\"%i\", song.ytid, cmd_list)\n    util.dbg(\"Downloading using: %s\", \" \".join(cmd_list))\n    subprocess.call(cmd_list)\n</code></pre>"},{"location":"reference/commands/download/#mps_youtube.commands.download.extract_metadata","title":"<code>extract_metadata(name)</code>","text":"<p>Try to determine metadata from video title. </p> Source code in <code>mps_youtube\\commands\\download.py</code> <pre><code>def extract_metadata(name):\n    \"\"\" Try to determine metadata from video title. \"\"\"\n    seps = name.count(\" - \")\n    artist = title = None\n\n    if seps == 1:\n\n        pos = name.find(\" - \")\n        artist = name[:pos].strip()\n        title = name[pos + 3:].strip()\n\n    else:\n        title = name.strip()\n\n    return dict(artist=artist, title=title)\n</code></pre>"},{"location":"reference/commands/download/#mps_youtube.commands.download.gen_dl_text","title":"<code>gen_dl_text(ddata, song, p)</code>","text":"<p>Generate text for dl screen. </p> Source code in <code>mps_youtube\\commands\\download.py</code> <pre><code>def gen_dl_text(ddata, song, p):\n    \"\"\" Generate text for dl screen. \"\"\"\n    hdr = []\n    hdr.append(\"  %s%s%s\" % (c.r, song.title, c.w))\n    author = p.author\n    hdr.append(c.r + \"  Uploaded by \" + author + c.w)\n    hdr.append(\"  [\" + util.fmt_time(song.length) + \"]\")\n    hdr.append(\"\")\n\n    heading = tuple(\"Item Format Quality Media Size Notes\".split())\n    fmt = \"  {0}%-6s %-8s %-13s %-7s   %-5s   %-16s{1}\"\n    heading = [fmt.format(c.w, c.w) % heading]\n    heading.append(\"\")\n\n    content = []\n\n    for n, d in enumerate(ddata):\n        row = (n + 1, d['ext'], d['quality'], d['mediatype'], d['size'],\n               d['notes'])\n        fmt = \"  {0}%-6s %-8s %-13s %-7s %5s Mb   %-16s{1}\"\n        row = fmt.format(c.g, c.w) % row\n        content.append(row)\n\n    content.append(\"\")\n\n    footer = \"Select [%s1-%s%s] to download or [%sEnter%s] to return\"\n    footer = [footer % (c.y, len(content) - 1, c.w, c.y, c.w)]\n    return(content, hdr, heading, footer)\n</code></pre>"},{"location":"reference/commands/download/#mps_youtube.commands.download.get_dl_data","title":"<code>get_dl_data(song, mediatype='any')</code>","text":"<p>Get filesize and metadata for all streams, return dict. </p> Source code in <code>mps_youtube\\commands\\download.py</code> <pre><code>def get_dl_data(song, mediatype=\"any\"):\n    \"\"\" Get filesize and metadata for all streams, return dict. \"\"\"\n    def mbsize(x):\n        \"\"\" Return size in MB. \"\"\"\n        return str(int(x / (1024 ** 2)))\n\n    p = util.get_pafy(song)\n    dldata = []\n    text = \" [Fetching stream info] &gt;\"\n    streamlist = [x for x in p.allstreams]\n\n    if mediatype == \"audio\":\n        streamlist = [x for x in p.audiostreams]\n\n    l = len(streamlist)\n    for n, stream in enumerate(streamlist):\n        sys.stdout.write(text + \"-\" * n + \"&gt;\" + \" \" * (l - n - 1) + \"&lt;\\r\")\n        sys.stdout.flush()\n\n        try:\n            size = mbsize(stream.get_filesize())\n\n        except TypeError:\n            util.dbg(c.r + \"---Error getting stream size\" + c.w)\n            size = 0\n\n        item = {'mediatype': stream.mediatype,\n                'size': size,\n                'ext': stream.extension,\n                'quality': stream.quality,\n                'notes': stream.notes,\n                'url': stream.url}\n\n        dldata.append(item)\n\n    screen.writestatus(\"\")\n    return dldata, p\n</code></pre>"},{"location":"reference/commands/download/#mps_youtube.commands.download.menu_prompt","title":"<code>menu_prompt(model, prompt=' &gt; ', rows=None, header=None, theading=None, footer=None, force=0)</code>","text":"<p>Generate a list of choice, returns item from model. </p> Source code in <code>mps_youtube\\commands\\download.py</code> <pre><code>def menu_prompt(model, prompt=\" &gt; \", rows=None, header=None, theading=None,\n                footer=None, force=0):\n    \"\"\" Generate a list of choice, returns item from model. \"\"\"\n    content = \"\"\n\n    for x in header, theading, rows, footer:\n        if isinstance(x, list):\n\n            for line in x:\n                content += line + \"\\n\"\n\n        elif isinstance(x, str):\n            content += x + \"\\n\"\n\n    g.content = content\n    screen.update()\n\n    choice = input(prompt)\n\n    if choice in model:\n        return model[choice]\n\n    elif force:\n        return menu_prompt(model, prompt, rows, header, theading, footer,\n                           force)\n\n    elif not choice.strip():\n        return False, False\n\n    else:  # unrecognised input\n        return False, \"abort\"\n</code></pre>"},{"location":"reference/commands/download/#mps_youtube.commands.download.prompt_dl","title":"<code>prompt_dl(song)</code>","text":"<p>Prompt user do choose a stream to dl.  Return (url, extension). </p> Source code in <code>mps_youtube\\commands\\download.py</code> <pre><code>def prompt_dl(song):\n    \"\"\" Prompt user do choose a stream to dl.  Return (url, extension). \"\"\"\n    # pylint: disable=R0914\n    dl_data, p = get_dl_data(song)\n    dl_text = gen_dl_text(dl_data, song, p)\n\n    model = [x['url'] for x in dl_data]\n    ed = enumerate(dl_data)\n    model = {str(n + 1): (x['url'], x['ext']) for n, x in ed}\n    url, ext = menu_prompt(model, \"Download number: \", *dl_text)\n    url2 = ext2 = None\n    mediatype = [i for i in dl_data if i['url'] == url][0]['mediatype']\n\n    if mediatype == \"video\" and g.muxapp and not config.DOWNLOAD_COMMAND.get:\n        # offer mux if not using external downloader\n        dl_data, p = get_dl_data(song, mediatype=\"audio\")\n        dl_text = gen_dl_text(dl_data, song, p)\n        au_choices = \"1\" if len(dl_data) == 1 else \"1-%s\" % len(dl_data)\n        footer = [util.F('-audio') % ext, util.F('select mux') % au_choices]\n        dl_text = tuple(dl_text[0:3]) + (footer,)\n        aext = (\"ogg\", \"m4a\")\n        model = [x['url'] for x in dl_data if x['ext'] in aext]\n        ed = enumerate(dl_data)\n        model = {str(n + 1): (x['url'], x['ext']) for n, x in ed}\n        prompt = \"Audio stream: \"\n        url2, ext2 = menu_prompt(model, prompt, *dl_text)\n\n    return url, ext, url2, ext2\n</code></pre>"},{"location":"reference/commands/download/#mps_youtube.commands.download.remux_audio","title":"<code>remux_audio(filename, title)</code>","text":"<p>Remux audio file. Insert limited metadata tags. </p> Source code in <code>mps_youtube\\commands\\download.py</code> <pre><code>def remux_audio(filename, title):\n    \"\"\" Remux audio file. Insert limited metadata tags. \"\"\"\n    util.dbg(\"starting remux\")\n    temp_file = filename + \".\" + str(random.randint(10000, 99999))\n    os.rename(filename, temp_file)\n    meta = extract_metadata(title)\n    metadata = [\"title=%s\" % meta[\"title\"]]\n\n    if meta[\"artist\"]:\n        metadata = [\"title=%s\" % meta[\"title\"], \"-metadata\",\n                    \"artist=%s\" % meta[\"artist\"]]\n\n    cmd = [g.muxapp, \"-y\", \"-i\", temp_file, \"-acodec\", \"copy\", \"-metadata\"]\n    cmd += metadata + [\"-vn\", filename]\n    util.dbg(cmd)\n\n    try:\n        with open(os.devnull, \"w\") as devnull:\n            subprocess.call(cmd, stdout=devnull, stderr=subprocess.STDOUT)\n\n    except OSError:\n        util.dbg(\"Failed to remux audio using %s\", g.muxapp)\n        os.rename(temp_file, filename)\n\n    else:\n        os.unlink(temp_file)\n        util.dbg(\"remuxed audio file using %s\" % g.muxapp)\n</code></pre>"},{"location":"reference/commands/download/#mps_youtube.commands.download.transcode","title":"<code>transcode(filename, enc_data)</code>","text":"<p>Re encode a download. </p> Source code in <code>mps_youtube\\commands\\download.py</code> <pre><code>def transcode(filename, enc_data):\n    \"\"\" Re encode a download. \"\"\"\n    base = os.path.splitext(filename)[0]\n    exe = g.muxapp if g.transcoder_path == \"auto\" else g.transcoder_path\n\n    # ensure valid executable\n    if not exe or not os.path.exists(exe) or not os.access(exe, os.X_OK):\n        util.xprint(\"Encoding failed. Couldn't find a valid encoder :(\\n\")\n        time.sleep(2)\n        return filename\n\n    command = shlex.split(enc_data['command'])\n    newcom, outfn = command[::], \"\"\n\n    for n, d in enumerate(command):\n\n        if d == \"ENCODER_PATH\":\n            newcom[n] = exe\n\n        elif d == \"IN\":\n            newcom[n] = filename\n\n        elif d == \"OUT\":\n            newcom[n] = outfn = base\n\n        elif d == \"OUT.EXT\":\n            newcom[n] = outfn = base + \".\" + enc_data['ext']\n\n    returncode = subprocess.call(newcom)\n\n    if returncode == 0 and g.delete_orig:\n        os.unlink(filename)\n\n    return outfn\n</code></pre>"},{"location":"reference/commands/generate_playlist/","title":"generate_playlist.py","text":"<p>Playlist Generation</p>"},{"location":"reference/commands/generate_playlist/#mps_youtube.commands.generate_playlist.check_sourcefile","title":"<code>check_sourcefile(filename)</code>","text":"<p>Check if filename exists and has a non-zero size</p> Source code in <code>mps_youtube\\commands\\generate_playlist.py</code> <pre><code>def check_sourcefile(filename):\n    \"\"\"Check if filename exists and has a non-zero size\"\"\"\n    return path.isfile(filename) and path.getsize(filename) &gt; 0\n</code></pre>"},{"location":"reference/commands/generate_playlist/#mps_youtube.commands.generate_playlist.create_playlist","title":"<code>create_playlist(queries, title='')</code>","text":"<p>Add a new playlist</p> <p>Create playlist with a random name, get the first match for each title in queries and append it to the playlist</p> Source code in <code>mps_youtube\\commands\\generate_playlist.py</code> <pre><code>def create_playlist(queries, title=''):\n    \"\"\"Add a new playlist\n\n    Create playlist with a random name, get the first\n    match for each title in queries and append it to the playlist\n    \"\"\"\n    plname = title.replace(\" \", \"-\") or random_plname()\n    if not g.userpl.get(plname):\n        g.userpl[plname] = Playlist(plname)\n    for query in queries:\n        g.message = util.F('mkp finding') % query\n        screen.update()\n        qresult = find_best_match(query)\n        if qresult:\n            g.userpl[plname].songs.append(qresult)\n    if g.userpl[plname]:\n        playlists.save()\n</code></pre>"},{"location":"reference/commands/generate_playlist/#mps_youtube.commands.generate_playlist.description_generator","title":"<code>description_generator(text)</code>","text":"<p>Fetches a videos description and parses it for  -  combinations Source code in <code>mps_youtube\\commands\\generate_playlist.py</code> <pre><code>def description_generator(text):\n    \"\"\" Fetches a videos description and parses it for\n        &lt;artist&gt; - &lt;track&gt; combinations\n    \"\"\"\n    if not isinstance(g.model, Playlist):\n        g.message = util.F(\"mkp desc unknown\")\n        return\n\n    # Use only the first result, for now\n    num = text.replace(\"--description\", \"\")\n    num = num.replace(\"-d\", \"\")\n    num = util.number_string_to_list(num)[0]\n\n    query = {}\n    query['id'] = g.model[num].ytid\n    query['part'] = 'snippet'\n    query['maxResults'] = '1'\n    data = pafy.call_gdata('videos', query)['items'][0]['snippet']\n    title = \"mkp %s\" % data['title']\n    data = util.fetch_songs(data['description'], data['title'])\n\n    columns = [\n        {\"name\": \"idx\", \"size\": 3, \"heading\": \"Num\"},\n        {\"name\": \"artist\", \"size\": 30, \"heading\": \"Artist\"},\n        {\"name\": \"title\", \"size\": \"remaining\", \"heading\": \"Title\"},\n    ]\n\n    def run_m(idx):\n        \"\"\" Create playlist based on the\n            results selected\n        \"\"\"\n        create_playlist(idx, title)\n\n    if data:\n        data = [listview.ListSongtitle(x) for x in data]\n        g.content = listview.ListView(columns, data, run_m)\n        g.message = util.F(\"mkp desc which data\")\n    else:\n        g.message = util.F(\"mkp no valid\")\n\n    return\n</code></pre>"},{"location":"reference/commands/generate_playlist/#mps_youtube.commands.generate_playlist.find_best_match","title":"<code>find_best_match(query)</code>","text":"<p>Find the best(first)</p> Source code in <code>mps_youtube\\commands\\generate_playlist.py</code> <pre><code>def find_best_match(query):\n    \"\"\"Find the best(first)\"\"\"\n    # This assumes that the first match is the best one\n    qs = search.generate_search_qs(query)\n    wdata = pafy.call_gdata('search', qs)\n    results = search.get_tracks_from_json(wdata)\n    if results:\n        res, score = album_search._best_song_match(\n            results, query, 0.1, 1.0, 0.0)\n        return res\n    return None\n</code></pre>"},{"location":"reference/commands/generate_playlist/#mps_youtube.commands.generate_playlist.generate_playlist","title":"<code>generate_playlist(sourcefile)</code>","text":"<p>Generate a playlist from video titles in sourcefile</p> Source code in <code>mps_youtube\\commands\\generate_playlist.py</code> <pre><code>@command(r'mkp\\s*(.{1,100})', 'mkp')\ndef generate_playlist(sourcefile):\n    \"\"\"Generate a playlist from video titles in sourcefile\"\"\"\n\n    # Hooks into this, check if the argument --description is present\n    if \"--description\" in sourcefile or \"-d\" in sourcefile:\n        description_generator(sourcefile)\n        return\n\n    expanded_sourcefile = path.expanduser(sourcefile)\n    if not check_sourcefile(expanded_sourcefile):\n        g.message = util.F('mkp empty') % expanded_sourcefile\n    else:\n        queries = read_sourcefile(expanded_sourcefile)\n        g.message = util.F('mkp parsed') % (len(queries), sourcefile)\n        if queries:\n            create_playlist(queries)\n            g.message = util.F('pl help')\n            g.content = content.playlists_display()\n</code></pre>"},{"location":"reference/commands/generate_playlist/#mps_youtube.commands.generate_playlist.random_plname","title":"<code>random_plname()</code>","text":"<p>Generates a random alphanumeric string of 6 characters</p> Source code in <code>mps_youtube\\commands\\generate_playlist.py</code> <pre><code>def random_plname():\n    \"\"\"Generates a random alphanumeric string of 6 characters\"\"\"\n    n_chars = 6\n    return ''.join(choice(string.ascii_lowercase + string.digits)\n                   for _ in range(n_chars))\n</code></pre>"},{"location":"reference/commands/generate_playlist/#mps_youtube.commands.generate_playlist.read_sourcefile","title":"<code>read_sourcefile(filename)</code>","text":"<p>Read each line as a query from filename</p> Source code in <code>mps_youtube\\commands\\generate_playlist.py</code> <pre><code>def read_sourcefile(filename):\n    \"\"\"Read each line as a query from filename\"\"\"\n    with open(filename) as srcfl:\n        queries = list()\n        for item in srcfl.readlines():\n            clean_item = str(item).strip()\n            if not clean_item:\n                continue\n            queries.append(clean_item)\n        return queries\n</code></pre>"},{"location":"reference/commands/lastfm/","title":"lastfm.py","text":""},{"location":"reference/commands/lastfm/#mps_youtube.commands.lastfm.init_network","title":"<code>init_network(verbose=True)</code>","text":"<p>Initialize the global pylast network variable </p> Source code in <code>mps_youtube\\commands\\lastfm.py</code> <pre><code>@command(r'lastfm_connect', 'lastfm_connect')\ndef init_network(verbose=True):\n    \"\"\" Initialize the global pylast network variable \"\"\"\n    if not has_pylast :\n        if verbose:\n            pylast_url = 'https://github.com/pylast/pylast'\n            g.message = '\"pylast\" module not found\\n see %s' % (pylast_url)\n        return\n\n    # TODO: Add option to read lastfm config from file or env variable\n    key = config.LASTFM_API_KEY.get\n    secret = config.LASTFM_API_SECRET.get\n    password = config.LASTFM_PASSWORD.get # already hashed\n    username = config.LASTFM_USERNAME.get\n\n    if not (key and secret and password and username):\n        if verbose:\n            util.xprint(\"Not all Last.fm credentials were set.\")\n        return\n\n    try:\n        g.lastfm_network = pylast.LastFMNetwork(api_key=key, api_secret=secret,\n                                                username=username,\n                                                password_hash=password)\n        if verbose:\n            g.message = \"Last.fm authentication successful!\"\n    except (pylast.WSError, pylast.MalformedResponseError, pylast.NetworkError) as e:\n        if verbose:\n            g.message = \"Last.fm connection error: %s\" % (str(e))\n</code></pre>"},{"location":"reference/commands/lastfm/#mps_youtube.commands.lastfm.scrobble_track","title":"<code>scrobble_track(artist, album, track)</code>","text":"<p>Scrobble a track to the user's Last.fm account </p> Source code in <code>mps_youtube\\commands\\lastfm.py</code> <pre><code>def scrobble_track(artist, album, track):\n    \"\"\" Scrobble a track to the user's Last.fm account \"\"\"\n    if not g.lastfm_network:\n        return\n    unix_timestamp = int(time.mktime(datetime.datetime.now().timetuple()))\n    try:\n        g.lastfm_network.scrobble(artist=artist, title=track, album=album,\n                                  timestamp=unix_timestamp)\n    except (pylast.WSError, pylast.MalformedResponseError, pylast.NetworkError):\n        return\n</code></pre>"},{"location":"reference/commands/lastfm/#mps_youtube.commands.lastfm.set_now_playing","title":"<code>set_now_playing(artist, track)</code>","text":"<p>Set the current track as \"now playing\" on the user's Last.fm account </p> Source code in <code>mps_youtube\\commands\\lastfm.py</code> <pre><code>def set_now_playing(artist, track):\n    \"\"\" Set the current track as \"now playing\" on the user's Last.fm account \"\"\"\n    if not g.lastfm_network:\n        return\n    try:\n        g.lastfm_network.update_now_playing(artist=artist, title=track)\n    except (pylast.WSError, pylast.MalformedResponseError, pylast.NetworkError):\n        return\n</code></pre>"},{"location":"reference/commands/local_playlist/","title":"local_playlist.py","text":""},{"location":"reference/commands/local_playlist/#mps_youtube.commands.local_playlist.add_rm_all","title":"<code>add_rm_all(action)</code>","text":"<p>Add all displayed songs to current playlist.</p> <p>remove all displayed songs from view.</p> Source code in <code>mps_youtube\\commands\\local_playlist.py</code> <pre><code>@command(r'(rm|add)\\s(?:\\*|all)', 'rm', 'add')\ndef add_rm_all(action):\n    \"\"\" Add all displayed songs to current playlist.\n\n    remove all displayed songs from view.\n\n    \"\"\"\n    if action == \"rm\":\n        g.model.songs.clear()\n        msg = c.b + \"Cleared all songs\" + c.w\n        g.content = content.generate_songlist_display(zeromsg=msg)\n\n    elif action == \"add\":\n        size = len(g.model)\n        songlist_rm_add(\"add\", \"-\" + str(size))\n</code></pre>"},{"location":"reference/commands/local_playlist/#mps_youtube.commands.local_playlist.ls","title":"<code>ls()</code>","text":"<p>List user saved playlists. </p> Source code in <code>mps_youtube\\commands\\local_playlist.py</code> <pre><code>@command(r'ls', 'ls')\ndef ls():\n    \"\"\" List user saved playlists. \"\"\"\n    if not g.userpl:\n        g.message = util.F('no playlists')\n        g.content = g.content or \\\n                content.generate_songlist_display(zeromsg=g.message)\n\n    else:\n        g.content = content.playlists_display()\n        g.message = util.F('pl help')\n</code></pre>"},{"location":"reference/commands/local_playlist/#mps_youtube.commands.local_playlist.open_save_view","title":"<code>open_save_view(action, name)</code>","text":"<p>Open, save or view a playlist by name.  Get closest name match. </p> Source code in <code>mps_youtube\\commands\\local_playlist.py</code> <pre><code>@command(r'(open|save|view)\\s*(%s)' % WORD, 'open', 'save', 'view')\ndef open_save_view(action, name):\n    \"\"\" Open, save or view a playlist by name.  Get closest name match. \"\"\"\n    name = name.replace(\" \", \"-\")\n    if action == \"open\" or action == \"view\":\n        saved = g.userpl.get(name)\n\n        if not saved:\n            name = util.get_near_name(name, g.userpl)\n            saved = g.userpl.get(name)\n\n        elif action == \"open\":\n            g.active.songs = list(saved.songs)\n            g.last_opened = name\n            msg = util.F(\"pl loaded\") % name\n            paginatesongs(g.active, msg=msg)\n\n        elif action == \"view\":\n            g.last_opened = \"\"\n            msg = util.F(\"pl viewed\") % name\n            paginatesongs(list(saved.songs), msg=msg)\n\n        elif not saved and action in \"view open\".split():\n            g.message = util.F(\"pl not found\") % name\n            g.content = content.playlists_display()\n\n    elif action == \"save\":\n        if not g.model:\n            g.message = \"Nothing to save. \" + util.F('advise search')\n            g.content = content.generate_songlist_display()\n\n        else:\n            if g.selected_pafy_pls_id: # if a playlist was selected by user:\n                g.userpl[name] = Playlist(name, [Video(i['id'], i['title'], parse_video_length(i['duration'])) for i in g.pafy_pls[g.selected_pafy_pls_id][0].videos])\n            else: # user created custom playlist and never opened it and now wants to save it\n                g.userpl[name] = Playlist(name, list(g.model.songs))\n            g.message = util.F('pl saved') % name\n            playlists.save()\n            g.content = content.generate_songlist_display()\n</code></pre>"},{"location":"reference/commands/local_playlist/#mps_youtube.commands.local_playlist.open_view_bynum","title":"<code>open_view_bynum(action, num)</code>","text":"<p>Open or view a saved playlist by number. </p> Source code in <code>mps_youtube\\commands\\local_playlist.py</code> <pre><code>@command(r'(open|view)\\s*(\\d{1,4})', 'open', 'view')\ndef open_view_bynum(action, num):\n    \"\"\" Open or view a saved playlist by number. \"\"\"\n    srt = sorted(g.userpl)\n    name = srt[int(num) - 1]\n    open_save_view(action, name)\n</code></pre>"},{"location":"reference/commands/local_playlist/#mps_youtube.commands.local_playlist.playlist_add","title":"<code>playlist_add(nums, playlist)</code>","text":"<p>Add selected song nums to saved playlist. </p> Source code in <code>mps_youtube\\commands\\local_playlist.py</code> <pre><code>@command(r'add\\s*(-?\\d[-,\\d\\s]{1,250})(%s)' % WORD, 'add')\ndef playlist_add(nums, playlist):\n    \"\"\" Add selected song nums to saved playlist. \"\"\"\n    nums = util.parse_multi(nums)\n    # Replacing spaces with hyphens before checking if playlist already exist.\n    # See https://github.com/mps-youtube/mps-youtube/issues/1046.\n    playlist = playlist.replace(\" \", \"-\")\n\n    if not g.userpl.get(playlist):\n        g.userpl[playlist] = Playlist(playlist)\n\n    for songnum in nums:\n        g.userpl[playlist].songs.append(g.model[songnum - 1])\n        dur = g.userpl[playlist].duration\n        f = (len(nums), playlist, len(g.userpl[playlist]), dur)\n        g.message = util.F('added to saved pl') % f\n\n    if nums:\n        playlists.save()\n\n    g.content = content.generate_songlist_display()\n</code></pre>"},{"location":"reference/commands/local_playlist/#mps_youtube.commands.local_playlist.playlist_remove","title":"<code>playlist_remove(name)</code>","text":"<p>Delete a saved playlist by name - or purge working playlist if *all.</p> Source code in <code>mps_youtube\\commands\\local_playlist.py</code> <pre><code>@command(r'rmp\\s*(\\d+|%s)' % WORD, 'rmp')\ndef playlist_remove(name):\n    \"\"\" Delete a saved playlist by name - or purge working playlist if *all.\"\"\"\n    if name.isdigit() or g.userpl.get(name):\n\n        if name.isdigit():\n            name = int(name) - 1\n            name = sorted(g.userpl)[name]\n\n        playlists.delete(name)\n        g.message = \"Deleted playlist %s%s%s\" % (c.y, name, c.w)\n        g.content = content.playlists_display()\n        #playlists.save()\n\n    else:\n        g.message = util.F('pl not found advise ls') % name\n        g.content = content.playlists_display()\n</code></pre>"},{"location":"reference/commands/local_playlist/#mps_youtube.commands.local_playlist.playlist_rename","title":"<code>playlist_rename(playlists_)</code>","text":"<p>Rename a playlist using mv command. </p> Source code in <code>mps_youtube\\commands\\local_playlist.py</code> <pre><code>@command(r'mv\\s*(%s\\s+%s)' % (WORD, WORD), 'mv')\ndef playlist_rename(playlists_):\n    \"\"\" Rename a playlist using mv command. \"\"\"\n    # Deal with old playlist names that permitted spaces\n    a, b = \"\", playlists_.split(\" \")\n    while a not in g.userpl:\n        a = (a + \" \" + (b.pop(0))).strip()\n        if not b and a not in g.userpl:\n            g.message = util.F('no pl match for rename')\n            g.content = g.content or content.playlists_display()\n            return\n\n    b = \"-\".join(b)\n    g.userpl[b] = Playlist(b)\n    g.userpl[b].songs = list(g.userpl[a].songs)\n    playlist_remove(a)\n    g.message = util.F('pl renamed') % (a, b)\n    playlists.save()\n</code></pre>"},{"location":"reference/commands/local_playlist/#mps_youtube.commands.local_playlist.playlist_rename_idx","title":"<code>playlist_rename_idx(_id, name)</code>","text":"<p>Rename a playlist by ID. </p> Source code in <code>mps_youtube\\commands\\local_playlist.py</code> <pre><code>@command(r'mv\\s*(\\d{1,3})\\s*(%s)' % WORD, 'mv')\ndef playlist_rename_idx(_id, name):\n    \"\"\" Rename a playlist by ID. \"\"\"\n    _id = int(_id) - 1\n    playlist_rename(sorted(g.userpl)[_id] + \" \" + name)\n</code></pre>"},{"location":"reference/commands/local_playlist/#mps_youtube.commands.local_playlist.save_last","title":"<code>save_last()</code>","text":"<p>Save command with no playlist name. </p> Source code in <code>mps_youtube\\commands\\local_playlist.py</code> <pre><code>@command(r'save', 'save')\ndef save_last():\n    \"\"\" Save command with no playlist name. \"\"\"\n    if g.last_opened:\n        open_save_view(\"save\", g.last_opened)\n\n    else:\n        saveas = \"\"\n\n        # save using artist name in postion 1\n        if g.model:\n            if g.selected_pafy_pls_id: # if a playlist was selected\n                saveas = g.pafy_pls[g.selected_pafy_pls_id][0].info['info']['title']\n            else: # user didn't selected a playlist\n                saveas = g.model[0].title[:18].strip()\n            saveas = re.sub(r\"[^-\\w]\", \"-\", saveas, flags=re.UNICODE)\n\n        # loop to find next available name\n        post = 0\n\n        while g.userpl.get(saveas):\n            post += 1\n            saveas = g.model[0].title[:18].strip() + \"-\" + str(post)\n\n        # Playlists are not allowed to start with a digit\n        # TODO: Possibly change this, but ban purely numerical names\n        saveas = saveas.lstrip(\"0123456789\")\n\n        open_save_view(\"save\", saveas)\n</code></pre>"},{"location":"reference/commands/local_playlist/#mps_youtube.commands.local_playlist.vp","title":"<code>vp()</code>","text":"<p>View current working playlist. </p> Source code in <code>mps_youtube\\commands\\local_playlist.py</code> <pre><code>@command(r'vp', 'vp')\ndef vp():\n    \"\"\" View current working playlist. \"\"\"\n\n    msg = util.F('current pl')\n    txt = util.F('advise add') if g.model else util.F('advise search')\n    failmsg = util.F('pl empty') + \" \" + txt\n\n    paginatesongs(g.active, msg=msg, failmsg=failmsg)\n</code></pre>"},{"location":"reference/commands/misc/","title":"misc.py","text":""},{"location":"reference/commands/misc/#mps_youtube.commands.misc.clear_history","title":"<code>clear_history()</code>","text":"<p>Clears the user's play history </p> Source code in <code>mps_youtube\\commands\\misc.py</code> <pre><code>@command(r'history clear', 'history clear')\ndef clear_history():\n    \"\"\" Clears the user's play history \"\"\"\n    g.userhist['history'].songs = []\n    history.save()\n    g.message = \"History cleared\"\n    g.content = logo()\n</code></pre>"},{"location":"reference/commands/misc/#mps_youtube.commands.misc.clearcache","title":"<code>clearcache()</code>","text":"<p>Clear cached items - for debugging use. </p> Source code in <code>mps_youtube\\commands\\misc.py</code> <pre><code>@command(r'clearcache')\ndef clearcache():\n    \"\"\" Clear cached items - for debugging use. \"\"\"\n    g.pafs = {}\n    g.streams = {}\n    util.dbg(\"%scache cleared%s\", c.p, c.w)\n    g.message = \"cache cleared\"\n</code></pre>"},{"location":"reference/commands/misc/#mps_youtube.commands.misc.clipcopy_stream","title":"<code>clipcopy_stream(num)</code>","text":"<p>Copy content stream url to clipboard. </p> Source code in <code>mps_youtube\\commands\\misc.py</code> <pre><code>@command(r'X\\s*(\\d+)', 'X')\ndef clipcopy_stream(num):\n    \"\"\" Copy content stream url to clipboard. \"\"\"\n    if g.browse_mode == \"normal\":\n\n        item = (g.model[int(num) - 1])\n        details = player.stream_details(item)[1]\n        stream = details['url']\n\n    else:\n        g.message = \"clipboard copy not valid in this mode\"\n        g.content = generate_songlist_display()\n        return\n\n    if has_pyperclip:\n\n        try:\n            pyperclip.copy(stream)\n            g.message = c.y + stream + c.w + \" copied\"\n            g.content = generate_songlist_display()\n\n        except Exception as e:\n            g.content = generate_songlist_display()\n            g.message = stream + \"\\nError - couldn't copy to clipboard.\\n\" + \\\n                    ''.join(traceback.format_exception_only(type(e), e))\n\n    else:\n        g.message = \"pyperclip module must be installed for clipboard support\\n\"\n        g.message += \"see https://pypi.python.org/pypi/pyperclip/\"\n        g.content = generate_songlist_display()\n</code></pre>"},{"location":"reference/commands/misc/#mps_youtube.commands.misc.clipcopy_video","title":"<code>clipcopy_video(num)</code>","text":"<p>Copy video/playlist url to clipboard. </p> Source code in <code>mps_youtube\\commands\\misc.py</code> <pre><code>@command(r'x\\s*(\\d+)', 'x')\ndef clipcopy_video(num):\n    \"\"\" Copy video/playlist url to clipboard. \"\"\"\n    if g.browse_mode == \"ytpl\":\n\n        p = g.ytpls[int(num) - 1]\n        link = \"https://youtube.com/playlist?list=%s\" % p['link']\n\n    elif g.browse_mode == \"normal\":\n        item = (g.model[int(num) - 1])\n        link = \"https://youtube.com/watch?v=%s\" % item.ytid\n\n    else:\n        g.message = \"clipboard copy not valid in this mode\"\n        g.content = generate_songlist_display()\n        return\n\n    if has_pyperclip:\n\n        try:\n            pyperclip.copy(link)\n            g.message = c.y + link + c.w + \" copied\"\n            g.content = generate_songlist_display()\n\n        except Exception as e:\n            g.content = generate_songlist_display()\n            g.message = link + \"\\nError - couldn't copy to clipboard.\\n\" + \\\n                    ''.join(traceback.format_exception_only(type(e), e))\n\n    else:\n        g.message = \"pyperclip module must be installed for clipboard support\\n\"\n        g.message += \"see https://pypi.python.org/pypi/pyperclip/\"\n        g.content = generate_songlist_display()\n</code></pre>"},{"location":"reference/commands/misc/#mps_youtube.commands.misc.comments","title":"<code>comments(number)</code>","text":"<p>Receive use request to view comments. </p> Source code in <code>mps_youtube\\commands\\misc.py</code> <pre><code>@command(r'c\\s?(\\d{1,4})', 'c')\ndef comments(number):\n    \"\"\" Receive use request to view comments. \"\"\"\n    if g.browse_mode == \"normal\":\n        item = g.model[int(number) - 1]\n        fetch_comments(item)\n\n    else:\n        g.content = generate_songlist_display()\n        g.message = \"Comments only available for video items\"\n</code></pre>"},{"location":"reference/commands/misc/#mps_youtube.commands.misc.fetch_comments","title":"<code>fetch_comments(item)</code>","text":"<p>Fetch comments for item using gdata. </p> Source code in <code>mps_youtube\\commands\\misc.py</code> <pre><code>def fetch_comments(item):\n    \"\"\" Fetch comments for item using gdata. \"\"\"\n    # pylint: disable=R0912\n    # pylint: disable=R0914\n    ytid, title = item.ytid, item.title\n    util.dbg(\"Fetching comments for %s\", c.c(\"y\", ytid))\n    screen.writestatus(\"Fetching comments for %s\" % c.c(\"y\", title[:55]))\n    # qs = {'textFormat': 'plainText',\n    #       'videoId': ytid,\n    #       'maxResults': 50,\n    #       'part': 'snippet'}\n\n    # jsdata = None\n    try:\n        all_comments = pafy.get_comments(ytid)\n    except Exception:\n        raise\n    # coms = [x.get('snippet', {}) for x in jsdata.get('items', [])]\n\n    # skip blanks\n    # coms = [x for x in coms\n    #         if len(x.get('topLevelComment', {}).get('snippet', {}).get('textDisplay', '').strip())]\n\n    if not len(all_comments):\n        g.message = \"No comments for %s\" % item.title[:50]\n        g.content = generate_songlist_display()\n        return\n\n    commentstext = ''\n\n    for n, com in enumerate(all_comments, 1):\n        # snippet = com.get('topLevelComment', {}).get('snippet', {})\n        commentstext += _format_comment(n, len(all_comments), com['author']['name'], com['published'], com['content'])\n        # todo fetch comment replies\n        # if com.get('replyCount') &gt; 0:\n        #     replies = _fetch_commentreplies(com.get('topLevelComment').get('id'))\n        #     for n, com in enumerate(reversed(replies), 1):\n        #         commentstext += _format_comment(com.get('snippet', {}),\n        #                                         n, len(replies), True)\n\n    g.current_page = 0\n    g.content = content.StringContent(commentstext)\n</code></pre>"},{"location":"reference/commands/misc/#mps_youtube.commands.misc.quits","title":"<code>quits(showlogo=True)</code>","text":"<p>Exit the program. </p> Source code in <code>mps_youtube\\commands\\misc.py</code> <pre><code>@command(r'(?:q|quit|exit)', 'quit', 'exit')\ndef quits(showlogo=True):\n    \"\"\" Exit the program. \"\"\"\n    if has_readline and config.INPUT_HISTORY.get:\n        readline.write_history_file(g.READLINE_FILE)\n        util.dbg(\"Saved history file\")\n\n    cache.save()\n\n    screen.clear()\n    msg = logo(c.r, version=__version__) if showlogo else \"\"\n    msg += util.F(\"exitmsg\", 2)\n\n    if config.CHECKUPDATE.get and showlogo:\n\n        try:\n            url = \"https://raw.githubusercontent.com/mps-youtube/yewtube/master/setup.py\"\n            v = urlopen(url, timeout=1).read().decode()\n            v = re.search(r'__version__\\s*=\\s*\"\\s*([\\d\\.]+)\\s*\"\\s*', v, re.MULTILINE)\n\n            if v:\n                v = v.group(1)\n\n                if v &gt; __version__:\n                    msg += \"\\n\\nA newer version is available (%s). Use `help new` command to check what's changed.\\n\" % v\n\n        except (URLError, HTTPError, socket.timeout):\n            util.dbg(\"check update timed out\")\n\n    screen.msgexit(msg)\n</code></pre>"},{"location":"reference/commands/misc/#mps_youtube.commands.misc.recent_history","title":"<code>recent_history()</code>","text":"<p>Display the recent user's played songs </p> Source code in <code>mps_youtube\\commands\\misc.py</code> <pre><code>@command(r'history recent', 'history recent')\ndef recent_history():\n    \"\"\" Display the recent user's played songs \"\"\"\n    view_history(duplicates=False)\n</code></pre>"},{"location":"reference/commands/misc/#mps_youtube.commands.misc.show_help","title":"<code>show_help(choice)</code>","text":"<p>Print help message. </p> Source code in <code>mps_youtube\\commands\\misc.py</code> <pre><code>@command(r'(?:help|h)(?:\\s+([-_a-zA-Z]+))?', 'help')\ndef show_help(choice):\n    \"\"\" Print help message. \"\"\"\n\n    g.content = get_help(choice)\n</code></pre>"},{"location":"reference/commands/misc/#mps_youtube.commands.misc.stream_info","title":"<code>stream_info(num)</code>","text":"<p>Get stream information. </p> Source code in <code>mps_youtube\\commands\\misc.py</code> <pre><code>@command(r's\\s*(\\d{1,4})', 's')\ndef stream_info(num):\n    \"\"\" Get stream information. \"\"\"\n    if g.browse_mode == \"normal\":\n        g.content = logo(c.b)\n        screen.update()\n        screen.writestatus(\"Fetching stream metadata..\")\n        item = (g.model[int(num) - 1])\n        streams.get(item)\n        p = util.get_pafy(item)\n        setattr(p, 'ytid', p.videoid)\n        details = player.stream_details(p)[1]\n        screen.writestatus(\"Fetched\")\n        out = \"\\n\\n\" + c.ul + \"Stream Info\" + c.w + \"\\n\"\n        out += \"\\nExtension   : \" + details['ext']\n        out += \"\\nSize        : \" + str(details['size'])\n        out += \"\\nQuality     : \" + details['quality']\n        out += \"\\nRaw bitrate : \" + str(details['rawbitrate'])\n        out += \"\\nMedia type  : \" + details['mtype']\n        out += \"\\nLink        : \" + details['url']\n        out += \"\\n\\n%s[%sPress enter to go back%s]%s\" % (c.y, c.w, c.y, c.w)\n        g.content = out\n</code></pre>"},{"location":"reference/commands/misc/#mps_youtube.commands.misc.video_info","title":"<code>video_info(num)</code>","text":"<p>Get video information. </p> Source code in <code>mps_youtube\\commands\\misc.py</code> <pre><code>@command(r'i\\s*(\\d{1,4})', 'i')\ndef video_info(num):\n    \"\"\" Get video information. \"\"\"\n    if g.browse_mode == \"ytpl\":\n        p = g.ytpls[int(num) - 1]\n\n        # fetch the playlist item as it has more metadata\n        if p['link'] in g.pafy_pls:\n            ytpl = g.pafy_pls[p['link']][0]\n        else:\n            g.content = logo(col=c.g)\n            g.message = \"Fetching playlist info..\"\n            screen.update()\n            util.dbg(\"%sFetching playlist using pafy%s\", c.y, c.w)\n            ytpl = pafy.get_playlist2(p['link'])\n            g.pafy_pls[p['link']] = (ytpl, util.IterSlicer(ytpl))\n\n        ytpl_desc = ytpl.description\n        g.content = generate_songlist_display()\n        created = util.yt_datetime_local(p['created'])\n        updated = util.yt_datetime_local(p['updated'])\n        out = c.ul + \"Playlist Info\" + c.w + \"\\n\\n\"\n        out += p['title']\n        out += \"\\n\" + ytpl_desc\n        out += (\"\\n\\nAuthor     : \" + p['author'])\n        out += \"\\nSize       : \" + str(p['size']) + \" videos\"\n        out += \"\\nCreated    : \" + created[1] + \" \" + created[2]\n        out += \"\\nUpdated    : \" + updated[1] + \" \" + updated[2]\n        out += \"\\nID         : \" + str(p['link'])\n        out += (\"\\n\\n%s[%sPress enter to go back%s]%s\" % (c.y, c.w, c.y, c.w))\n        g.content = out\n\n    elif g.browse_mode == \"normal\":\n        g.content = logo(c.b)\n        screen.update()\n        screen.writestatus(\"Fetching video metadata..\")\n        item = (g.model[int(num) - 1])\n        streams.get(item)\n        p = pafy.get_video_info(item.ytid)\n        #pub = datetime.strptime(str(p.published), \"%Y-%m-%d %H:%M:%SZ\")\n        #pub = util.utc2local(pub)\n        screen.writestatus(\"Fetched\")\n        out = c.ul + \"Video Info\" + c.w + \"\\n\\n\"\n        out += p['title'] or \"\"\n        out += \"\\n\\nDescription:\\n\\n\" + str(p.get('description', \"\")) + \"\\n\"\n        out += \"\\nKeywords: \" + str(p['keywords']) + \"\\n\"\n        out += \"\\nIs Live Now    : \" + str(p['isLiveNow'])\n        out += \"\\nDuration       : \" + str(timedelta(seconds=int(p['duration']['secondsText'])))\n        out += \"\\nView count     : \" + \"{:,}\".format(int(p['viewCount']['text']))\n        out += \"\\nAuthor         : \" + str(p['channel']['name'] + ' ~ ' + p['channel']['link'])\n        out += \"\\nPublished Date : \" + str(p['publishDate'])\n        out += \"\\nUploaded Date  : \" + str(p['uploadDate'])\n        out += \"\\nRating         : \" + str(p['averageRating'])\n        out += \"\\nLikes          : \" + \"{:,}\".format(p.get('likes', 0))\n        out += \"\\nDislikes       : \" + \"{:,}\".format(p.get('dislikes', 0))\n        out += \"\\nCategory       : \" + str(p['category'])\n        out += \"\\nFamily Safe    : \" + str(p['isFamilySafe'])\n        out += \"\\nLink           : \" + str(p['link'])\n        if config.SHOW_QRCODE.get:\n            out += \"\\n\" + qrcode_display(\n                \"https://youtube.com/watch?v=%s\" % p.videoid)\n\n        out += \"\\n\\n%s[%sPress enter to go back%s]%s\" % (c.y, c.w, c.y, c.w)\n        g.content = out\n</code></pre>"},{"location":"reference/commands/misc/#mps_youtube.commands.misc.view_history","title":"<code>view_history(duplicates=True)</code>","text":"<p>Display the user's play history </p> Source code in <code>mps_youtube\\commands\\misc.py</code> <pre><code>@command(r'history', 'history')\ndef view_history(duplicates=True):\n    \"\"\" Display the user's play history \"\"\"\n    history = g.userhist.get('history')\n    #g.last_opened = \"\"\n    try:\n        hist_list = list(reversed(history.songs))\n        message = \"Viewing play history\"\n        if not duplicates:\n            # List unique elements and preserve order.\n            seen = set()\n            seen_add = seen.add  # it makes calls to add() faster\n            hist_list = [x for x in hist_list if not (x.ytid in seen or seen_add(x.ytid))]\n            message = \"Viewing recent played songs\"\n        paginatesongs(hist_list)\n        g.message = message\n\n    except AttributeError:\n        g.content = logo(c.r)\n        g.message = \"History empty\"\n\n\n    if not config.HISTORY.get:\n        g.message += \"\\t{1}History recording is currently off{0}\".format(c.w,c.y)\n</code></pre>"},{"location":"reference/commands/play/","title":"play.py","text":""},{"location":"reference/commands/play/#mps_youtube.commands.play.browser_play","title":"<code>browser_play(number)</code>","text":"<p>Open a previously searched result in the browser.</p> Source code in <code>mps_youtube\\commands\\play.py</code> <pre><code>@command(r'browserplay\\s(\\d{1,50})', 'browserplay')\ndef browser_play(number):\n    \"\"\"Open a previously searched result in the browser.\"\"\"\n    if (len(g.model) == 0):\n        g.message = c.r + \"No previous search.\" + c.w\n        g.content = content.logo(c.r)\n        return\n\n    try:\n        index = int(number) - 1\n\n        if (0 &lt;= index &lt; len(g.model)):\n            base_url = \"https://www.youtube.com/watch?v=\"\n            video = g.model[index]\n            url = base_url + video.ytid\n            webbrowser.open(url)\n            g.content = g.content or content.generate_songlist_display()\n\n        else:\n            g.message = c.r + \"Out of range.\" + c.w\n            g.content = g.content or content.generate_songlist_display()\n            return\n\n    except (HTTPError, URLError, Exception) as e:\n        g.message = c.r + str(e) + c.w\n        g.content = g.content or content.generate_songlist_display()\n        return\n</code></pre>"},{"location":"reference/commands/play/#mps_youtube.commands.play.play","title":"<code>play(pre, choice, post='')</code>","text":"<p>Play choice.  Use repeat/random if appears in pre/post. </p> Source code in <code>mps_youtube\\commands\\play.py</code> <pre><code>@command(r'(%s{0,3})([-,\\d\\s\\[\\]]{1,250})\\s*(%s{0,3})$' %\n         (RS, RS))\ndef play(pre, choice, post=\"\"):\n    \"\"\" Play choice.  Use repeat/random if appears in pre/post. \"\"\"\n    # pylint: disable=R0914\n    # too many local variables\n\n    # Im just highjacking this if g.content is a\n    # content.Content class\n    if isinstance(g.content, content.Content):\n        play_call = getattr(g.content, \"_play\", None)\n        if callable(play_call):\n            play_call(pre, choice, post)\n        return\n\n    if g.browse_mode == \"ytpl\":\n\n        if choice.isdigit():\n            g.selected_pafy_pls_id = g.ytpls[int(choice)-1]['link']\n            return plist(g.selected_pafy_pls_id)\n        else:\n            g.message = \"Invalid playlist selection: %s\" % c.y + choice + c.w\n            g.content = content.generate_songlist_display()\n            return\n\n    if not g.model:\n        g.message = c.r + \"There are no tracks to select\" + c.w\n        g.content = g.content or content.generate_songlist_display()\n\n    else:\n        shuffle = \"shuffle\" in pre + post\n        repeat = \"repeat\" in pre + post\n        novid = \"-a\" in pre + post\n        fs = \"-f\" in pre + post\n        nofs = \"-w\" in pre + post\n        forcevid = \"-v\" in pre + post\n\n        if ((novid and fs) or (novid and nofs) or (nofs and fs)\n           or (novid and forcevid)):\n            raise IOError(\"Conflicting override options specified\")\n\n        override = False\n        override = \"audio\" if novid else override\n        override = \"fullscreen\" if fs else override\n        override = \"window\" if nofs else override\n\n        if (not fs) and (not nofs):\n            override = \"forcevid\" if forcevid else override\n\n        selection = util.parse_multi(choice)\n        songlist = [g.model[x - 1] for x in selection]\n\n        # cache next result of displayed items\n        # when selecting a single item\n        if len(songlist) == 1:\n            chosen = selection[0] - 1\n\n            if len(g.model) &gt; chosen + 1:\n                streams.preload(g.model[chosen + 1], override=override)\n\n        if g.scrobble:\n            old_queue = g.scrobble_queue\n            g.scrobble_queue = [g.scrobble_queue[x - 1] for x in selection]\n\n        try:\n            if not config.PLAYER.get or not util.has_exefile(config.PLAYER.get):\n                g.message = \"Player not configured! Enter %sset player &lt;player_app&gt; \"\\\n                            \"%s to set a player\" % (c.g, c.w)\n                return\n            g.PLAYER_OBJ.play(songlist, shuffle, repeat, override)\n        except KeyboardInterrupt:\n            return\n        finally:\n            g.content = content.generate_songlist_display()\n\n        if g.scrobble:\n            g.scrobble_queue = old_queue\n\n        if config.AUTOPLAY.get:\n            related(selection.pop())\n            play(pre, str(random.randint(1, 15)), post=\"\")\n</code></pre>"},{"location":"reference/commands/play/#mps_youtube.commands.play.play_all","title":"<code>play_all(pre, choice, post='')</code>","text":"<p>Play all tracks in model (last displayed). shuffle/repeat if req'd.</p> Source code in <code>mps_youtube\\commands\\play.py</code> <pre><code>@command(r'(%s{0,3})(?:\\*|all)\\s*(%s{0,3})' %\n        (RS, RS))\ndef play_all(pre, choice, post=\"\"):\n    \"\"\" Play all tracks in model (last displayed). shuffle/repeat if req'd.\"\"\"\n    options = pre + choice + post\n    play(options, \"1-\" + str(len(g.model)))\n</code></pre>"},{"location":"reference/commands/play/#mps_youtube.commands.play.play_pl","title":"<code>play_pl(name)</code>","text":"<p>Play a playlist by name. </p> Source code in <code>mps_youtube\\commands\\play.py</code> <pre><code>@command(r'play\\s+(%s|\\d+)' % WORD, 'play')\ndef play_pl(name):\n    \"\"\" Play a playlist by name. \"\"\"\n    if name.isdigit():\n        name = int(name)\n        name = sorted(g.userpl)[name - 1]\n\n    saved = g.userpl.get(name)\n\n    if not saved:\n        name = util.get_near_name(name, g.userpl)\n        saved = g.userpl.get(name)\n\n    if saved:\n        g.model.songs = list(saved.songs)\n        play_all(\"\", \"\", \"\")\n\n    else:\n        g.message = util.F(\"pl not found\") % name\n        g.content = content.playlists_display()\n</code></pre>"},{"location":"reference/commands/play/#mps_youtube.commands.play.play_url","title":"<code>play_url(url, override)</code>","text":"<p>Open and play a youtube video url.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>url to be played</p> required <code>override</code> <code>Any</code> <p>override</p> required <p>Exceptions:</p> Type Description <code>SystemExit</code> <p>If run from command line</p> Source code in <code>mps_youtube\\commands\\play.py</code> <pre><code>@command(r'playurl\\s(.*[-_a-zA-Z0-9]{11}[^\\s]*)(\\s-(?:f|a|w))?', 'playurl')\ndef play_url(url: str, override: T.Any):\n    \"\"\"Open and play a youtube video url.\n\n    Args:\n        url: url to be played\n        override: override\n\n    Raises:\n        SystemExit: If run from command line\n    \"\"\"\n    # @fixme check override type hint\n    override = override if override else \"_\"\n    g.browse_mode = \"normal\"\n    yt_url(url, print_title=True)\n\n    if len(g.model) == 1:\n        play(override, \"1\", \"_\")\n\n    if g.command_line:\n        sys.exit()\n</code></pre>"},{"location":"reference/commands/search/","title":"search.py","text":""},{"location":"reference/commands/search/#mps_youtube.commands.search.cache_userdata","title":"<code>cache_userdata(userterm, username, channel_id)</code>","text":"<p>Cache user name and channel id tuple </p> Source code in <code>mps_youtube\\commands\\search.py</code> <pre><code>def cache_userdata(userterm, username, channel_id):\n    \"\"\" Cache user name and channel id tuple \"\"\"\n    userterm = ''.join([t.strip().lower() for t in userterm.split(' ')])\n    g.username_query_cache[userterm] = (username, channel_id)\n    util.dbg('Cache data for username search query \"{}\": {} ({})'.format(\n        userterm, username, channel_id))\n\n    while len(g.username_query_cache) &gt; 300:\n        g.username_query_cache.popitem(last=False)\n    return (username, channel_id)\n</code></pre>"},{"location":"reference/commands/search/#mps_youtube.commands.search.channelfromname","title":"<code>channelfromname(user)</code>","text":"<p>Query channel id from username. </p> Source code in <code>mps_youtube\\commands\\search.py</code> <pre><code>def channelfromname(user):\n    \"\"\" Query channel id from username. \"\"\"\n\n    cached = userdata_cached(user)\n    if cached:\n        return cached\n\n    try:\n        channel_id, channel_name = pafy.channel_id_from_name(user)\n        return cache_userdata(user, channel_name, channel_id)\n\n    except Exception as e:\n        import traceback\n        traceback.print_exception(type(e), e, e.__traceback__)\n        g.message = \"Could not retrieve information for user {}\\n{}\".format(\n            c.y + user + c.w, e)\n        util.dbg('Error during channel request for user {}:\\n{}'.format(\n            user, e))\n\n    # at this point, we know the channel id associated to a user name\n    return None\n</code></pre>"},{"location":"reference/commands/search/#mps_youtube.commands.search.get_pl_from_json","title":"<code>get_pl_from_json(pldata)</code>","text":"<p>Process json playlist data. </p> Source code in <code>mps_youtube\\commands\\search.py</code> <pre><code>def get_pl_from_json(pldata):\n    \"\"\" Process json playlist data. \"\"\"\n\n    try:\n        items = pldata\n\n    except KeyError:\n        items = []\n\n    results = []\n\n    for item in items:\n        results.append(dict(\n            link=item[\"id\"],\n            size=item[\"videoCount\"],\n            title=item[\"title\"],\n            author= item['channel'][\"name\"] if 'channel' in item.keys()  else None,\n            created=item.get(\"publishedAt\"),\n            updated=item.get('publishedAt'), #XXX Not available in API?\n            description=item.get(\"description\")))\n\n    return results\n</code></pre>"},{"location":"reference/commands/search/#mps_youtube.commands.search.get_track_id_from_json","title":"<code>get_track_id_from_json(item)</code>","text":"<p>Try to extract video Id from various response types </p> Source code in <code>mps_youtube\\commands\\search.py</code> <pre><code>def get_track_id_from_json(item):\n    \"\"\" Try to extract video Id from various response types \"\"\"\n    fields = ['contentDetails/videoId',\n              'snippet/resourceId/videoId',\n              'id/videoId',\n              'id']\n    for field in fields:\n        node = item\n        for p in field.split('/'):\n            if node and isinstance(node, dict):\n                node = node.get(p)\n        if node:\n            return node\n    return ''\n</code></pre>"},{"location":"reference/commands/search/#mps_youtube.commands.search.get_tracks_from_json","title":"<code>get_tracks_from_json(jsons)</code>","text":"<p>Get search results from API response </p> Source code in <code>mps_youtube\\commands\\search.py</code> <pre><code>def get_tracks_from_json(jsons):\n    \"\"\" Get search results from API response \"\"\"\n\n    if len(jsons) == 0:\n        util.dbg(\"got unexpected data or no search results\")\n        return ()\n\n    # populate list of video objects\n    songs = []\n    for item in jsons:\n        try:\n            ytid = get_track_id_from_json(item)\n            duration = util.parse_video_length(item.get('duration'))\n            #stats = item.get('statistics', {})\n            #snippet = item.get('snippet', {})\n            title = item.get('title', '').strip()\n            # instantiate video representation in local model\n            cursong = Video(ytid=ytid, title=title, length=duration)\n            dislike_data = {'likes': 0, 'dislikes':0, 'rating':0}#pafy.return_dislikes(ytid)\n            likes = int(dislike_data['likes'])\n            dislikes = int(dislike_data['dislikes'])\n            # this is a very poor attempt to calculate a rating value\n            rating = int(dislike_data['rating'])#5.*likes/(likes+dislikes) if (likes+dislikes) &gt; 0 else 0\n            category = '?'#snippet.get('categoryId')\n            publishedlocaldatetime = item.get('publishedTime','?')#util.yt_datetime_local(snippet.get('publishedAt', ''))\n\n            # cache video information in custom global variable store\n            g.meta[ytid] = dict(\n                # tries to get localized title first, fallback to normal title\n                title=title,\n                length=str(util.fmt_time(cursong.length)),\n                rating=rating,#str('{}'.format(rating))[:4].ljust(4, \"0\"),\n                uploader=item['channel']['id'],\n                uploaderName=item['channel']['name'],\n                category=category,\n                aspect=\"custom\", #XXX\n                uploaded=publishedlocaldatetime,#publishedlocaldatetime[1] if publishedlocaldatetime is not None else None,\n                uploadedTime=publishedlocaldatetime,#,publishedlocaldatetime[2] if publishedlocaldatetime is not None else None,\n                likes=str(num_repr(likes)),\n                dislikes=str(num_repr(dislikes)),\n                commentCount='?',#str(num_repr(int(stats.get('commentCount', 0)))),\n                viewCount= item['viewCount']['text'] if 'viewCount' in item.keys() else '?')#str(num_repr(int(stats.get('viewCount', 0)))))\n            songs.append(cursong)\n\n        except Exception as e:\n            import traceback\n            traceback.print_exception(type(e), e, e.__traceback__)\n            input('Press any key to continue...')\n            util.dbg(json.dumps(item, indent=2))\n            util.dbg('Error during metadata extraction/instantiation of ' +\n                'search result {}\\n{}'.format(ytid, e))\n\n\n\n    # return video objects\n    return songs\n</code></pre>"},{"location":"reference/commands/search/#mps_youtube.commands.search.mix","title":"<code>mix(num)</code>","text":"<p>Retrieves the YouTube mix for the selected video. </p> Source code in <code>mps_youtube\\commands\\search.py</code> <pre><code>@command(r'mix\\s*(\\d{1,4})', 'mix')\ndef mix(num):\n    \"\"\" Retrieves the YouTube mix for the selected video. \"\"\"\n    g.content = g.content or content.generate_songlist_display()\n    if g.browse_mode != \"normal\":\n        g.message = util.F('mix only videos')\n    else:\n        item = (g.model[int(num) - 1])\n        if item is None:\n            g.message = util.F('invalid item')\n            return\n        item = util.get_pafy(item)\n        # Mix playlists are made up of 'RD' + video_id\n        try:\n            plist(\"RD\" + item.videoid)\n        except OSError:\n            g.message = util.F('no mix')\n</code></pre>"},{"location":"reference/commands/search/#mps_youtube.commands.search.num_repr","title":"<code>num_repr(num)</code>","text":"<p>Return up to four digit string representation of a number, eg 2.6m. </p> Source code in <code>mps_youtube\\commands\\search.py</code> <pre><code>def num_repr(num):\n    \"\"\" Return up to four digit string representation of a number, eg 2.6m. \"\"\"\n    if num &lt;= 9999:\n        return str(num)\n\n    def digit_count(x):\n        \"\"\" Return number of digits. \"\"\"\n        return int(math.floor(math.log10(x)) + 1)\n\n    digits = digit_count(num)\n    sig = 3 if digits % 3 == 0 else 2\n    rounded = int(round(num, int(sig - digits)))\n    digits = digit_count(rounded)\n    suffix = \"_kmBTqXYX\"[(digits - 1) // 3]\n    front = 3 if digits % 3 == 0 else digits % 3\n\n    if not front == 1:\n        return str(rounded)[0:front] + suffix\n\n    return str(rounded)[0] + \".\" + str(rounded)[1] + suffix\n</code></pre>"},{"location":"reference/commands/search/#mps_youtube.commands.search.pl_search","title":"<code>pl_search(term, page=0, splash=True, is_user=False)</code>","text":"<p>Search for YouTube playlists.</p> <p>term can be query str or dict indicating user playlist search.</p> Source code in <code>mps_youtube\\commands\\search.py</code> <pre><code>@command(r'(?:\\.\\.|\\/\\/|pls(?:earch)?\\s)\\s*(.*)', 'plsearch')\ndef pl_search(term, page=0, splash=True, is_user=False):\n    \"\"\" Search for YouTube playlists.\n\n    term can be query str or dict indicating user playlist search.\n\n    \"\"\"\n    if not term or len(term) &lt; 2:\n        g.message = c.r + \"Not enough input\" + c.w\n        g.content = content.generate_songlist_display()\n        return\n\n    if splash:\n        g.content = content.logo(c.g)\n        prog = \"user: \" + term if is_user else term\n        g.message = \"Searching playlists for %s\" % c.y + prog + c.w\n        screen.update()\n\n    logging.info(\"playlist search for %s\", prog)\n    if is_user:\n        ret = channelfromname(term)\n        if not ret:\n            return\n        user, channel_id = ret\n        pldata = pafy.all_playlists_from_channel(channel_id)\n    else:\n        pldata = pafy.playlist_search(term)\n\n    playlists = get_pl_from_json(pldata)[:util.getxy().max_results]\n\n    if playlists:\n        g.last_search_query = (pl_search, {\"term\": term, \"is_user\": is_user})\n        g.browse_mode = \"ytpl\"\n        g.current_page = page\n        g.result_count = len(pldata)\n        g.ytpls = playlists\n        g.message = \"Playlist results for %s\" % c.y + prog + c.w\n        g.content = content.generate_playlist_display()\n\n    else:\n        g.message = \"No playlists found for: %s\" % c.y + prog + c.w\n        g.current_page = 0\n        g.content = content.generate_songlist_display(zeromsg=g.message)\n</code></pre>"},{"location":"reference/commands/search/#mps_youtube.commands.search.related","title":"<code>related(num)</code>","text":"<p>Show videos related to to vid num. </p> Source code in <code>mps_youtube\\commands\\search.py</code> <pre><code>@command(r'r\\s?(\\d{1,4})', 'r')\ndef related(num):\n    \"\"\" Show videos related to to vid num. \"\"\"\n    if g.browse_mode != \"normal\":\n        g.message = \"Related items must refer to a specific video item\"\n        g.message = c.y + g.message + c.w\n        g.content = content.generate_songlist_display()\n        return\n\n    g.current_page = 0\n    item = g.model[int(num) - 1]\n    related_search(item)\n</code></pre>"},{"location":"reference/commands/search/#mps_youtube.commands.search.related_search","title":"<code>related_search(vitem)</code>","text":"<p>Fetch videos related to vitem vitem = {'description': str, 'length': int, 'title': str, 'ytid': str}</p> Source code in <code>mps_youtube\\commands\\search.py</code> <pre><code>def related_search(vitem):\n    \"\"\" Fetch videos related to vitem\n    vitem = {'description': str, 'length': int, 'title': str, 'ytid': str}\n    \"\"\"\n\n    t = vitem.title\n    ttitle = t[:48].strip() + \"..\" if len(t) &gt; 49 else t\n\n    msg = \"Videos related to %s%s%s\" % (c.y, ttitle, c.w)\n    failmsg = \"Related to %s%s%s not found\" % (c.y, vitem.ytid, c.w)\n\n    # todo: implement realted search in pafy\n    #_search(ttitle, vitem.title, msg, failmsg)\n</code></pre>"},{"location":"reference/commands/search/#mps_youtube.commands.search.search","title":"<code>search(term)</code>","text":"<p>Perform search. </p> Source code in <code>mps_youtube\\commands\\search.py</code> <pre><code>@command(r'(?:search|\\.|/)\\s*([^./].{1,500})', 'search')\ndef search(term):\n    \"\"\" Perform search. \"\"\"\n    try:  # TODO make use of unknowns\n        args, unknown = parser.parse_known_args(term.split())\n        video_duration = args.duration if args.duration else 'any'\n        if args.category:\n            if not args.category[0].isdigit():\n                args.category = g.categories.get(args.category[0])\n            else:\n                args.category = \"\".join(args.category)\n        after = args.after\n        term = ' '.join(args.search)\n    except SystemExit:  # &lt;------ argsparse calls exit()\n        g.message = c.b + \"Bad syntax. Enter h for help\" + c.w\n        return\n\n    if not term or len(term) &lt; 2:\n        g.message = c.r + \"Not enough input\" + c.w\n        g.content = content.generate_songlist_display()\n        return\n\n    logging.info(\"search for %s\", term)\n    #query = generate_search_qs(term, videoDuration=video_duration, after=after, category=args.category, is_live=args.live)\n\n    msg = \"Search results for %s%s%s\" % (c.y, term, c.w)\n    failmsg = \"Found nothing for %s%s%s\" % (c.y, term, c.w)\n    wdata = pafy.search_videos(term, int(config.PAGES.get))\n    _display_search_results(term, wdata, msg, failmsg)\n</code></pre>"},{"location":"reference/commands/search/#mps_youtube.commands.search.token","title":"<code>token(page)</code>","text":"<p>Returns a page token for a given start index. </p> Source code in <code>mps_youtube\\commands\\search.py</code> <pre><code>def token(page):\n    \"\"\" Returns a page token for a given start index. \"\"\"\n    index = (page or 0) * util.getxy().max_results\n    k = index//128 - 1\n    index -= 128 * k\n    f = [8, index]\n    if k &gt; 0 or index &gt; 127:\n        f.append(k+1)\n    f += [16, 0]\n    b64 = base64.b64encode(bytes(f)).decode('utf8')\n    return b64.strip('=')\n</code></pre>"},{"location":"reference/commands/search/#mps_youtube.commands.search.user_more","title":"<code>user_more(num)</code>","text":"<p>Show more videos from user of vid num. </p> Source code in <code>mps_youtube\\commands\\search.py</code> <pre><code>@command(r'u\\s?([\\d]{1,4})', 'u')\ndef user_more(num):\n    \"\"\" Show more videos from user of vid num. \"\"\"\n    if g.browse_mode != \"normal\":\n        g.message = \"User uploads must refer to a specific video item\"\n        g.message = c.y + g.message + c.w\n        g.content = content.generate_songlist_display()\n        return\n\n    g.current_page = 0\n    item = g.model[int(num) - 1]\n\n    #TODO: Cleaner way of doing this?\n    if item.ytid in g.meta:\n        channel_id = g.meta.get(item.ytid, {}).get('uploader')\n        user = g.meta.get(item.ytid, {}).get('uploaderName')\n    else:\n        paf = util.get_pafy(item)\n        user, channel_id = channelfromname(paf.author)\n\n    usersearch_id(user, channel_id, '')\n</code></pre>"},{"location":"reference/commands/search/#mps_youtube.commands.search.user_pls","title":"<code>user_pls(user)</code>","text":"<p>Retrieve user playlists. </p> Source code in <code>mps_youtube\\commands\\search.py</code> <pre><code>@command(r'u(?:ser)?pl\\s(.*)', 'userpl', 'upl')\ndef user_pls(user):\n    \"\"\" Retrieve user playlists. \"\"\"\n    return pl_search(user, is_user=True)\n</code></pre>"},{"location":"reference/commands/search/#mps_youtube.commands.search.userdata_cached","title":"<code>userdata_cached(userterm)</code>","text":"<p>Check if user name search term found in cache </p> Source code in <code>mps_youtube\\commands\\search.py</code> <pre><code>def userdata_cached(userterm):\n    \"\"\" Check if user name search term found in cache \"\"\"\n    userterm = ''.join([t.strip().lower() for t in userterm.split(' ')])\n    return g.username_query_cache.get(userterm)\n</code></pre>"},{"location":"reference/commands/search/#mps_youtube.commands.search.usersearch","title":"<code>usersearch(q_user, identify='forUsername')</code>","text":"<p>Fetch uploads by a YouTube user. </p> Source code in <code>mps_youtube\\commands\\search.py</code> <pre><code>@command(r'user\\s+(.+)', 'user')\ndef usersearch(q_user, identify='forUsername'):\n    \"\"\" Fetch uploads by a YouTube user. \"\"\"\n\n    user, _, term = (x.strip() for x in q_user.partition(\"/\"))\n    if identify == 'forUsername':\n        ret = channelfromname(user)\n        if not ret:  # Error\n            return\n        user, channel_id = ret\n\n    else:\n        channel_id = user\n\n    # at this point, we know the channel id associated to a user name\n    usersearch_id(user, channel_id, term)\n</code></pre>"},{"location":"reference/commands/search/#mps_youtube.commands.search.usersearch_id","title":"<code>usersearch_id(user, channel_id, term)</code>","text":"<p>Performs a search within a user's (i.e. a channel's) uploads for an optional search term with the user (i.e. the channel) identified by its ID </p> Source code in <code>mps_youtube\\commands\\search.py</code> <pre><code>def usersearch_id(user, channel_id, term):\n    \"\"\" Performs a search within a user's (i.e. a channel's) uploads\n    for an optional search term with the user (i.e. the channel)\n    identified by its ID \"\"\"\n\n    #query = generate_search_qs(term)\n    aliases = dict(views='viewCount')  # The value of the config item is 'views' not 'viewCount'\n    if config.USER_ORDER.get:\n        pass\n        #query['order'] = aliases.get(config.USER_ORDER.get,\n        #        config.USER_ORDER.get)\n    #query['channelId'] = channel_id\n\n    termuser = tuple([c.y + x + c.w for x in (term, user)])\n    if term:\n        msg = \"Results for {1}{3}{0} (by {2}{4}{0})\"\n        progtext = \"%s by %s\" % termuser\n        failmsg = \"No matching results for %s (by %s)\" % termuser\n    else:\n        msg = \"Video uploads by {2}{4}{0}\"\n        progtext = termuser[1]\n        if config.SEARCH_MUSIC:\n            failmsg = \"\"\"User %s not found or has no videos in the Music category.\nUse 'set search_music False' to show results not in the Music category.\"\"\" % termuser[1]\n        else:\n            failmsg = \"User %s not found or has no videos.\"  % termuser[1]\n    msg = str(msg).format(c.w, c.y, c.y, term, user)\n\n    videos = pafy.all_videos_from_channel(channel_id)\n    query = term.lower() if term else None\n\n    if query:\n        results = [v for v in videos if query in v.get('title', '').lower() or query in v.get('description', '').lower()]\n    else:\n        results = videos\n    _display_search_results(progtext, results, msg, failmsg)\n</code></pre>"},{"location":"reference/commands/search/#mps_youtube.commands.search.yt_url","title":"<code>yt_url(url, print_title=False)</code>","text":"<p>Acess videos by urls.</p> <p>If <code>print_title</code> is true only last title from unique parsed id will be printed.</p> <p>If for example <code>vid1</code> and <code>vid2</code> have title <code>title1</code> and <code>title2</code>, respectively, <code>yt_url('vid1 vid2 vid1', True)</code> will print <code>title2</code> from <code>vid2</code> instead <code>title1</code> from last entry <code>vid1</code>.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>youtube url</p> required <code>print_title</code> <code>bool</code> <p>print title or not</p> <code>False</code> Source code in <code>mps_youtube\\commands\\search.py</code> <pre><code>@command(r\"url\\s(.*[-_a-zA-Z0-9]{11}.*)\", \"url\")\ndef yt_url(url: str, print_title: bool = False):\n    \"\"\"\n    Acess videos by urls.\n\n    If `print_title` is true only last title from unique parsed id will be printed.\n\n    If for example `vid1` and `vid2` have title `title1` and `title2`, respectively,\n    `yt_url('vid1 vid2 vid1', True)`\n    will print `title2` from `vid2` instead `title1` from last entry `vid1`.\n\n    Args:\n        url: youtube url\n        print_title: print title or not\n    \"\"\"\n    url_list = url.split()\n\n    g.model.songs = []\n\n    v_ids = set()\n    v_title = None\n    for url in url_list:\n        try:\n            v_id = pafy.extract_video_id(url)\n            if v_id in v_ids:\n                continue\n            p = pafy.get_video_info(v_id)\n        except (IOError, ValueError, Exception) as e:\n            g.message = c.r + str(e) + c.w\n            g.content = g.content or content.generate_songlist_display(\n                    zeromsg=g.message)\n            return\n\n        g.browse_mode = \"normal\"\n        v = Video(p['id'], p['title'], int(p['duration']['secondsText']))\n        if p and isinstance(p, dict):\n            v_title = p.get(\"title\")\n        g.model.songs.append(v)\n        v_ids.add(v_id)\n\n    if not g.command_line:\n        g.content = content.generate_songlist_display()\n\n    if print_title and v_title:\n        util.xprint(v_title)\n</code></pre>"},{"location":"reference/commands/search/#mps_youtube.commands.search.yt_url_file","title":"<code>yt_url_file(file_name)</code>","text":"<p>Access a list of urls in a text file </p> Source code in <code>mps_youtube\\commands\\search.py</code> <pre><code>@command(r'url_file\\s(\\S+)', 'url_file')\ndef yt_url_file(file_name):\n    \"\"\" Access a list of urls in a text file \"\"\"\n\n    #Open and read the file\n    try:\n        with open(file_name, \"r\") as fo:\n            output = ' '.join([line.strip() for line in fo if line.strip()])\n\n    except (IOError):\n        g.message = c.r + 'Error while opening the file, check the validity of the path' + c.w\n        g.content = g.content or content.generate_songlist_display(\n                zeromsg=g.message)\n        return\n\n    #Finally pass the input to yt_url\n    yt_url(output)\n</code></pre>"},{"location":"reference/commands/songlist/","title":"songlist.py","text":""},{"location":"reference/commands/songlist/#mps_youtube.commands.songlist.dump","title":"<code>dump(un)</code>","text":"<p>Show entire playlist. </p> Source code in <code>mps_youtube\\commands\\songlist.py</code> <pre><code>@command(r'(un)?dump', 'dump', 'undump')\ndef dump(un):\n    \"\"\" Show entire playlist. \"\"\"\n    func, args = g.last_search_query\n\n    if func is paginatesongs:\n        paginatesongs(dumps=(not un), **args)\n\n    else:\n        un = \"\" if not un else un\n        g.message = \"%s%sdump%s may only be used on an open YouTube playlist\"\n        g.message = g.message % (c.y, un, c.w)\n        g.content = content.generate_songlist_display()\n</code></pre>"},{"location":"reference/commands/songlist/#mps_youtube.commands.songlist.nextprev","title":"<code>nextprev(np, page=None)</code>","text":"<p>Get next / previous search results. </p> Source code in <code>mps_youtube\\commands\\songlist.py</code> <pre><code>@command(r'(n|p)\\s*(\\d{1,2})?')\ndef nextprev(np, page=None):\n    \"\"\" Get next / previous search results. \"\"\"\n    if isinstance(g.content, content.PaginatedContent):\n        page_count = g.content.numPages()\n        function = g.content.getPage\n        args = {}\n    else:\n        page_count = math.ceil(g.result_count/util.getxy().max_results)\n        function, args = g.last_search_query\n\n    good = False\n\n    if function:\n        if np == \"n\":\n            if g.current_page + 1 &lt; page_count:\n                g.current_page += 1\n                good = True\n\n        elif np == \"p\":\n            if page and int(page) in range(1,20):\n                g.current_page = int(page)-1\n                good = True\n\n            elif g.current_page &gt; 0:\n                g.current_page -= 1\n                good = True\n\n    if good:\n        function(page=g.current_page, **args)\n\n    else:\n        norp = \"next\" if np == \"n\" else \"previous\"\n        g.message = \"No %s items to display\" % norp\n\n    if not isinstance(g.content, content.PaginatedContent):\n        g.content = content.generate_songlist_display()\n    return good\n</code></pre>"},{"location":"reference/commands/songlist/#mps_youtube.commands.songlist.paginatesongs","title":"<code>paginatesongs(func, page=0, splash=True, dumps=False, length=None, msg=None, failmsg=None, loadmsg=None)</code>","text":"<p>A utility function for handling lists of songs, so that the pagination and the dump command will work properly.</p> <p>:param func: Either a function taking a start and end index,     or a slicable object. Either way, it should produce an iterable     of :class:<code>mps_youtube.playlist.Video</code> objects. :param page: The page number to display :param splash: Whether or not to display a splash screen while     loading. :param dumps: Used by :func:<code>dump</code> command to load all songs, instead     of only those that fit on a page :param length: The total number of songs. It it is not provided,     <code>len(func)</code> will be used instead. :param msg: Message to display after loading successfully :param failmsg: Message to display on failure (if no songs are     returned by func :param loadmsg: Message to display while loading :type page: int :type splash: bool :type dumps: bool :type length: int :type msg: str :type failmsg: str :type loadmsg: str</p> Source code in <code>mps_youtube\\commands\\songlist.py</code> <pre><code>def paginatesongs(func, page=0, splash=True, dumps=False,\n        length=None, msg=None, failmsg=None, loadmsg=None):\n    \"\"\"\n    A utility function for handling lists of songs, so that\n    the pagination and the dump command will work properly.\n\n    :param func: Either a function taking a start and end index,\n        or a slicable object. Either way, it should produce an iterable\n        of :class:`mps_youtube.playlist.Video` objects.\n    :param page: The page number to display\n    :param splash: Whether or not to display a splash screen while\n        loading.\n    :param dumps: Used by :func:`dump` command to load all songs, instead\n        of only those that fit on a page\n    :param length: The total number of songs. It it is not provided,\n        ``len(func)`` will be used instead.\n    :param msg: Message to display after loading successfully\n    :param failmsg: Message to display on failure (if no songs are\n        returned by func\n    :param loadmsg: Message to display while loading\n    :type page: int\n    :type splash: bool\n    :type dumps: bool\n    :type length: int\n    :type msg: str\n    :type failmsg: str\n    :type loadmsg: str\n    \"\"\"\n    if splash:\n        g.message = loadmsg or ''\n        g.content = content.logo(col=c.b)\n        screen.update()\n\n    max_results = util.getxy().max_results\n\n    if dumps:\n        s = 0\n        e = None\n    else:\n        s = page * max_results\n        e = (page + 1) * max_results\n\n    if callable(func):\n        songs = func(s, e)\n    else:\n        songs = func[s:e]\n\n    if length is None:\n        length = len(func)\n\n    args = {'func':func, 'length':length, 'msg':msg,\n            'failmsg':failmsg, 'loadmsg': loadmsg}\n    g.last_search_query = (paginatesongs, args)\n    g.browse_mode = \"normal\"\n    g.current_page = page\n    g.result_count = length\n    g.model.songs = songs\n    g.content = content.generate_songlist_display()\n    g.last_opened = \"\"\n    g.message = msg or ''\n    if not songs:\n        g.message = failmsg or g.message\n\n    if songs:\n        # preload first result url\n        streams.preload(songs[0], delay=0)\n</code></pre>"},{"location":"reference/commands/songlist/#mps_youtube.commands.songlist.plist","title":"<code>plist(parturl)</code>","text":"<p>Retrieve YouTube playlist. </p> Source code in <code>mps_youtube\\commands\\songlist.py</code> <pre><code>@command(r'pl\\s+%s' % PL, 'pl')\ndef plist(parturl):\n    \"\"\" Retrieve YouTube playlist. \"\"\"\n\n    if parturl in g.pafy_pls:\n        ytpl, plitems = g.pafy_pls[parturl]\n    else:\n        util.dbg(\"%sFetching playlist using pafy%s\", c.y, c.w)\n        ytpl = pafy.get_playlist(parturl)\n        plitems = util.IterSlicer(ytpl.videos)\n        g.pafy_pls[parturl] = (ytpl, plitems)\n\n    def pl_seg(s, e):\n        return [Video(i['id'], i['title'], util.parse_video_length(i['duration'])) for i in plitems[s:e]]\n\n    msg = \"Showing YouTube playlist %s\" % (c.y + ytpl.info['info']['title'] + c.w)\n    loadmsg = \"Retrieving YouTube playlist\"\n    paginatesongs(pl_seg, length=len(ytpl.videos), msg=msg, loadmsg=loadmsg)\n</code></pre>"},{"location":"reference/commands/songlist/#mps_youtube.commands.songlist.reverse_playlist","title":"<code>reverse_playlist()</code>","text":"<p>Reverse order of entire loaded playlist. </p> Source code in <code>mps_youtube\\commands\\songlist.py</code> <pre><code>@command(r'reverse all', 'reverse all')\ndef reverse_playlist():\n    \"\"\" Reverse order of entire loaded playlist. \"\"\"\n    songs = content.get_last_query()\n\n    if songs:   \n        paginatesongs(list(reversed(songs)))\n        g.message = c.y + \"Reversed entire playlist\" + c.w\n        g.content = content.generate_songlist_display()\n</code></pre>"},{"location":"reference/commands/songlist/#mps_youtube.commands.songlist.reverse_songs","title":"<code>reverse_songs()</code>","text":"<p>Reverse order of displayed items. </p> Source code in <code>mps_youtube\\commands\\songlist.py</code> <pre><code>@command(r'reverse', 'reverse')\ndef reverse_songs():\n    \"\"\" Reverse order of displayed items. \"\"\"\n    g.model.songs = g.model.songs[::-1]\n    g.message = c.y + \"Reversed displayed songs\" + c.w\n    g.content = content.generate_songlist_display()\n</code></pre>"},{"location":"reference/commands/songlist/#mps_youtube.commands.songlist.reverse_songs_range","title":"<code>reverse_songs_range(lower, upper)</code>","text":"<p>Reverse the songs within a specified range. </p> Source code in <code>mps_youtube\\commands\\songlist.py</code> <pre><code>@command(r'reverse\\s*(\\d{1,4})\\s*-\\s*(\\d{1,4})\\s*', 'reverse')\ndef reverse_songs_range(lower, upper):\n    \"\"\" Reverse the songs within a specified range. \"\"\"\n    lower, upper = int(lower), int(upper)\n    if lower &gt; upper: lower, upper = upper, lower\n\n    g.model.songs[lower-1:upper] = reversed(g.model.songs[lower-1:upper])\n    g.message = c.y + \"Reversed range: \" + str(lower) + \"-\" + str(upper) + c.w\n    g.content = content.generate_songlist_display()\n</code></pre>"},{"location":"reference/commands/songlist/#mps_youtube.commands.songlist.shuffle_fn","title":"<code>shuffle_fn()</code>","text":"<p>Shuffle displayed items. </p> Source code in <code>mps_youtube\\commands\\songlist.py</code> <pre><code>@command(r'shuffle', 'shuffle')\ndef shuffle_fn():\n    \"\"\" Shuffle displayed items. \"\"\"\n    random.shuffle(g.model.songs)\n    g.message = c.y + \"Items shuffled\" + c.w\n    g.content = content.generate_songlist_display()\n</code></pre>"},{"location":"reference/commands/songlist/#mps_youtube.commands.songlist.shuffle_playlist","title":"<code>shuffle_playlist()</code>","text":"<p>Shuffle entire loaded playlist. </p> Source code in <code>mps_youtube\\commands\\songlist.py</code> <pre><code>@command(r'shuffle all', 'shuffle all')\ndef shuffle_playlist():\n    \"\"\" Shuffle entire loaded playlist. \"\"\"\n    songs = content.get_last_query()\n\n    if songs:\n        temp_songs = list(songs)\n        random.shuffle(temp_songs)\n        paginatesongs(temp_songs)\n        g.message = c.y + \"Shuffled entire playlist\" + c.w\n        g.content = content.generate_songlist_display()\n</code></pre>"},{"location":"reference/commands/songlist/#mps_youtube.commands.songlist.songlist_mv_sw","title":"<code>songlist_mv_sw(action, a, b)</code>","text":"<p>Move a song or swap two songs. </p> Source code in <code>mps_youtube\\commands\\songlist.py</code> <pre><code>@command(r'(mv|sw)\\s*(\\d{1,4})\\s*[\\s,]\\s*(\\d{1,4})', 'mv', 'sw')\ndef songlist_mv_sw(action, a, b):\n    \"\"\" Move a song or swap two songs. \"\"\"\n    i, j = int(a) - 1, int(b) - 1\n\n    if action == \"mv\":\n        g.model.songs.insert(j, g.model.songs.pop(i))\n        g.message = util.F('song move') % (g.model[j].title, b)\n\n    elif action == \"sw\":\n        g.model[i], g.model[j] = g.model[j], g.model[i]\n        g.message = util.F('song sw') % (min(a, b), max(a, b))\n\n    g.content = content.generate_songlist_display()\n</code></pre>"},{"location":"reference/commands/songlist/#mps_youtube.commands.songlist.songlist_rm_add","title":"<code>songlist_rm_add(action, songrange)</code>","text":"<p>Remove or add tracks. works directly on user input. </p> Source code in <code>mps_youtube\\commands\\songlist.py</code> <pre><code>@command(r'(rm|add)\\s*(-?\\d[-,\\d\\s]{,250})', 'rm', 'add')\ndef songlist_rm_add(action, songrange):\n    \"\"\" Remove or add tracks. works directly on user input. \"\"\"\n    selection = util.parse_multi(songrange)\n\n    if action == \"add\":\n        duplicate_songs = []\n        for songnum in selection:\n            if g.model[songnum - 1] in g.active:\n                duplicate_songs.append(str(songnum))\n            g.active.songs.append(g.model[songnum - 1])\n\n        d = g.active.duration\n        g.message = util.F('added to pl') % (len(selection), len(g.active), d)\n        if duplicate_songs:\n            duplicate_songs = ', '.join(sorted(duplicate_songs))\n            g.message += '\\n'\n            g.message += util.F('duplicate tracks') % duplicate_songs\n\n    elif action == \"rm\":\n        selection = sorted(set(selection), reverse=True)\n        removed = str(tuple(reversed(selection))).replace(\",\", \"\")\n\n        for x in selection:\n            g.model.songs.pop(x - 1)\n            try:\n                g.active.songs.pop(g.current_page * util.getxy().max_results + x - 1)\n            except IndexError:\n                pass\n\n        g.message = util.F('songs rm') % (len(selection), removed)\n\n    g.content = content.generate_songlist_display()\n</code></pre>"},{"location":"reference/commands/spotify_playlist/","title":"spotify_playlist.py","text":""},{"location":"reference/commands/spotify_playlist/#mps_youtube.commands.spotify_playlist.generate_credentials","title":"<code>generate_credentials()</code>","text":"<p>Generate the token. Please respect these credentials :)</p> Source code in <code>mps_youtube\\commands\\spotify_playlist.py</code> <pre><code>def generate_credentials():\n    \"\"\"Generate the token. Please respect these credentials :)\"\"\"\n    credentials = oauth2.SpotifyClientCredentials(\n        client_id='6451e12933bb49ed8543d41e3296a88d',\n        client_secret='40ef54678fe441bd9acd66f5d5c34e69')\n    return credentials\n</code></pre>"},{"location":"reference/commands/spotify_playlist/#mps_youtube.commands.spotify_playlist.search_playlist","title":"<code>search_playlist(term, spotify=None)</code>","text":"<p>Search for Spotify playlist. </p> Source code in <code>mps_youtube\\commands\\spotify_playlist.py</code> <pre><code>@command(r'splaylist\\s*(.*[-_a-zA-Z0-9].*)?', 'splaylist')\ndef search_playlist(term, spotify=None):\n    \"\"\"Search for Spotify playlist. \"\"\"\n    # pylint: disable=R0914,R0912\n    if has_spotipy:\n\n        if not term:\n            show_message(\"Enter playlist url:\", c.g, update=True)\n            term = input(\"&gt; \")\n\n            if not term or len(term) &lt; 2:\n                g.message = c.r + \"Not enough input!\" + c.w\n                g.content = None#content.generate_songlist_display()\n                return\n\n        if not spotify:\n            credentials = generate_credentials()\n            token = credentials.get_access_token()\n            spotify = spotipy.Spotify(auth=token)\n\n        try:\n            playlist, tracks = grab_playlist(spotify, term)\n        except TypeError:\n            tracks = None\n\n        if not tracks:\n            show_message(\"Playlist '%s' not found!\" % term)\n            return\n\n        if not playlist['tracks']['total']:\n            show_message(\"Playlist '%s' by '%s' has 0 tracks!\" % (playlist['name'], playlist['owner']['id']))\n            return\n\n        msg = \"%s%s%s by %s%s%s\\n\\n\" % (c.g, playlist['name'], c.w, c.g, playlist['owner']['id'], c.w)\n        msg += \"Enter to begin matching or [q] to abort\"\n        g.message = msg\n        g.content = \"Tracks:\\n\"\n        for n, track in enumerate(tracks, 1):\n            trackname = '{0:&lt;20} - {1}'.format(track['artists'][0]['name'], track['name'])\n            g.content += \"%03s  %s\" % (n, trackname)\n            g.content += \"\\n\"\n\n        screen.update()\n        entry = input(\"Continue? [Enter] &gt; \")\n\n        if entry == \"\":\n            pass\n\n        else:\n            show_message(\"Playlist search abandoned!\")\n            return\n\n        songs = []\n        screen.clear()\n        itt = _match_tracks(tracks)\n\n        stash = config.SEARCH_MUSIC.get, config.ORDER.get\n        config.SEARCH_MUSIC.value = True\n        config.ORDER.value = \"relevance\"\n\n        try:\n            songs.extend(itt)\n\n        except KeyboardInterrupt:\n            util.xprint(\"%sHalted!%s\" % (c.r, c.w))\n\n        finally:\n            config.SEARCH_MUSIC.value, config.ORDER.value = stash\n\n        if songs:\n            util.xprint(\"\\n%s / %s songs matched\" % (len(songs), len(tracks)))\n            input(\"Press Enter to continue\")\n\n        msg = \"Contents of playlist %s%s - %s%s %s(%d/%d)%s:\" % (\n            c.y, playlist['owner']['id'], playlist['name'], c.w, c.b, len(songs), len(tracks), c.w)\n        failmsg = \"Found no playlist tracks for %s%s%s\" % (c.y, playlist['name'], c.w)\n\n        paginatesongs(songs, msg=msg, failmsg=failmsg)\n\n    else:\n        g.message = \"spotipy module must be installed for Spotify support\\n\"\n        g.message += \"see https://pypi.python.org/pypi/spotipy/\"\n</code></pre>"},{"location":"reference/commands/spotify_playlist/#mps_youtube.commands.spotify_playlist.search_user","title":"<code>search_user(term)</code>","text":"<p>Search for Spotify user playlists. </p> Source code in <code>mps_youtube\\commands\\spotify_playlist.py</code> <pre><code>@command(r'suser\\s*(.*[-_a-zA-Z0-9].*)?', 'suser')\ndef search_user(term):\n    \"\"\"Search for Spotify user playlists. \"\"\"\n    # pylint: disable=R0914,R0912\n    if has_spotipy:\n\n        if not term:\n            show_message(\"Enter username:\", c.g, update=True)\n            term = input(\"&gt; \")\n\n            if not term or len(term) &lt; 2:\n                g.message = c.r + \"Not enough input!\" + c.w\n                g.content = None#content.generate_songlist_display()\n                return\n\n        credentials = generate_credentials()\n        token = credentials.get_access_token()\n        spotify = spotipy.Spotify(auth=token)\n\n        playlists = spotify.user_playlists(term)\n        links = []\n        check = 1\n\n        g.content = \"Playlists:\\n\"\n\n        while True:\n            for playlist in playlists['items']:\n                if playlist['name'] is not None:\n                    g.content += (u'{0:&gt;2}. {1:&lt;30}  ({2} tracks)'.format(\n                        check, playlist['name'],\n                        playlist['tracks']['total']))\n                    g.content += \"\\n\"\n                    links.append(playlist)\n                    check += 1\n            if playlists['next']:\n                playlists = spotify.next(playlists)\n            else:\n                break\n\n        g.message = c.g + \"Choose your playlist:\" + c.w\n        screen.update()\n\n        choice = int(input(\"&gt; \"))\n        playlist = links[choice-1]\n\n        search_playlist(playlist['external_urls']['spotify'], spotify=spotify)\n\n    else:\n        g.message = \"spotipy module must be installed for Spotify support\\n\"\n        g.message += \"see https://pypi.python.org/pypi/spotipy/\"\n</code></pre>"},{"location":"reference/commands/spotify_playlist/#mps_youtube.commands.spotify_playlist.show_message","title":"<code>show_message(message, col='', update=False)</code>","text":"<p>Show message using col, update screen if required. </p> Source code in <code>mps_youtube\\commands\\spotify_playlist.py</code> <pre><code>def show_message(message, col=c.r, update=False):\n    \"\"\" Show message using col, update screen if required. \"\"\"\n    g.content = content.generate_songlist_display()\n    g.message = col + message + c.w\n\n    if update:\n        screen.update()\n</code></pre>"},{"location":"reference/listview/__init__/","title":"init","text":"<p>DOCSTING COMES HERE</p>"},{"location":"reference/listview/__init__/#mps_youtube.listview.__init__.ListView","title":"<code> ListView            (PaginatedContent)         </code>","text":"<p>Content Agnostic Numbered List</p> <p>This class, using ListViewItems as abstractions you can give it a list of data and which columns to show and it will show it.</p> <p>Todo</p> <p>Currently we rely on the commands/play code to send information about which elements are being picked.</p> <p>Column format:     {\"name\": \"idx\", \"size\": 3, \"heading\": \"Num\"}     name:    The method name that will be called from the ListViewItem     !!! size \"How much size is allocated to the columns,\"              see ListView.content for more information about              the dynamic options     heading: The text shown in the header</p> <pre><code>\"idx\" is generated in the content function, not by the ListViewItem\n</code></pre> Source code in <code>mps_youtube\\listview\\__init__.py</code> <pre><code>class ListView(content.PaginatedContent):\n    \"\"\" Content Agnostic Numbered List\n\n        This class, using ListViewItems as abstractions you can\n        give it a list of data and which columns to show and it will\n        show it.\n\n        Todo:\n            Currently we rely on the commands/play code to send information\n            about which elements are being picked.\n\n        Attributes:\n            func        The function that will be run on the selected items\n            objects     List of objects(or a ContentQuery object)\n            columns     A list of Hashes containing information about which\n                        columns to show\n            page        Current Page\n\n        Column format:\n            {\"name\": \"idx\", \"size\": 3, \"heading\": \"Num\"}\n            name:    The method name that will be called from the ListViewItem\n            size:    How much size is allocated to the columns,\n                     see ListView.content for more information about\n                     the dynamic options\n            heading: The text shown in the header\n\n            \"idx\" is generated in the content function, not by the ListViewItem\n    \"\"\"\n    func = None\n    objects = None\n    columns = None\n    page = 0\n\n    def __init__(self, columns, objects, function_call=None):\n        \"\"\" \"\"\"\n        self.func = function_call\n        self.objects = objects\n        self.columns = columns\n        self.object_type = None\n\n        # Ensure single type of object\n        types = len(set([obj.__class__ for obj in objects]))\n        if types == 0:\n            raise BaseException(\"No objects in list\")\n        if types &gt; 1:\n            raise BaseException(\"More than one kind of objects in list\")\n\n        self.object_type = [obj.__class__ for obj in objects][0]\n\n    def numPages(self):\n        \"\"\" Returns # of pages \"\"\"\n        return max(1, math.ceil(len(self.objects) / self.views_per_page()))\n\n    def getPage(self, page):\n        self.page = page\n        return self.content()\n\n    def _page_slice(self):\n        chgt = self.views_per_page()\n        return slice(self.page * chgt, (self.page+1) * chgt)\n\n    def content(self):\n        \"\"\" Generates content\n\n            ===============\n            Dynamic fields\n            ===============\n\n            Column.size may instead of an integer be a string\n            containing either \"length\" or \"remaining\".\n\n            Length is for time formats like 20:40\n            Remaining will allocate all remaining space to that\n            column.\n\n            TODO: Make it so set columns can set \"remaining\" ?\n        \"\"\"\n        # Sums all ints, deal with strings later\n        remaining = (util.getxy().width) - sum(1 + (x['size'] if x['size'] and x['size'].__class__ == int else 0) for x in self.columns) - (len(self.columns))\n        lengthsize = 0\n        if \"length\" in [x['size'] for x in self.columns]:\n            max_l = max((getattr(x, \"length\")() for x in self.objects))\n            lengthsize = 8 if max_l &gt; 35999 else 7\n            lengthsize = 6 if max_l &lt; 6000 else lengthsize\n\n        for col in self.columns:\n            if col['size'] == \"remaining\":\n                col['size'] = remaining - lengthsize\n            if col['size'] == \"length\":\n                col['size'] = lengthsize\n\n        for num, column in enumerate(self.columns):\n            column['idx'] = num\n            column['sign'] = \"-\" if not column['name'] == \"length\" else \"\"\n\n        fmt = [\"%{}{}s  \".format(x['sign'], x['size']) for x in self.columns]\n        fmtrow = fmt[0:1] + [\"%s  \"] + fmt[2:]\n        fmt, fmtrow = \"\".join(fmt).strip(), \"\".join(fmtrow).strip()\n        titles = tuple([x['heading'][:x['size']] for x in self.columns])\n        out = \"\\n\" + (c.ul + fmt % titles + c.w) + \"\\n\"\n\n        for num, obj in enumerate(self.objects[self._page_slice()]):\n            col = (c.r if num % 2 == 0 else c.p)\n            idx = num + (self.views_per_page() * self.page) + 1\n\n            line = ''\n            for column in self.columns:\n                fieldsize, field = column['size'], column['name']\n                direction = \"&lt;\" if column['sign'] == \"-\" else \"&gt;\"\n\n                if field == \"idx\":\n                    field = \"%2d\" % idx\n\n                else:\n                    field = getattr(obj, field)(fieldsize)\n                    field = str(field) if field.__class__ != str else field\n\n                line += util.uea_pad(fieldsize, field, direction)\n\n                if column != self.columns[-1]:\n                    line += \"  \"\n\n            line = col + line + c.w\n            out += line + \"\\n\"\n\n        return out\n\n    def _play(self, _, choice, __):  # pre, choice, post\n        \"\"\" Handles what happends when a user selects something from the list\n            Currently this functions hooks into commands/play\n        \"\"\"\n\n        uids = []\n        for splitted_choice in choice.split(\",\"):\n            cho = splitted_choice.strip()\n            if cho.isdigit():\n                uids.append(int(cho) - 1)\n            else:\n                cho = cho.split(\"-\")\n                if cho[0].isdigit() and cho[1].isdigit():\n                    uids += list(range(int(cho[0]) - 1, int(cho[1])))\n\n        var = getattr(self.object_type, \"return_field\")()\n        self.func([getattr(self.objects[x], var)() for x in uids])\n\n    def views_per_page(self):\n        \"\"\" Determines how many views can be per page\n        \"\"\"\n        return util.getxy().max_results\n</code></pre>"},{"location":"reference/listview/__init__/#mps_youtube.listview.__init__.ListView.content","title":"<code>content(self)</code>","text":"<p>Generates content</p> <p>=============== Dynamic fields ===============</p> <p>Column.size may instead of an integer be a string containing either \"length\" or \"remaining\".</p> <p>Length is for time formats like 20:40 Remaining will allocate all remaining space to that column.</p> <p>TODO: Make it so set columns can set \"remaining\" ?</p> Source code in <code>mps_youtube\\listview\\__init__.py</code> <pre><code>def content(self):\n    \"\"\" Generates content\n\n        ===============\n        Dynamic fields\n        ===============\n\n        Column.size may instead of an integer be a string\n        containing either \"length\" or \"remaining\".\n\n        Length is for time formats like 20:40\n        Remaining will allocate all remaining space to that\n        column.\n\n        TODO: Make it so set columns can set \"remaining\" ?\n    \"\"\"\n    # Sums all ints, deal with strings later\n    remaining = (util.getxy().width) - sum(1 + (x['size'] if x['size'] and x['size'].__class__ == int else 0) for x in self.columns) - (len(self.columns))\n    lengthsize = 0\n    if \"length\" in [x['size'] for x in self.columns]:\n        max_l = max((getattr(x, \"length\")() for x in self.objects))\n        lengthsize = 8 if max_l &gt; 35999 else 7\n        lengthsize = 6 if max_l &lt; 6000 else lengthsize\n\n    for col in self.columns:\n        if col['size'] == \"remaining\":\n            col['size'] = remaining - lengthsize\n        if col['size'] == \"length\":\n            col['size'] = lengthsize\n\n    for num, column in enumerate(self.columns):\n        column['idx'] = num\n        column['sign'] = \"-\" if not column['name'] == \"length\" else \"\"\n\n    fmt = [\"%{}{}s  \".format(x['sign'], x['size']) for x in self.columns]\n    fmtrow = fmt[0:1] + [\"%s  \"] + fmt[2:]\n    fmt, fmtrow = \"\".join(fmt).strip(), \"\".join(fmtrow).strip()\n    titles = tuple([x['heading'][:x['size']] for x in self.columns])\n    out = \"\\n\" + (c.ul + fmt % titles + c.w) + \"\\n\"\n\n    for num, obj in enumerate(self.objects[self._page_slice()]):\n        col = (c.r if num % 2 == 0 else c.p)\n        idx = num + (self.views_per_page() * self.page) + 1\n\n        line = ''\n        for column in self.columns:\n            fieldsize, field = column['size'], column['name']\n            direction = \"&lt;\" if column['sign'] == \"-\" else \"&gt;\"\n\n            if field == \"idx\":\n                field = \"%2d\" % idx\n\n            else:\n                field = getattr(obj, field)(fieldsize)\n                field = str(field) if field.__class__ != str else field\n\n            line += util.uea_pad(fieldsize, field, direction)\n\n            if column != self.columns[-1]:\n                line += \"  \"\n\n        line = col + line + c.w\n        out += line + \"\\n\"\n\n    return out\n</code></pre>"},{"location":"reference/listview/__init__/#mps_youtube.listview.__init__.ListView.numPages","title":"<code>numPages(self)</code>","text":"<p>Returns # of pages </p> Source code in <code>mps_youtube\\listview\\__init__.py</code> <pre><code>def numPages(self):\n    \"\"\" Returns # of pages \"\"\"\n    return max(1, math.ceil(len(self.objects) / self.views_per_page()))\n</code></pre>"},{"location":"reference/listview/__init__/#mps_youtube.listview.__init__.ListView.views_per_page","title":"<code>views_per_page(self)</code>","text":"<p>Determines how many views can be per page</p> Source code in <code>mps_youtube\\listview\\__init__.py</code> <pre><code>def views_per_page(self):\n    \"\"\" Determines how many views can be per page\n    \"\"\"\n    return util.getxy().max_results\n</code></pre>"},{"location":"reference/listview/base/","title":"base.py","text":""},{"location":"reference/listview/base/#mps_youtube.listview.base.ListViewItem","title":"<code> ListViewItem        </code>","text":"<p>Base class for items Used by Listview</p> Source code in <code>mps_youtube\\listview\\base.py</code> <pre><code>class ListViewItem:\n    \"\"\" Base class for items\n        Used by Listview\n    \"\"\"\n    data = None\n\n    def __init__(self, data):\n        self.data = data\n\n    def __getattr__(self, key):\n        return self.data[key] if key in self.data.keys() else None\n\n    def length(self, _=0):\n        \"\"\" Returns length of ListViewItem\n            A LVI has to return something for length\n            even if the item does not have one.\n        \"\"\"\n        return 0\n</code></pre>"},{"location":"reference/listview/base/#mps_youtube.listview.base.ListViewItem.length","title":"<code>length(self, _=0)</code>","text":"<p>Returns length of ListViewItem A LVI has to return something for length even if the item does not have one.</p> Source code in <code>mps_youtube\\listview\\base.py</code> <pre><code>def length(self, _=0):\n    \"\"\" Returns length of ListViewItem\n        A LVI has to return something for length\n        even if the item does not have one.\n    \"\"\"\n    return 0\n</code></pre>"},{"location":"reference/listview/livestream/","title":"livestream.py","text":""},{"location":"reference/listview/livestream/#mps_youtube.listview.livestream.ListLiveStream","title":"<code> ListLiveStream            (ListViewItem)         </code>","text":"<p>Class exposing necessary components of a live stream </p> Source code in <code>mps_youtube\\listview\\livestream.py</code> <pre><code>class ListLiveStream(ListViewItem):\n    \"\"\" Class exposing necessary components of a live stream \"\"\"\n    # pylint: disable=unused-argument\n    def ytid(self, lngt=10):\n        \"\"\" Exposes ytid(string) \"\"\"\n        return self.data.get(\"id\").get(\"videoId\")\n\n    def ret(self):\n        \"\"\" Returns content.video compatible tuple \"\"\"\n        return (self.ytid(), self.title(), self.length())\n\n    def title(self, lngt=10):\n        \"\"\" exposes title \"\"\"\n        return util.uea_pad(lngt, self.data.get(\"snippet\").get(\"title\"))\n    def description(self, lngt=10):\n        \"\"\" exposes description \"\"\"\n        return util.uea_pad(lngt, self.data.get(\"snippet\").get(\"description\"))\n\n    @staticmethod\n    def return_field():\n        \"\"\" ret \"\"\"\n        return \"ret\"\n</code></pre>"},{"location":"reference/listview/livestream/#mps_youtube.listview.livestream.ListLiveStream.description","title":"<code>description(self, lngt=10)</code>","text":"<p>exposes description </p> Source code in <code>mps_youtube\\listview\\livestream.py</code> <pre><code>def description(self, lngt=10):\n    \"\"\" exposes description \"\"\"\n    return util.uea_pad(lngt, self.data.get(\"snippet\").get(\"description\"))\n</code></pre>"},{"location":"reference/listview/livestream/#mps_youtube.listview.livestream.ListLiveStream.ret","title":"<code>ret(self)</code>","text":"<p>Returns content.video compatible tuple </p> Source code in <code>mps_youtube\\listview\\livestream.py</code> <pre><code>def ret(self):\n    \"\"\" Returns content.video compatible tuple \"\"\"\n    return (self.ytid(), self.title(), self.length())\n</code></pre>"},{"location":"reference/listview/livestream/#mps_youtube.listview.livestream.ListLiveStream.return_field","title":"<code>return_field()</code>  <code>staticmethod</code>","text":"<p>ret </p> Source code in <code>mps_youtube\\listview\\livestream.py</code> <pre><code>@staticmethod\ndef return_field():\n    \"\"\" ret \"\"\"\n    return \"ret\"\n</code></pre>"},{"location":"reference/listview/livestream/#mps_youtube.listview.livestream.ListLiveStream.title","title":"<code>title(self, lngt=10)</code>","text":"<p>exposes title </p> Source code in <code>mps_youtube\\listview\\livestream.py</code> <pre><code>def title(self, lngt=10):\n    \"\"\" exposes title \"\"\"\n    return util.uea_pad(lngt, self.data.get(\"snippet\").get(\"title\"))\n</code></pre>"},{"location":"reference/listview/livestream/#mps_youtube.listview.livestream.ListLiveStream.ytid","title":"<code>ytid(self, lngt=10)</code>","text":"<p>Exposes ytid(string) </p> Source code in <code>mps_youtube\\listview\\livestream.py</code> <pre><code>def ytid(self, lngt=10):\n    \"\"\" Exposes ytid(string) \"\"\"\n    return self.data.get(\"id\").get(\"videoId\")\n</code></pre>"},{"location":"reference/listview/songtitle/","title":"songtitle.py","text":""},{"location":"reference/listview/songtitle/#mps_youtube.listview.songtitle.ListSongtitle","title":"<code> ListSongtitle            (ListViewItem)         </code>","text":"<p>Describes a user</p> Source code in <code>mps_youtube\\listview\\songtitle.py</code> <pre><code>class ListSongtitle(ListViewItem):\n    \"\"\" Describes a user\n    \"\"\"\n    # pylint: disable=unused-argument\n    _checked = False\n    _certainty = 1.0\n\n    def __init__(self, data, certainty=1.0):\n        self._checked = True\n        self._certainty = certainty\n        super(ListSongtitle, self).__init__(data)\n\n    def artist(self, l=10):\n        \"\"\" Get artist \"\"\"\n        return u.uea_pad(l, self.data[0])\n\n    def title(self, l=10):\n        \"\"\" Get title \"\"\"\n        return u.uea_pad(l, self.data[1])\n\n    def checked(self, l=10):\n        \"\"\" String from for checked \"\"\"\n        return \"  X  \" if self._checked else \"     \"\n\n    def certainty(self):\n        \"\"\" Float \"\"\"\n        return self._certainty\n\n    def is_checked(self):\n        \"\"\" Returns true if checked \"\"\"\n        return self._checked\n\n    def toggle(self):\n        \"\"\" Toggle checked status \"\"\"\n        self._checked = not self._checked\n\n    def ret(self):\n        \"\"\" Used in the ListView play function \"\"\"\n        return \"%s - %s\" % (self.artist().strip(), self.title().strip())\n\n    @staticmethod\n    def return_field():\n        \"\"\" Determines which function will be called on selected items \"\"\"\n        return \"ret\"\n</code></pre>"},{"location":"reference/listview/songtitle/#mps_youtube.listview.songtitle.ListSongtitle.artist","title":"<code>artist(self, l=10)</code>","text":"<p>Get artist </p> Source code in <code>mps_youtube\\listview\\songtitle.py</code> <pre><code>def artist(self, l=10):\n    \"\"\" Get artist \"\"\"\n    return u.uea_pad(l, self.data[0])\n</code></pre>"},{"location":"reference/listview/songtitle/#mps_youtube.listview.songtitle.ListSongtitle.certainty","title":"<code>certainty(self)</code>","text":"<p>Float </p> Source code in <code>mps_youtube\\listview\\songtitle.py</code> <pre><code>def certainty(self):\n    \"\"\" Float \"\"\"\n    return self._certainty\n</code></pre>"},{"location":"reference/listview/songtitle/#mps_youtube.listview.songtitle.ListSongtitle.checked","title":"<code>checked(self, l=10)</code>","text":"<p>String from for checked </p> Source code in <code>mps_youtube\\listview\\songtitle.py</code> <pre><code>def checked(self, l=10):\n    \"\"\" String from for checked \"\"\"\n    return \"  X  \" if self._checked else \"     \"\n</code></pre>"},{"location":"reference/listview/songtitle/#mps_youtube.listview.songtitle.ListSongtitle.is_checked","title":"<code>is_checked(self)</code>","text":"<p>Returns true if checked </p> Source code in <code>mps_youtube\\listview\\songtitle.py</code> <pre><code>def is_checked(self):\n    \"\"\" Returns true if checked \"\"\"\n    return self._checked\n</code></pre>"},{"location":"reference/listview/songtitle/#mps_youtube.listview.songtitle.ListSongtitle.ret","title":"<code>ret(self)</code>","text":"<p>Used in the ListView play function </p> Source code in <code>mps_youtube\\listview\\songtitle.py</code> <pre><code>def ret(self):\n    \"\"\" Used in the ListView play function \"\"\"\n    return \"%s - %s\" % (self.artist().strip(), self.title().strip())\n</code></pre>"},{"location":"reference/listview/songtitle/#mps_youtube.listview.songtitle.ListSongtitle.return_field","title":"<code>return_field()</code>  <code>staticmethod</code>","text":"<p>Determines which function will be called on selected items </p> Source code in <code>mps_youtube\\listview\\songtitle.py</code> <pre><code>@staticmethod\ndef return_field():\n    \"\"\" Determines which function will be called on selected items \"\"\"\n    return \"ret\"\n</code></pre>"},{"location":"reference/listview/songtitle/#mps_youtube.listview.songtitle.ListSongtitle.title","title":"<code>title(self, l=10)</code>","text":"<p>Get title </p> Source code in <code>mps_youtube\\listview\\songtitle.py</code> <pre><code>def title(self, l=10):\n    \"\"\" Get title \"\"\"\n    return u.uea_pad(l, self.data[1])\n</code></pre>"},{"location":"reference/listview/songtitle/#mps_youtube.listview.songtitle.ListSongtitle.toggle","title":"<code>toggle(self)</code>","text":"<p>Toggle checked status </p> Source code in <code>mps_youtube\\listview\\songtitle.py</code> <pre><code>def toggle(self):\n    \"\"\" Toggle checked status \"\"\"\n    self._checked = not self._checked\n</code></pre>"},{"location":"reference/listview/user/","title":"user.py","text":""},{"location":"reference/listview/user/#mps_youtube.listview.user.ListUser","title":"<code> ListUser            (ListViewItem)         </code>","text":"<p>Describes a user</p> Source code in <code>mps_youtube\\listview\\user.py</code> <pre><code>class ListUser(ListViewItem):\n    \"\"\" Describes a user\n    \"\"\"\n    # pylint: disable=unused-argument\n    def id(self, length=0):\n        \"\"\" Returns YTID \"\"\"\n        return self.data.get(\"id\")\n\n    def name(self, length=10):\n        \"\"\" Returns channel name \"\"\"\n        return u.uea_pad(length, self.data.get(\"title\"))\n\n    def description(self, length=10):\n        \"\"\" Channel description\"\"\"\n        return u.uea_pad(length, self.data[\"descriptionSnippet\"][0]['text'] if self.data['descriptionSnippet'] is not None else 'No description found')\n\n    def kind(self, length=10):\n        \"\"\" Returns the youtube datatype\n            Example: youtube#channel, youtube#video\n        \"\"\"\n        return self.data.get(\"type\")\n\n    def ret(self):\n        \"\"\" Used in the ListView play function \"\"\"\n        return (self.name(), self.id(), \"\")\n\n    @staticmethod\n    def return_field():\n        \"\"\" Determines which function will be called on selected items \"\"\"\n        return \"ret\"\n</code></pre>"},{"location":"reference/listview/user/#mps_youtube.listview.user.ListUser.description","title":"<code>description(self, length=10)</code>","text":"<p>Channel description</p> Source code in <code>mps_youtube\\listview\\user.py</code> <pre><code>def description(self, length=10):\n    \"\"\" Channel description\"\"\"\n    return u.uea_pad(length, self.data[\"descriptionSnippet\"][0]['text'] if self.data['descriptionSnippet'] is not None else 'No description found')\n</code></pre>"},{"location":"reference/listview/user/#mps_youtube.listview.user.ListUser.id","title":"<code>id(self, length=0)</code>","text":"<p>Returns YTID </p> Source code in <code>mps_youtube\\listview\\user.py</code> <pre><code>def id(self, length=0):\n    \"\"\" Returns YTID \"\"\"\n    return self.data.get(\"id\")\n</code></pre>"},{"location":"reference/listview/user/#mps_youtube.listview.user.ListUser.kind","title":"<code>kind(self, length=10)</code>","text":"<p>Returns the youtube datatype Example: youtube#channel, youtube#video</p> Source code in <code>mps_youtube\\listview\\user.py</code> <pre><code>def kind(self, length=10):\n    \"\"\" Returns the youtube datatype\n        Example: youtube#channel, youtube#video\n    \"\"\"\n    return self.data.get(\"type\")\n</code></pre>"},{"location":"reference/listview/user/#mps_youtube.listview.user.ListUser.name","title":"<code>name(self, length=10)</code>","text":"<p>Returns channel name </p> Source code in <code>mps_youtube\\listview\\user.py</code> <pre><code>def name(self, length=10):\n    \"\"\" Returns channel name \"\"\"\n    return u.uea_pad(length, self.data.get(\"title\"))\n</code></pre>"},{"location":"reference/listview/user/#mps_youtube.listview.user.ListUser.ret","title":"<code>ret(self)</code>","text":"<p>Used in the ListView play function </p> Source code in <code>mps_youtube\\listview\\user.py</code> <pre><code>def ret(self):\n    \"\"\" Used in the ListView play function \"\"\"\n    return (self.name(), self.id(), \"\")\n</code></pre>"},{"location":"reference/listview/user/#mps_youtube.listview.user.ListUser.return_field","title":"<code>return_field()</code>  <code>staticmethod</code>","text":"<p>Determines which function will be called on selected items </p> Source code in <code>mps_youtube\\listview\\user.py</code> <pre><code>@staticmethod\ndef return_field():\n    \"\"\" Determines which function will be called on selected items \"\"\"\n    return \"ret\"\n</code></pre>"},{"location":"reference/players/GenericPlayer/","title":"GenericPlayer.py","text":""},{"location":"reference/players/GenericPlayer/#mps_youtube.players.GenericPlayer.GenericPlayer","title":"<code> GenericPlayer            (CmdPlayer)         </code>","text":"Source code in <code>mps_youtube\\players\\genericplayer.py</code> <pre><code>class GenericPlayer(CmdPlayer):\n    def __init__(self, player):\n        self.player = player\n\n    def _generate_real_playerargs(self):\n        '''Generates player arguments to called using Popen\n\n        '''\n        args = config.PLAYERARGS.get.strip().split()\n\n        ############################################\n        # Define your arguments below this line\n\n        ###########################################\n\n        return [self.player] + args + [self.stream['url']]\n\n    def clean_up(self):\n        ''' Cleans up temp files after process exits.\n\n        '''\n        pass\n\n    def launch_player(self, cmd):\n\n        ##################################################\n        # Change this however you want\n\n        with open(os.devnull, \"w\") as devnull:\n            self.p = subprocess.Popen(cmd, shell=False, stderr=devnull)\n        self.p.wait()\n\n        ##################################################\n\n        # Donot forget self.next()\n        self.next()\n\n    def _help(self, short=True):\n        ''' Help keys shown when the song is played.\n\n        See mpv.py for reference.\n\n        '''\n        pass\n</code></pre>"},{"location":"reference/players/GenericPlayer/#mps_youtube.players.GenericPlayer.GenericPlayer.clean_up","title":"<code>clean_up(self)</code>","text":"<p>Cleans up temp files after process exits.</p> Source code in <code>mps_youtube\\players\\genericplayer.py</code> <pre><code>def clean_up(self):\n    ''' Cleans up temp files after process exits.\n\n    '''\n    pass\n</code></pre>"},{"location":"reference/players/__init__/","title":"init","text":""},{"location":"reference/players/mplayer/","title":"mplayer.py","text":""},{"location":"reference/players/mpv/","title":"mpv.py","text":""},{"location":"reference/players/vlc/","title":"vlc.py","text":""}]}